var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/constants.js
var require_constants = __commonJS({
  "src/constants.js"(exports2, module2) {
    var extensionPrefix = `ui-geeks-ext-package-dep`;
    var REPORT_TITLE = "Package Dependency Report";
    var REPORT_TEMPLATE = "dependency-report";
    var REPORT_FOLDER_NAME = "ui-geeks-ext-npm-dependencies";
    var REPORT_FILE_NAME = "package-dep-report";
    var COMMANDS2 = {
      DEPENDENCY: `${extensionPrefix}.runGetDependency`
    };
    var DEPENDENCY_META = {
      dependency: {
        dependencyType: "Dependencies",
        hint: `It contains all the packages that are required in the production or testing environments. These will be included in bundled code.`
      },
      devDependency: {
        dependencyType: "Dev Dependencies",
        hint: `It contains all the packages that are required in the development || phase of the project and not in the production or testing environments.`
      },
      peerDependencies: {
        dependencyType: "Peer Dependencies",
        hint: `Having a peer dependency means that our package needs a dependency that is the same exact dependency as the person installing our package.`
      }
    };
    var MSGS = {
      PACKAGE_JSON_NOT_FOUND: `Error: package.json file not found!`,
      INVALID_SELECTION: `Invalid Selection`,
      REPORT_PDF_CREATED: `A PDF file named '${REPORT_FILE_NAME}.pdf' is download in folder '${REPORT_FOLDER_NAME}'.


  Note: Folder will automatically be deleted on closing the '${REPORT_TITLE}' tab.`,
      PDF_ERROR: `Error generating PDF Report. Please try again later. Error: ##MESSAGE##.`,
      PREPARING_PDF: `Generating PDF, please wait...`
    };
    var COMMON_CSS = `
body { font-size: 1.2em; background-color: #f6f6f6; color: black; -webkit-print-color-adjust: exact; }
.b { font-weight: bold; }
.i { font-style: italic; }
.text-center { text-align:center; }
.text-right { text-align:right; }
.mb-1 { margin-bottom:10px; }
.pl-1 { padding-left:10px; }
.pl-2 { padding-left:20px; }
.mb-2 { margin-bottom:20px; }
.mt-1 { margin-top:10px; }
.mt-2 { margin-top:20px; }
.p-2 { padding:20px; }
.color-grey { color: #7a7a7a}
.text-danger{ color:red}
.text-warning { color:#9a5919}
.no-link { text-decoration:none;  }
.no-link:hover { color: #7a7a7a;}
.content { display: flex; flex-direction: row; justify-content: space-between; gap:10px; }
.content-box{ flex:1;} 
.field-label { text-align:center; font-style: italic; }
.field-value { font-weight: bold; text-align:center; }
.header-section { margin-bottom: 0;font-size: 1em;  }
.hint { font-size: 0.9em;font-style: italic; color: #a5a4a4; margin-bottom: 20px; }
.table { width: 100%;max-width: 100%; margin-bottom: 1rem;}
.table th, .table td { padding: 0.75rem;vertical-align: top; border-top: 1px solid #eceeef;background-color: #e7e9eb;color: black;}
.table thead th { vertical-align: bottom; border-bottom: 2px solid #eceeef; text-align: left; }
.table tbody + tbody { border-top: 2px solid #eceeef; }
.table { background-color: #fff; }
.table-sm th,.table-sm td { padding: 0.3rem;}
.table-bordered { border: 1px solid #eceeef;}
.table-bordered th, .table-bordered td { border: 1px solid #eceeef;}
.table-bordered thead th, .table-bordered thead td { border-bottom-width: 2px; }
.box{ padding:10px; border:1px solid #c0c0c0; margin-bottom: 20px; border-radius: 4px; background:#c0c0c0; }
.box-critical {background: #ff2f2f; }
.box-high { background: #ffa9a9; }
.box-moderate { background: #ffd49f; }
.box-low { background: #f8ffe5; }
.box-info { background: #e2faff; }
.box-success { background: green;}
.compat-update { border-left: 5px solid green; }
.breaking-update { border-left: 5px solid #cf6321; }
.fix-green { color: green; }
.fix-yellow { color: cf6321; }
.email-link { font-size:20px; position:absolute; right: 20px; margin-top:20px; }
.email-link a.no-link { font-size:16px; }
`;
    module2.exports = {
      MSGS,
      extensionPrefix,
      COMMANDS: COMMANDS2,
      COMMON_CSS,
      REPORT_FILE_NAME,
      REPORT_FOLDER_NAME,
      REPORT_TITLE,
      REPORT_TEMPLATE,
      DEPENDENCY_META
    };
  }
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/mustache/mustache.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
    })(exports2, function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
          return entityMap[s];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0)
          return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;
          case 0:
            match = "";
            break;
          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(template, view, partials, config) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#")
            value = this.renderSection(token, context, partials, originalTemplate, config);
          else if (symbol === "^")
            value = this.renderInverted(token, context, partials, originalTemplate, config);
          else if (symbol === ">")
            value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&")
            value = this.unescapedValue(token, context);
          else if (symbol === "name")
            value = this.escapedValue(token, context, config);
          else if (symbol === "text")
            value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value)
          return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
        if (!partials)
          return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config) {
        var escape = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    });
  }
});

// src/util.js
var require_util = __commonJS({
  "src/util.js"(exports2, module2) {
    var { MSGS } = require_constants();
    var { window: window2, workspace, commands } = require("vscode");
    var logMsg = (msg, inModal) => {
      window2.showInformationMessage(msg, { modal: inModal || false });
    };
    var logErrorMsg = (msg) => {
      window2.showErrorMessage(msg);
    };
    var findFile = (fileName) => {
      return new Promise((resolve, reject) => {
        workspace.findFiles(`**/${fileName}`).then(
          async (resp) => {
            if (resp) {
              resp = resp.filter((r) => r.path.indexOf("node_modules") === -1);
              if (resp.length === 1) {
                return resolve(await workspace.openTextDocument(resp[0].path));
              }
              const selectedFile = await window2.showQuickPick(
                resp.map((r) => r.path)
              );
              if (selectedFile) {
                return resolve(await workspace.openTextDocument(selectedFile));
              }
              return reject(MSGS.INVALID_SELECTION);
            }
            resolve(null);
          },
          () => {
            reject("File Not Found");
          }
        );
      });
    };
    var getFileContent = async (file) => {
      if (!file) {
        return "";
      }
      return await file.getText();
    };
    var openFile = async (fileUri) => {
      const doc = await workspace.openTextDocument(fileUri);
      await window2.showTextDocument(doc, { preview: false });
    };
    var registerCommand2 = (command, handlerMethod) => {
      return commands.registerCommand(command, async () => {
        await handlerMethod();
      });
    };
    var isDarkTheme = () => {
      return window2.activeColorTheme.kind === 2;
    };
    var sortByKey = (list, key) => {
      if (!list || !key) {
        return list;
      }
      return list.sort((a, b) => a[key] > b[key] ? 1 : b[key] > a[key] ? -1 : 0);
    };
    var convertObjectToArray = (obj, keyAttribute, valueAttribute) => {
      if (!obj || Object.keys(obj).length === 0) {
        return [];
      }
      return Object.keys(obj).map((key) => {
        return { [keyAttribute]: key, [valueAttribute]: obj[key] };
      });
    };
    module2.exports = {
      logMsg,
      logErrorMsg,
      findFile,
      getFileContent,
      openFile,
      registerCommand: registerCommand2,
      convertObjectToArray,
      sortByKey,
      isDarkTheme
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/third_party/mitt/index.js
var require_mitt = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/third_party/mitt/index.js"(exports2, module2) {
    "use strict";
    function mitt(n) {
      return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
        var i = n.get(t);
        i ? i.push(e) : n.set(t, [e]);
      }, off: function(t, e) {
        var i = n.get(t);
        i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
      }, emit: function(t, e) {
        var i = n.get(t);
        i && i.slice().map(function(n2) {
          n2(e);
        }), (i = n.get("*")) && i.slice().map(function(n2) {
          n2(t, e);
        });
      } };
    }
    module2.exports = mitt;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/EventEmitter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventEmitter = void 0;
    var index_js_1 = __importDefault(require_mitt());
    var EventEmitter = class {
      /**
       * @internal
       */
      constructor() {
        this.eventsMap = /* @__PURE__ */ new Map();
        this.emitter = (0, index_js_1.default)(this.eventsMap);
      }
      /**
       * Bind an event listener to fire when an event occurs.
       * @param event - the event type you'd like to listen to. Can be a string or symbol.
       * @param handler - the function to be called when the event occurs.
       * @returns `this` to enable you to chain method calls.
       */
      on(event, handler) {
        this.emitter.on(event, handler);
        return this;
      }
      /**
       * Remove an event listener from firing.
       * @param event - the event type you'd like to stop listening to.
       * @param handler - the function that should be removed.
       * @returns `this` to enable you to chain method calls.
       */
      off(event, handler) {
        this.emitter.off(event, handler);
        return this;
      }
      /**
       * Remove an event listener.
       * @deprecated please use {@link EventEmitter.off} instead.
       */
      removeListener(event, handler) {
        this.off(event, handler);
        return this;
      }
      /**
       * Add an event listener.
       * @deprecated please use {@link EventEmitter.on} instead.
       */
      addListener(event, handler) {
        this.on(event, handler);
        return this;
      }
      /**
       * Emit an event and call any associated listeners.
       *
       * @param event - the event you'd like to emit
       * @param eventData - any data you'd like to emit with the event
       * @returns `true` if there are any listeners, `false` if there are not.
       */
      emit(event, eventData) {
        this.emitter.emit(event, eventData);
        return this.eventListenersCount(event) > 0;
      }
      /**
       * Like `on` but the listener will only be fired once and then it will be removed.
       * @param event - the event you'd like to listen to
       * @param handler - the handler function to run when the event occurs
       * @returns `this` to enable you to chain method calls.
       */
      once(event, handler) {
        const onceHandler = (eventData) => {
          handler(eventData);
          this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
      }
      /**
       * Gets the number of listeners for a given event.
       *
       * @param event - the event to get the listener count for
       * @returns the number of listeners bound to the given event
       */
      listenerCount(event) {
        return this.eventListenersCount(event);
      }
      /**
       * Removes all listeners. If given an event argument, it will remove only
       * listeners for that event.
       * @param event - the event to remove listeners for.
       * @returns `this` to enable you to chain method calls.
       */
      removeAllListeners(event) {
        if (event) {
          this.eventsMap.delete(event);
        } else {
          this.eventsMap.clear();
        }
        return this;
      }
      eventListenersCount(event) {
        var _a;
        return ((_a = this.eventsMap.get(event)) === null || _a === void 0 ? void 0 : _a.length) || 0;
      }
    };
    exports2.EventEmitter = EventEmitter;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/Browser.js
var require_Browser = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/Browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Browser = exports2.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = void 0;
    var EventEmitter_js_1 = require_EventEmitter();
    exports2.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
      ["geolocation", "geolocation"],
      ["midi", "midi"],
      ["notifications", "notifications"],
      // TODO: push isn't a valid type?
      // ['push', 'push'],
      ["camera", "videoCapture"],
      ["microphone", "audioCapture"],
      ["background-sync", "backgroundSync"],
      ["ambient-light-sensor", "sensors"],
      ["accelerometer", "sensors"],
      ["gyroscope", "sensors"],
      ["magnetometer", "sensors"],
      ["accessibility-events", "accessibilityEvents"],
      ["clipboard-read", "clipboardReadWrite"],
      ["clipboard-write", "clipboardReadWrite"],
      ["payment-handler", "paymentHandler"],
      ["persistent-storage", "durableStorage"],
      ["idle-detection", "idleDetection"],
      // chrome-specific permissions we have.
      ["midi-sysex", "midiSysex"]
    ]);
    var Browser = class extends EventEmitter_js_1.EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      /**
       * @internal
       */
      _attach() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      _detach() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      get _targets() {
        throw new Error("Not implemented");
      }
      /**
       * The spawned browser process. Returns `null` if the browser instance was created with
       * {@link Puppeteer.connect}.
       */
      process() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      _getIsPageTargetCallback() {
        throw new Error("Not implemented");
      }
      createIncognitoBrowserContext() {
        throw new Error("Not implemented");
      }
      /**
       * Returns an array of all open browser contexts. In a newly created browser, this will
       * return a single instance of {@link BrowserContext}.
       */
      browserContexts() {
        throw new Error("Not implemented");
      }
      /**
       * Returns the default browser context. The default browser context cannot be closed.
       */
      defaultBrowserContext() {
        throw new Error("Not implemented");
      }
      _disposeContext() {
        throw new Error("Not implemented");
      }
      /**
       * The browser websocket endpoint which can be used as an argument to
       * {@link Puppeteer.connect}.
       *
       * @returns The Browser websocket url.
       *
       * @remarks
       *
       * The format is `ws://${host}:${port}/devtools/browser/<id>`.
       *
       * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
       * Learn more about the
       * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
       * the {@link
       * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
       * | browser endpoint}.
       */
      wsEndpoint() {
        throw new Error("Not implemented");
      }
      /**
       * Promise which resolves to a new {@link Page} object. The Page is created in
       * a default browser context.
       */
      newPage() {
        throw new Error("Not implemented");
      }
      _createPageInContext() {
        throw new Error("Not implemented");
      }
      /**
       * All active targets inside the Browser. In case of multiple browser contexts, returns
       * an array with all the targets in all browser contexts.
       */
      targets() {
        throw new Error("Not implemented");
      }
      /**
       * The target associated with the browser.
       */
      target() {
        throw new Error("Not implemented");
      }
      waitForTarget() {
        throw new Error("Not implemented");
      }
      /**
       * An array of all open pages inside the Browser.
       *
       * @remarks
       *
       * In case of multiple browser contexts, returns an array with all the pages in all
       * browser contexts. Non-visible pages, such as `"background_page"`, will not be listed
       * here. You can find them using {@link Target.page}.
       */
      pages() {
        throw new Error("Not implemented");
      }
      /**
       * A string representing the browser name and version.
       *
       * @remarks
       *
       * For headless browser, this is similar to `HeadlessChrome/61.0.3153.0`. For
       * non-headless, this is similar to `Chrome/61.0.3153.0`.
       *
       * The format of browser.version() might change with future releases of browsers.
       */
      version() {
        throw new Error("Not implemented");
      }
      /**
       * The browser's original user agent. Pages can override the browser user agent with
       * {@link Page.setUserAgent}.
       */
      userAgent() {
        throw new Error("Not implemented");
      }
      /**
       * Closes the browser and all of its pages (if any were opened). The
       * {@link Browser} object itself is considered to be disposed and cannot be
       * used anymore.
       */
      close() {
        throw new Error("Not implemented");
      }
      /**
       * Disconnects Puppeteer from the browser, but leaves the browser process running.
       * After calling `disconnect`, the {@link Browser} object is considered disposed and
       * cannot be used anymore.
       */
      disconnect() {
        throw new Error("Not implemented");
      }
      /**
       * Indicates that the browser is connected.
       */
      isConnected() {
        throw new Error("Not implemented");
      }
    };
    exports2.Browser = Browser;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/BrowserContext.js
var require_BrowserContext = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/BrowserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserContext = void 0;
    var EventEmitter_js_1 = require_EventEmitter();
    var BrowserContext = class extends EventEmitter_js_1.EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      /**
       * An array of all active targets inside the browser context.
       */
      targets() {
        throw new Error("Not implemented");
      }
      waitForTarget() {
        throw new Error("Not implemented");
      }
      /**
       * An array of all pages inside the browser context.
       *
       * @returns Promise which resolves to an array of all open pages.
       * Non visible pages, such as `"background_page"`, will not be listed here.
       * You can find them using {@link Target.page | the target page}.
       */
      pages() {
        throw new Error("Not implemented");
      }
      /**
       * Returns whether BrowserContext is incognito.
       * The default browser context is the only non-incognito browser context.
       *
       * @remarks
       * The default browser context cannot be closed.
       */
      isIncognito() {
        throw new Error("Not implemented");
      }
      overridePermissions() {
        throw new Error("Not implemented");
      }
      /**
       * Clears all permission overrides for the browser context.
       *
       * @example
       *
       * ```ts
       * const context = browser.defaultBrowserContext();
       * context.overridePermissions('https://example.com', ['clipboard-read']);
       * // do stuff ..
       * context.clearPermissionOverrides();
       * ```
       */
      clearPermissionOverrides() {
        throw new Error("Not implemented");
      }
      /**
       * Creates a new page in the browser context.
       */
      newPage() {
        throw new Error("Not implemented");
      }
      /**
       * The browser this browser context belongs to.
       */
      browser() {
        throw new Error("Not implemented");
      }
      /**
       * Closes the browser context. All the targets that belong to the browser context
       * will be closed.
       *
       * @remarks
       * Only incognito browser contexts can be closed.
       */
      close() {
        throw new Error("Not implemented");
      }
      get id() {
        return void 0;
      }
    };
    exports2.BrowserContext = BrowserContext;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PDFOptions.js
var require_PDFOptions = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/PDFOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.paperFormats = void 0;
    exports2.paperFormats = {
      letter: { width: 8.5, height: 11 },
      legal: { width: 8.5, height: 14 },
      tabloid: { width: 11, height: 17 },
      ledger: { width: 17, height: 11 },
      a0: { width: 33.1, height: 46.8 },
      a1: { width: 23.4, height: 33.1 },
      a2: { width: 16.54, height: 23.4 },
      a3: { width: 11.7, height: 16.54 },
      a4: { width: 8.27, height: 11.7 },
      a5: { width: 5.83, height: 8.27 },
      a6: { width: 4.13, height: 5.83 }
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/environment.js
var require_environment = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFERRED_PROMISE_DEBUG_TIMEOUT = exports2.isNode = void 0;
    exports2.isNode = !!(typeof process !== "undefined" && process.version);
    exports2.DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process !== "undefined" && typeof process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"] !== "undefined" ? Number(process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"]) : -1;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/assert.js
var require_assert = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assert = void 0;
    var assert = (value, message) => {
      if (!value) {
        throw new Error(message);
      }
    };
    exports2.assert = assert;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/ErrorLike.js
var require_ErrorLike = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/ErrorLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isErrnoException = exports2.isErrorLike = void 0;
    function isErrorLike(obj) {
      return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
    }
    exports2.isErrorLike = isErrorLike;
    function isErrnoException(obj) {
      return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
    }
    exports2.isErrnoException = isErrnoException;
  }
});

// node_modules/puppeteer-core/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/puppeteer-core/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/puppeteer-core/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/puppeteer-core/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/puppeteer-core/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/puppeteer-core/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/puppeteer-core/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/puppeteer-core/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/puppeteer-core/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/puppeteer-core/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Debug.js
var require_Debug = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Debug.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCapturedLogs = exports2.setLogCapture = exports2.debug = exports2.importDebug = void 0;
    var environment_js_1 = require_environment();
    var debugModule = null;
    async function importDebug() {
      if (!debugModule) {
        debugModule = (await Promise.resolve().then(() => __importStar(require_src()))).default;
      }
      return debugModule;
    }
    exports2.importDebug = importDebug;
    var debug = (prefix) => {
      if (environment_js_1.isNode) {
        return async (...logArgs) => {
          if (captureLogs) {
            capturedLogs.push(prefix + logArgs);
          }
          (await importDebug())(prefix)(logArgs);
        };
      }
      return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel) {
          return;
        }
        const everythingShouldBeLogged = debugLevel === "*";
        const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
         * If the debug level is `foo*`, that means we match any prefix that
         * starts with `foo`. If the level is `foo`, we match only the prefix
         * `foo`.
         */
        (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
        if (!prefixMatchesDebugLevel) {
          return;
        }
        console.log(`${prefix}:`, ...logArgs);
      };
    };
    exports2.debug = debug;
    var capturedLogs = [];
    var captureLogs = false;
    function setLogCapture(value) {
      capturedLogs = [];
      captureLogs = value;
    }
    exports2.setLogCapture = setLogCapture;
    function getCapturedLogs() {
      return capturedLogs;
    }
    exports2.getCapturedLogs = getCapturedLogs;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/JSHandle.js
var require_JSHandle = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/JSHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSHandle = void 0;
    var JSHandle = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * @internal
       */
      get disposed() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      executionContext() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      get client() {
        throw new Error("Not implemented");
      }
      async evaluate() {
        throw new Error("Not implemented");
      }
      async evaluateHandle() {
        throw new Error("Not implemented");
      }
      async getProperty() {
        throw new Error("Not implemented");
      }
      /**
       * Gets a map of handles representing the properties of the current handle.
       *
       * @example
       *
       * ```ts
       * const listHandle = await page.evaluateHandle(() => document.body.children);
       * const properties = await listHandle.getProperties();
       * const children = [];
       * for (const property of properties.values()) {
       *   const element = property.asElement();
       *   if (element) {
       *     children.push(element);
       *   }
       * }
       * children; // holds elementHandles to all children of document.body
       * ```
       */
      async getProperties() {
        throw new Error("Not implemented");
      }
      /**
       * A vanilla object representing the serializable portions of the
       * referenced object.
       * @throws Throws if the object cannot be serialized due to circularity.
       *
       * @remarks
       * If the object has a `toJSON` function, it **will not** be called.
       */
      async jsonValue() {
        throw new Error("Not implemented");
      }
      /**
       * Either `null` or the handle itself if the handle is an
       * instance of {@link ElementHandle}.
       */
      asElement() {
        throw new Error("Not implemented");
      }
      /**
       * Releases the object referenced by the handle for garbage collection.
       */
      async dispose() {
        throw new Error("Not implemented");
      }
      /**
       * Returns a string representation of the JSHandle.
       *
       * @remarks
       * Useful during debugging.
       */
      toString() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      get id() {
        throw new Error("Not implemented");
      }
      /**
       * Provides access to the
       * {@link https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObject | Protocol.Runtime.RemoteObject}
       * backing this handle.
       */
      remoteObject() {
        throw new Error("Not implemented");
      }
    };
    exports2.JSHandle = JSHandle;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/ElementHandle.js
var require_ElementHandle = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/ElementHandle.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ElementHandle_instances;
    var _ElementHandle_asSVGElementHandle;
    var _ElementHandle_getOwnerSVGElement;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementHandle = void 0;
    var JSHandle_js_1 = require_JSHandle();
    var ElementHandle = class extends JSHandle_js_1.JSHandle {
      /**
       * @internal
       */
      constructor(handle) {
        super();
        _ElementHandle_instances.add(this);
        this.handle = handle;
      }
      /**
       * @internal
       */
      get id() {
        return this.handle.id;
      }
      /**
       * @internal
       */
      get disposed() {
        return this.handle.disposed;
      }
      async getProperty(propertyName) {
        return this.handle.getProperty(propertyName);
      }
      /**
       * @internal
       */
      async getProperties() {
        return this.handle.getProperties();
      }
      /**
       * @internal
       */
      async evaluate(pageFunction, ...args) {
        return this.handle.evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      evaluateHandle(pageFunction, ...args) {
        return this.handle.evaluateHandle(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async jsonValue() {
        return this.handle.jsonValue();
      }
      /**
       * @internal
       */
      toString() {
        return this.handle.toString();
      }
      /**
       * @internal
       */
      async dispose() {
        return await this.handle.dispose();
      }
      asElement() {
        return this;
      }
      /**
       * @internal
       */
      executionContext() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      get client() {
        throw new Error("Not implemented");
      }
      get frame() {
        throw new Error("Not implemented");
      }
      async $() {
        throw new Error("Not implemented");
      }
      async $$() {
        throw new Error("Not implemented");
      }
      async $eval() {
        throw new Error("Not implemented");
      }
      async $$eval() {
        throw new Error("Not implemented");
      }
      async $x() {
        throw new Error("Not implemented");
      }
      async waitForSelector() {
        throw new Error("Not implemented");
      }
      /**
       * Checks if an element is visible using the same mechanism as
       * {@link ElementHandle.waitForSelector}.
       */
      async isVisible() {
        throw new Error("Not implemented.");
      }
      /**
       * Checks if an element is hidden using the same mechanism as
       * {@link ElementHandle.waitForSelector}.
       */
      async isHidden() {
        throw new Error("Not implemented.");
      }
      async waitForXPath() {
        throw new Error("Not implemented");
      }
      async toElement() {
        throw new Error("Not implemented");
      }
      /**
       * Resolves to the content frame for element handles referencing
       * iframe nodes, or null otherwise
       */
      async contentFrame() {
        throw new Error("Not implemented");
      }
      async clickablePoint() {
        throw new Error("Not implemented");
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page} to hover over the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async hover() {
        throw new Error("Not implemented");
      }
      async click() {
        throw new Error("Not implemented");
      }
      async drag() {
        throw new Error("Not implemented");
      }
      async dragEnter() {
        throw new Error("Not implemented");
      }
      async dragOver() {
        throw new Error("Not implemented");
      }
      async drop() {
        throw new Error("Not implemented");
      }
      async dragAndDrop() {
        throw new Error("Not implemented");
      }
      async select() {
        throw new Error("Not implemented");
      }
      async uploadFile() {
        throw new Error("Not implemented");
      }
      /**
       * This method scrolls element into view if needed, and then uses
       * {@link Touchscreen.tap} to tap in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async tap() {
        throw new Error("Not implemented");
      }
      async touchStart() {
        throw new Error("Not implemented");
      }
      async touchMove() {
        throw new Error("Not implemented");
      }
      async touchEnd() {
        throw new Error("Not implemented");
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
       */
      async focus() {
        throw new Error("Not implemented");
      }
      async type() {
        throw new Error("Not implemented");
      }
      async press() {
        throw new Error("Not implemented");
      }
      /**
       * This method returns the bounding box of the element (relative to the main frame),
       * or `null` if the element is not visible.
       */
      async boundingBox() {
        throw new Error("Not implemented");
      }
      /**
       * This method returns boxes of the element, or `null` if the element is not visible.
       *
       * @remarks
       *
       * Boxes are represented as an array of points;
       * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
       */
      async boxModel() {
        throw new Error("Not implemented");
      }
      async screenshot() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      async assertConnectedElement() {
        const error = await this.evaluate(async (element) => {
          if (!element.isConnected) {
            return "Node is detached from document";
          }
          if (element.nodeType !== Node.ELEMENT_NODE) {
            return "Node is not of type HTMLElement";
          }
          return;
        });
        if (error) {
          throw new Error(error);
        }
      }
      /**
       * Resolves to true if the element is visible in the current viewport. If an
       * element is an SVG, we check if the svg owner element is in the viewport
       * instead. See https://crbug.com/963246.
       *
       * @param options - Threshold for the intersection between 0 (no intersection) and 1
       * (full intersection). Defaults to 1.
       */
      async isIntersectingViewport(options) {
        await this.assertConnectedElement();
        const { threshold = 0 } = options !== null && options !== void 0 ? options : {};
        const svgHandle = await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_asSVGElementHandle).call(this, this);
        const intersectionTarget = svgHandle ? await __classPrivateFieldGet(this, _ElementHandle_instances, "m", _ElementHandle_getOwnerSVGElement).call(this, svgHandle) : this;
        try {
          return await intersectionTarget.evaluate(async (element, threshold2) => {
            const visibleRatio = await new Promise((resolve) => {
              const observer = new IntersectionObserver((entries) => {
                resolve(entries[0].intersectionRatio);
                observer.disconnect();
              });
              observer.observe(element);
            });
            return threshold2 === 1 ? visibleRatio === 1 : visibleRatio > threshold2;
          }, threshold);
        } finally {
          if (intersectionTarget !== this) {
            await intersectionTarget.dispose();
          }
        }
      }
      /**
       * Scrolls the element into view using either the automation protocol client
       * or by calling element.scrollIntoView.
       */
      async scrollIntoView() {
        throw new Error("Not implemented");
      }
    };
    exports2.ElementHandle = ElementHandle;
    _ElementHandle_instances = /* @__PURE__ */ new WeakSet(), _ElementHandle_asSVGElementHandle = /**
     * Returns true if an element is an SVGElement (included svg, path, rect
     * etc.).
     */
    async function _ElementHandle_asSVGElementHandle2(handle) {
      if (await handle.evaluate((element) => {
        return element instanceof SVGElement;
      })) {
        return handle;
      } else {
        return null;
      }
    }, _ElementHandle_getOwnerSVGElement = async function _ElementHandle_getOwnerSVGElement2(handle) {
      return await handle.evaluateHandle((element) => {
        if (element instanceof SVGSVGElement) {
          return element;
        }
        return element.ownerSVGElement;
      });
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/AsyncIterableUtil.js
var require_AsyncIterableUtil = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/AsyncIterableUtil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncIterableUtil = void 0;
    var AsyncIterableUtil = class {
      static async *map(iterable, map) {
        for await (const value of iterable) {
          yield await map(value);
        }
      }
      static async *flatMap(iterable, map) {
        for await (const value of iterable) {
          yield* map(value);
        }
      }
      static async collect(iterable) {
        const result = [];
        for await (const value of iterable) {
          result.push(value);
        }
        return result;
      }
      static async first(iterable) {
        for await (const value of iterable) {
          return value;
        }
        return;
      }
    };
    exports2.AsyncIterableUtil = AsyncIterableUtil;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/Function.js
var require_Function = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/Function.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interpolateFunction = exports2.stringifyFunction = exports2.createFunction = void 0;
    var createdFunctions = /* @__PURE__ */ new Map();
    var createFunction = (functionValue) => {
      let fn = createdFunctions.get(functionValue);
      if (fn) {
        return fn;
      }
      fn = new Function(`return ${functionValue}`)();
      createdFunctions.set(functionValue, fn);
      return fn;
    };
    exports2.createFunction = createFunction;
    function stringifyFunction(fn) {
      let value = fn.toString();
      try {
        new Function(`(${value})`);
      } catch {
        let prefix = "function ";
        if (value.startsWith("async ")) {
          prefix = `async ${prefix}`;
          value = value.substring("async ".length);
        }
        value = `${prefix}${value}`;
        try {
          new Function(`(${value})`);
        } catch {
          throw new Error("Passed function cannot be serialized!");
        }
      }
      return value;
    }
    exports2.stringifyFunction = stringifyFunction;
    var interpolateFunction = (fn, replacements) => {
      let value = stringifyFunction(fn);
      for (const [name, jsValue] of Object.entries(replacements)) {
        value = value.replace(new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"), jsValue);
      }
      return (0, exports2.createFunction)(value);
    };
    exports2.interpolateFunction = interpolateFunction;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/HandleIterator.js
var require_HandleIterator = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/HandleIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transposeIterableHandle = void 0;
    var DEFAULT_BATCH_SIZE = 20;
    async function* fastTransposeIteratorHandle(iterator, size) {
      const array = await iterator.evaluateHandle(async (iterator2, size2) => {
        const results = [];
        while (results.length < size2) {
          const result = await iterator2.next();
          if (result.done) {
            break;
          }
          results.push(result.value);
        }
        return results;
      }, size);
      const properties = await array.getProperties();
      await array.dispose();
      yield* properties.values();
      return properties.size === 0;
    }
    async function* transposeIteratorHandle(iterator) {
      let size = DEFAULT_BATCH_SIZE;
      try {
        while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
          size <<= 1;
        }
      } finally {
        await iterator.dispose();
      }
    }
    async function* transposeIterableHandle(handle) {
      yield* transposeIteratorHandle(await handle.evaluateHandle((iterable) => {
        return async function* () {
          yield* iterable;
        }();
      }));
    }
    exports2.transposeIterableHandle = transposeIterableHandle;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/IsolatedWorlds.js
var require_IsolatedWorlds = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/IsolatedWorlds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PUPPETEER_WORLD = exports2.MAIN_WORLD = void 0;
    exports2.MAIN_WORLD = Symbol("mainWorld");
    exports2.PUPPETEER_WORLD = Symbol("puppeteerWorld");
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/LazyArg.js
var require_LazyArg = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/LazyArg.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _LazyArg_get;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LazyArg = void 0;
    var LazyArg = class {
      constructor(get) {
        _LazyArg_get.set(this, void 0);
        __classPrivateFieldSet(this, _LazyArg_get, get, "f");
      }
      async get(context) {
        return __classPrivateFieldGet(this, _LazyArg_get, "f").call(this, context);
      }
    };
    exports2.LazyArg = LazyArg;
    _LazyArg_get = /* @__PURE__ */ new WeakMap();
    LazyArg.create = (get) => {
      return new LazyArg(get);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/QueryHandler.js
var require_QueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/QueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueryHandler = void 0;
    var ElementHandle_js_1 = require_ElementHandle();
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var Function_js_1 = require_Function();
    var HandleIterator_js_1 = require_HandleIterator();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var LazyArg_js_1 = require_LazyArg();
    var QueryHandler = class {
      static get _querySelector() {
        if (this.querySelector) {
          return this.querySelector;
        }
        if (!this.querySelectorAll) {
          throw new Error("Cannot create default `querySelector`.");
        }
        return this.querySelector = (0, Function_js_1.interpolateFunction)(async (node, selector, PuppeteerUtil) => {
          const querySelectorAll = PLACEHOLDER("querySelectorAll");
          const results = querySelectorAll(node, selector, PuppeteerUtil);
          for await (const result of results) {
            return result;
          }
          return null;
        }, {
          querySelectorAll: (0, Function_js_1.stringifyFunction)(this.querySelectorAll)
        });
      }
      static get _querySelectorAll() {
        if (this.querySelectorAll) {
          return this.querySelectorAll;
        }
        if (!this.querySelector) {
          throw new Error("Cannot create default `querySelectorAll`.");
        }
        return this.querySelectorAll = (0, Function_js_1.interpolateFunction)(async function* (node, selector, PuppeteerUtil) {
          const querySelector = PLACEHOLDER("querySelector");
          const result = await querySelector(node, selector, PuppeteerUtil);
          if (result) {
            yield result;
          }
        }, {
          querySelector: (0, Function_js_1.stringifyFunction)(this.querySelector)
        });
      }
      /**
       * Queries for multiple nodes given a selector and {@link ElementHandle}.
       *
       * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
       */
      static async *queryAll(element, selector) {
        const world = element.executionContext()._world;
        (0, assert_js_1.assert)(world);
        const handle = await element.evaluateHandle(this._querySelectorAll, selector, LazyArg_js_1.LazyArg.create((context) => {
          return context.puppeteerUtil;
        }));
        yield* (0, HandleIterator_js_1.transposeIterableHandle)(handle);
      }
      /**
       * Queries for a single node given a selector and {@link ElementHandle}.
       *
       * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
       */
      static async queryOne(element, selector) {
        const world = element.executionContext()._world;
        (0, assert_js_1.assert)(world);
        const result = await element.evaluateHandle(this._querySelector, selector, LazyArg_js_1.LazyArg.create((context) => {
          return context.puppeteerUtil;
        }));
        if (!(result instanceof ElementHandle_js_1.ElementHandle)) {
          await result.dispose();
          return null;
        }
        return result;
      }
      /**
       * Waits until a single node appears for a given selector and
       * {@link ElementHandle}.
       *
       * This will always query the handle in the Puppeteer world and migrate the
       * result to the main world.
       */
      static async waitFor(elementOrFrame, selector, options) {
        let frame;
        let element;
        if (!(elementOrFrame instanceof ElementHandle_js_1.ElementHandle)) {
          frame = elementOrFrame;
        } else {
          frame = elementOrFrame.frame;
          element = await frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].adoptHandle(elementOrFrame);
        }
        const { visible = false, hidden = false, timeout, signal } = options;
        try {
          signal === null || signal === void 0 ? void 0 : signal.throwIfAborted();
          const handle = await frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
            const querySelector = PuppeteerUtil.createFunction(query);
            const node = await querySelector(root !== null && root !== void 0 ? root : document, selector2, PuppeteerUtil);
            return PuppeteerUtil.checkVisibility(node, visible2);
          }, {
            polling: visible || hidden ? "raf" : "mutation",
            root: element,
            timeout,
            signal
          }, LazyArg_js_1.LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), (0, Function_js_1.stringifyFunction)(this._querySelector), selector, element, visible ? true : hidden ? false : void 0);
          if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            await handle.dispose();
            throw signal.reason;
          }
          if (!(handle instanceof ElementHandle_js_1.ElementHandle)) {
            await handle.dispose();
            return null;
          }
          return frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD].transferHandle(handle);
        } catch (error) {
          if (!(0, ErrorLike_js_1.isErrorLike)(error)) {
            throw error;
          }
          if (error.name === "AbortError") {
            throw error;
          }
          error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
          throw error;
        } finally {
          if (element) {
            await element.dispose();
          }
        }
      }
    };
    exports2.QueryHandler = QueryHandler;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/AriaQueryHandler.js
var require_AriaQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/AriaQueryHandler.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ARIAQueryHandler = void 0;
    var assert_js_1 = require_assert();
    var AsyncIterableUtil_js_1 = require_AsyncIterableUtil();
    var QueryHandler_js_1 = require_QueryHandler();
    var queryAXTree = async (client, element, accessibleName, role) => {
      const { nodes } = await client.send("Accessibility.queryAXTree", {
        objectId: element.id,
        accessibleName,
        role
      });
      return nodes.filter((node) => {
        return !node.role || node.role.value !== "StaticText";
      });
    };
    var KNOWN_ATTRIBUTES = Object.freeze(["name", "role"]);
    var isKnownAttribute = (attribute) => {
      return KNOWN_ATTRIBUTES.includes(attribute);
    };
    var normalizeValue = (value) => {
      return value.replace(/ +/g, " ").trim();
    };
    var ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
    var parseARIASelector = (selector) => {
      const queryOptions = {};
      const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
        attribute = attribute.trim();
        (0, assert_js_1.assert)(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
        queryOptions[attribute] = normalizeValue(value);
        return "";
      });
      if (defaultName && !queryOptions.name) {
        queryOptions.name = normalizeValue(defaultName);
      }
      return queryOptions;
    };
    var ARIAQueryHandler = class extends QueryHandler_js_1.QueryHandler {
      static async *queryAll(element, selector) {
        const context = element.executionContext();
        const { name, role } = parseARIASelector(selector);
        const results = await queryAXTree(context._client, element, name, role);
        const world = context._world;
        yield* AsyncIterableUtil_js_1.AsyncIterableUtil.map(results, (node) => {
          return world.adoptBackendNode(node.backendDOMNodeId);
        });
      }
    };
    exports2.ARIAQueryHandler = ARIAQueryHandler;
    _a = ARIAQueryHandler;
    ARIAQueryHandler.querySelector = async (node, selector, { ariaQuerySelector }) => {
      return ariaQuerySelector(node, selector);
    };
    ARIAQueryHandler.queryOne = async (element, selector) => {
      var _b;
      return (_b = await AsyncIterableUtil_js_1.AsyncIterableUtil.first(_a.queryAll(element, selector))) !== null && _b !== void 0 ? _b : null;
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/generated/injected.js
var require_injected = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/generated/injected.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.source = void 0;
    exports2.source = '"use strict";var C=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var se=Object.prototype.hasOwnProperty;var u=(e,t)=>{for(var n in t)C(e,n,{get:t[n],enumerable:!0})},ie=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of oe(t))!se.call(e,o)&&o!==n&&C(e,o,{get:()=>t[o],enumerable:!(r=ne(t,o))||r.enumerable});return e};var le=e=>ie(C({},"__esModule",{value:!0}),e);var Oe={};u(Oe,{default:()=>Re});module.exports=le(Oe);var P=class extends Error{constructor(t){super(t),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}},S=class extends P{},I=class extends P{#e;#r="";set code(t){this.#e=t}get code(){return this.#e}set originalMessage(t){this.#r=t}get originalMessage(){return this.#r}},De=Object.freeze({TimeoutError:S,ProtocolError:I});function p(e){let t=!1,n=!1,r,o,i=new Promise((l,a)=>{r=l,o=a}),s=e&&e.timeout>0?setTimeout(()=>{n=!0,o(new S(e.message))},e.timeout):void 0;return Object.assign(i,{resolved:()=>t,finished:()=>t||n,resolve:l=>{s&&clearTimeout(s),t=!0,r(l)},reject:l=>{clearTimeout(s),n=!0,o(l)}})}var G=new Map,X=e=>{let t=G.get(e);return t||(t=new Function(`return ${e}`)(),G.set(e,t),t)};var R={};u(R,{ariaQuerySelector:()=>ae,ariaQuerySelectorAll:()=>k});var ae=(e,t)=>window.__ariaQuerySelector(e,t),k=async function*(e,t){yield*await window.__ariaQuerySelectorAll(e,t)};var D={};u(D,{customQuerySelectors:()=>_});var O=class{#e=new Map;register(t,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(t,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(t){this.#e.delete(t)}get(t){return this.#e.get(t)}clear(){this.#e.clear()}},_=new O;var M={};u(M,{pierceQuerySelector:()=>ce,pierceQuerySelectorAll:()=>ue});var ce=(e,t)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(t)&&(n=s)}while(!n&&i.nextNode())};return e instanceof Document&&(e=e.documentElement),r(e),n},ue=(e,t)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(t)&&n.push(s)}while(i.nextNode())};return e instanceof Document&&(e=e.documentElement),r(e),n};var m=(e,t)=>{if(!e)throw new Error(t)};var T=class{#e;#r;#n;#t;constructor(t,n){this.#e=t,this.#r=n}async start(){let t=this.#t=p(),n=await this.#e();if(n){t.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(t.resolve(r),await this.stop())}),this.#n.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t}},x=class{#e;#r;constructor(t){this.#e=t}async start(){let t=this.#r=p(),n=await this.#e();if(n){t.resolve(n);return}let r=async()=>{if(t.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}t.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return m(this.#r,"Polling never started."),this.#r}},E=class{#e;#r;#n;#t;constructor(t,n){this.#e=t,this.#r=n}async start(){let t=this.#t=p(),n=await this.#e();if(n){t.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(t.resolve(r),await this.stop())},this.#r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t}};var H={};u(H,{pQuerySelector:()=>Ie,pQuerySelectorAll:()=>re});var c=class{static async*map(t,n){for await(let r of t)yield await n(r)}static async*flatMap(t,n){for await(let r of t)yield*n(r)}static async collect(t){let n=[];for await(let r of t)n.push(r);return n}static async first(t){for await(let n of t)return n}};var h={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6+)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6+)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},fe=new Set(["combinator","comma"]);var me=e=>{switch(e){case"pseudo-element":case"pseudo-class":return new RegExp(h[e].source.replace("(?<argument>\\xB6+)","(?<argument>.+)"),"gu");default:return h[e]}};function de(e,t){let n=0,r="";for(;t<e.length;t++){let o=e[t];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function pe(e,t=h){if(!e)return[];let n=[e];for(let[o,i]of Object.entries(t))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let d=a.index-1,f=[],V=a[0],B=l.slice(0,d+1);B&&f.push(B),f.push({...a.groups,type:o,content:V});let z=l.slice(d+V.length+1);z&&f.push(z),n.splice(s,1,...f)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],fe.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var he=/([\'"])([^\\\\\\n]+?)\\1/g,ge=/\\\\./g;function K(e,t=h){if(e=e.trim(),e==="")return[];let n=[];e=e.replace(ge,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),e=e.replace(he,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=e.indexOf("(",i))>-1;){let l=de(e,s);n.push({value:l,offset:s}),e=`${e.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${e.substring(s+l.length)}`,i=s+l.length}}let r=pe(e,t),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:d}=s,f=l-s.pos[0];s.content=d.slice(0,f)+a+d.slice(f+a.length),s.content!==d&&o.add(s)}for(let i of o){let s=me(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*N(e,t){switch(e.type){case"list":for(let n of e.list)yield*N(n,e);break;case"complex":yield*N(e.left,e),yield*N(e.right,e);break;case"compound":yield*e.list.map(n=>[n,e]);break;default:yield[e,t]}}function g(e){let t;return Array.isArray(e)?t=e:t=[...N(e)].map(([n])=>n),t.map(n=>n.content).join("")}h.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ye=/\\\\[\\s\\S]/g,we=e=>{if(e.length>1){for(let t of[\'"\',"\'"])if(!(!e.startsWith(t)||!e.endsWith(t)))return e.slice(t.length,-t.length).replace(ye,n=>n.slice(1))}return e};function Y(e){let t=!0,n=K(e);if(n.length===0)return[[],t];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":t=!1,s.length&&(r.push(g(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":t=!1,s.length&&(r.push(g(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;t=!1,s.length&&(r.push(g(s)),s.splice(0)),r.push({name:l.name.slice(3),value:we(l.argument??"")});continue;case"comma":s.length&&(r.push(g(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(g(s)),[i,t]}var Q={};u(Q,{textQuerySelectorAll:()=>b});var Se=new Set(["checkbox","image","radio"]),be=e=>e instanceof HTMLSelectElement||e instanceof HTMLTextAreaElement||e instanceof HTMLInputElement&&!Se.has(e.type),Pe=new Set(["SCRIPT","STYLE"]),w=e=>!Pe.has(e.nodeName)&&!document.head?.contains(e),q=new WeakMap,Z=e=>{for(;e;)q.delete(e),e instanceof ShadowRoot?e=e.host:e=e.parentNode},J=new WeakSet,Te=new MutationObserver(e=>{for(let t of e)Z(t.target)}),y=e=>{let t=q.get(e);if(t||(t={full:"",immediate:[]},!w(e)))return t;let n="";if(be(e))t.full=e.value,t.immediate.push(e.value),e.addEventListener("input",r=>{Z(r.target)},{once:!0,capture:!0});else{for(let r=e.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){t.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&t.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(t.full+=y(r).full)}n&&t.immediate.push(n),e instanceof Element&&e.shadowRoot&&(t.full+=y(e.shadowRoot).full),J.has(e)||(Te.observe(e,{childList:!0,characterData:!0}),J.add(e))}return q.set(e,t),t};var b=function*(e,t){let n=!1;for(let r of e.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=b(r.shadowRoot,t):o=b(r,t);for(let i of o)yield i,n=!0}n||e instanceof Element&&w(e)&&y(e).full.includes(t)&&(yield e)};var $={};u($,{checkVisibility:()=>Ee,pierce:()=>A,pierceAll:()=>L});var xe=["hidden","collapse"],Ee=(e,t)=>{if(!e)return t===!1;if(t===void 0)return e;let n=e.nodeType===Node.TEXT_NODE?e.parentElement:e,r=window.getComputedStyle(n),o=r&&!xe.includes(r.visibility)&&!Ne(n);return t===o?e:!1};function Ne(e){let t=e.getBoundingClientRect();return t.width===0||t.height===0}var Ae=e=>"shadowRoot"in e&&e.shadowRoot instanceof ShadowRoot;function*A(e){Ae(e)?yield e.shadowRoot:yield e}function*L(e){e=A(e).next().value,yield e;let t=[document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT)];for(let n of t){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,t.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var U={};u(U,{xpathQuerySelectorAll:()=>j});var j=function*(e,t){let r=(e.ownerDocument||document).evaluate(t,e,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),o;for(;o=r.iterateNext();)yield o};var ve=/[-\\w\\P{ASCII}*]/,ee=e=>"querySelectorAll"in e,v=class extends Error{constructor(t,n){super(`${t} is not a valid selector: ${n}`)}},F=class{#e;#r;#n=[];#t=void 0;elements;constructor(t,n,r){this.elements=[t],this.#e=n,this.#r=r,this.#o()}async run(){if(typeof this.#t=="string")switch(this.#t.trimStart()){case":scope":this.#o();break}for(;this.#t!==void 0;this.#o()){let t=this.#t,n=this.#e;typeof t=="string"?t[0]&&ve.test(t[0])?this.elements=c.flatMap(this.elements,async function*(r){ee(r)&&(yield*r.querySelectorAll(t))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!ee(r))return;yield*r.querySelectorAll(t);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${t}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(t.name){case"text":yield*b(r,t.value);break;case"xpath":yield*j(r,t.value);break;case"aria":yield*k(r,t.value);break;default:let o=_.get(t.name);if(!o)throw new v(n,`Unknown selector type: ${t.name}`);yield*o.querySelectorAll(r,t.value)}})}}#o(){if(this.#n.length!==0){this.#t=this.#n.shift();return}if(this.#r.length===0){this.#t=void 0;return}let t=this.#r.shift();switch(t){case">>>>":{this.elements=c.flatMap(this.elements,A),this.#o();break}case">>>":{this.elements=c.flatMap(this.elements,L),this.#o();break}default:this.#n=t,this.#o();break}}},W=class{#e=new WeakMap;calculate(t,n=[]){if(t===null)return n;t instanceof ShadowRoot&&(t=t.host);let r=this.#e.get(t);if(r)return[...r,...n];let o=0;for(let s=t.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(t.parentNode,[o]);return this.#e.set(t,i),[...i,...n]}},te=(e,t)=>{if(e.length+t.length===0)return 0;let[n=-1,...r]=e,[o=-1,...i]=t;return n===o?te(r,i):n<o?-1:1},Ce=async function*(e){let t=new Set;for await(let r of e)t.add(r);let n=new W;yield*[...t.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>te(r,o)).map(([r])=>r)},re=function(e,t){let n,r;try{[n,r]=Y(t)}catch{return e.querySelectorAll(t)}if(r)return e.querySelectorAll(t);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new v(t,"Multiple deep combinators found in sequence.");return Ce(c.flatMap(n,o=>{let i=new F(e,t,o);return i.run(),i.elements}))},Ie=async function(e,t){for await(let n of re(e,t))return n;return null};var ke=Object.freeze({...R,...D,...M,...H,...Q,...$,...U,createDeferredPromise:p,createFunction:X,createTextContent:y,IntervalPoller:E,isSuitableNodeForTextMatching:w,MutationPoller:T,RAFPoller:x}),Re=ke;\n';
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ScriptInjector.js
var require_ScriptInjector = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ScriptInjector.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _ScriptInjector_instances;
    var _ScriptInjector_updated;
    var _ScriptInjector_amendments;
    var _ScriptInjector_update;
    var _ScriptInjector_get;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scriptInjector = void 0;
    var injected_js_1 = require_injected();
    var ScriptInjector = class {
      constructor() {
        _ScriptInjector_instances.add(this);
        _ScriptInjector_updated.set(this, false);
        _ScriptInjector_amendments.set(this, /* @__PURE__ */ new Set());
      }
      // Appends a statement of the form `(PuppeteerUtil) => {...}`.
      append(statement) {
        __classPrivateFieldGet(this, _ScriptInjector_instances, "m", _ScriptInjector_update).call(this, () => {
          __classPrivateFieldGet(this, _ScriptInjector_amendments, "f").add(statement);
        });
      }
      pop(statement) {
        __classPrivateFieldGet(this, _ScriptInjector_instances, "m", _ScriptInjector_update).call(this, () => {
          __classPrivateFieldGet(this, _ScriptInjector_amendments, "f").delete(statement);
        });
      }
      inject(inject, force = false) {
        if (__classPrivateFieldGet(this, _ScriptInjector_updated, "f") || force) {
          inject(__classPrivateFieldGet(this, _ScriptInjector_instances, "m", _ScriptInjector_get).call(this));
        }
        __classPrivateFieldSet(this, _ScriptInjector_updated, false, "f");
      }
    };
    _ScriptInjector_updated = /* @__PURE__ */ new WeakMap(), _ScriptInjector_amendments = /* @__PURE__ */ new WeakMap(), _ScriptInjector_instances = /* @__PURE__ */ new WeakSet(), _ScriptInjector_update = function _ScriptInjector_update2(callback) {
      callback();
      __classPrivateFieldSet(this, _ScriptInjector_updated, true, "f");
    }, _ScriptInjector_get = function _ScriptInjector_get2() {
      return `(() => {
      const module = {};
      ${injected_js_1.source}
      ${[...__classPrivateFieldGet(this, _ScriptInjector_amendments, "f")].map((statement) => {
        return `(${statement})(module.exports.default);`;
      }).join("")}
      return module.exports.default;
    })()`;
    };
    exports2.scriptInjector = new ScriptInjector();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/CustomQueryHandler.js
var require_CustomQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/CustomQueryHandler.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _CustomQueryHandlerRegistry_handlers;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearCustomQueryHandlers = exports2.customQueryHandlerNames = exports2.unregisterCustomQueryHandler = exports2.registerCustomQueryHandler = exports2.customQueryHandlers = exports2.CustomQueryHandlerRegistry = void 0;
    var assert_js_1 = require_assert();
    var Function_js_1 = require_Function();
    var QueryHandler_js_1 = require_QueryHandler();
    var ScriptInjector_js_1 = require_ScriptInjector();
    var CustomQueryHandlerRegistry = class {
      constructor() {
        _CustomQueryHandlerRegistry_handlers.set(this, /* @__PURE__ */ new Map());
      }
      /**
       * @internal
       */
      get(name) {
        const handler = __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").get(name);
        return handler ? handler[1] : void 0;
      }
      /**
       * Registers a {@link CustomQueryHandler | custom query handler}.
       *
       * @remarks
       * After registration, the handler can be used everywhere where a selector is
       * expected by prepending the selection string with `<name>/`. The name is
       * only allowed to consist of lower- and upper case latin letters.
       *
       * @example
       *
       * ```ts
       * Puppeteer.customQueryHandlers.register('lit', {  });
       * const aHandle = await page.$('lit/');
       * ```
       *
       * @param name - Name to register under.
       * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
       * register.
       *
       * @internal
       */
      register(name, handler) {
        var _a;
        if (__classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").has(name)) {
          throw new Error(`Cannot register over existing handler: ${name}`);
        }
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").has(name), `Cannot register over existing handler: ${name}`);
        (0, assert_js_1.assert)(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
        (0, assert_js_1.assert)(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
        const Handler = (_a = class extends QueryHandler_js_1.QueryHandler {
        }, _a.querySelectorAll = (0, Function_js_1.interpolateFunction)((node, selector, PuppeteerUtil) => {
          return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
        }, { name: JSON.stringify(name) }), _a.querySelector = (0, Function_js_1.interpolateFunction)((node, selector, PuppeteerUtil) => {
          return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
        }, { name: JSON.stringify(name) }), _a);
        const registerScript = (0, Function_js_1.interpolateFunction)((PuppeteerUtil) => {
          PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
            queryAll: PLACEHOLDER("queryAll"),
            queryOne: PLACEHOLDER("queryOne")
          });
        }, {
          name: JSON.stringify(name),
          queryAll: handler.queryAll ? (0, Function_js_1.stringifyFunction)(handler.queryAll) : String(void 0),
          queryOne: handler.queryOne ? (0, Function_js_1.stringifyFunction)(handler.queryOne) : String(void 0)
        }).toString();
        __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").set(name, [registerScript, Handler]);
        ScriptInjector_js_1.scriptInjector.append(registerScript);
      }
      /**
       * Unregisters the {@link CustomQueryHandler | custom query handler} for the
       * given name.
       *
       * @throws `Error` if there is no handler under the given name.
       *
       * @internal
       */
      unregister(name) {
        const handler = __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").get(name);
        if (!handler) {
          throw new Error(`Cannot unregister unknown handler: ${name}`);
        }
        ScriptInjector_js_1.scriptInjector.pop(handler[0]);
        __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").delete(name);
      }
      /**
       * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
       *
       * @internal
       */
      names() {
        return [...__classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").keys()];
      }
      /**
       * Unregisters all custom query handlers.
       *
       * @internal
       */
      clear() {
        for (const [registerScript] of __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f")) {
          ScriptInjector_js_1.scriptInjector.pop(registerScript);
        }
        __classPrivateFieldGet(this, _CustomQueryHandlerRegistry_handlers, "f").clear();
      }
    };
    exports2.CustomQueryHandlerRegistry = CustomQueryHandlerRegistry;
    _CustomQueryHandlerRegistry_handlers = /* @__PURE__ */ new WeakMap();
    exports2.customQueryHandlers = new CustomQueryHandlerRegistry();
    function registerCustomQueryHandler(name, handler) {
      exports2.customQueryHandlers.register(name, handler);
    }
    exports2.registerCustomQueryHandler = registerCustomQueryHandler;
    function unregisterCustomQueryHandler(name) {
      exports2.customQueryHandlers.unregister(name);
    }
    exports2.unregisterCustomQueryHandler = unregisterCustomQueryHandler;
    function customQueryHandlerNames() {
      return exports2.customQueryHandlers.names();
    }
    exports2.customQueryHandlerNames = customQueryHandlerNames;
    function clearCustomQueryHandlers() {
      exports2.customQueryHandlers.clear();
    }
    exports2.clearCustomQueryHandlers = clearCustomQueryHandlers;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PierceQueryHandler.js
var require_PierceQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/PierceQueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PierceQueryHandler = void 0;
    var QueryHandler_js_1 = require_QueryHandler();
    var PierceQueryHandler = class extends QueryHandler_js_1.QueryHandler {
    };
    exports2.PierceQueryHandler = PierceQueryHandler;
    PierceQueryHandler.querySelector = (element, selector, { pierceQuerySelector }) => {
      return pierceQuerySelector(element, selector);
    };
    PierceQueryHandler.querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
      return pierceQuerySelectorAll(element, selector);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PQueryHandler.js
var require_PQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/PQueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PQueryHandler = void 0;
    var QueryHandler_js_1 = require_QueryHandler();
    var PQueryHandler = class extends QueryHandler_js_1.QueryHandler {
    };
    exports2.PQueryHandler = PQueryHandler;
    PQueryHandler.querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
      return pQuerySelectorAll(element, selector);
    };
    PQueryHandler.querySelector = (element, selector, { pQuerySelector }) => {
      return pQuerySelector(element, selector);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TextQueryHandler.js
var require_TextQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/TextQueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextQueryHandler = void 0;
    var QueryHandler_js_1 = require_QueryHandler();
    var TextQueryHandler = class extends QueryHandler_js_1.QueryHandler {
    };
    exports2.TextQueryHandler = TextQueryHandler;
    TextQueryHandler.querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
      return textQuerySelectorAll(element, selector);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/XPathQueryHandler.js
var require_XPathQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/XPathQueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathQueryHandler = void 0;
    var QueryHandler_js_1 = require_QueryHandler();
    var XPathQueryHandler = class extends QueryHandler_js_1.QueryHandler {
    };
    exports2.XPathQueryHandler = XPathQueryHandler;
    XPathQueryHandler.querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
      return xpathQuerySelectorAll(element, selector);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/GetQueryHandler.js
var require_GetQueryHandler = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/GetQueryHandler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getQueryHandlerAndSelector = exports2.getQueryHandlerByName = exports2.BUILTIN_QUERY_HANDLERS = void 0;
    var AriaQueryHandler_js_1 = require_AriaQueryHandler();
    var CustomQueryHandler_js_1 = require_CustomQueryHandler();
    var PierceQueryHandler_js_1 = require_PierceQueryHandler();
    var PQueryHandler_js_1 = require_PQueryHandler();
    var TextQueryHandler_js_1 = require_TextQueryHandler();
    var XPathQueryHandler_js_1 = require_XPathQueryHandler();
    exports2.BUILTIN_QUERY_HANDLERS = Object.freeze({
      aria: AriaQueryHandler_js_1.ARIAQueryHandler,
      pierce: PierceQueryHandler_js_1.PierceQueryHandler,
      xpath: XPathQueryHandler_js_1.XPathQueryHandler,
      text: TextQueryHandler_js_1.TextQueryHandler
    });
    var QUERY_SEPARATORS = ["=", "/"];
    function getQueryHandlerByName(name) {
      if (name in exports2.BUILTIN_QUERY_HANDLERS) {
        return exports2.BUILTIN_QUERY_HANDLERS[name];
      }
      return CustomQueryHandler_js_1.customQueryHandlers.get(name);
    }
    exports2.getQueryHandlerByName = getQueryHandlerByName;
    function getQueryHandlerAndSelector(selector) {
      for (const handlerMap of [
        CustomQueryHandler_js_1.customQueryHandlers.names().map((name) => {
          return [name, CustomQueryHandler_js_1.customQueryHandlers.get(name)];
        }),
        Object.entries(exports2.BUILTIN_QUERY_HANDLERS)
      ]) {
        for (const [name, QueryHandler] of handlerMap) {
          for (const separator of QUERY_SEPARATORS) {
            const prefix = `${name}${separator}`;
            if (selector.startsWith(prefix)) {
              selector = selector.slice(prefix.length);
              return { updatedSelector: selector, QueryHandler };
            }
          }
        }
      }
      return { updatedSelector: selector, QueryHandler: PQueryHandler_js_1.PQueryHandler };
    }
    exports2.getQueryHandlerAndSelector = getQueryHandlerAndSelector;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/JSHandle.js
var require_JSHandle2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/JSHandle.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _CDPJSHandle_disposed;
    var _CDPJSHandle_context;
    var _CDPJSHandle_remoteObject;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CDPJSHandle = void 0;
    var JSHandle_js_1 = require_JSHandle();
    var assert_js_1 = require_assert();
    var util_js_1 = require_util2();
    var CDPJSHandle = class extends JSHandle_js_1.JSHandle {
      get disposed() {
        return __classPrivateFieldGet(this, _CDPJSHandle_disposed, "f");
      }
      constructor(context, remoteObject) {
        super();
        _CDPJSHandle_disposed.set(this, false);
        _CDPJSHandle_context.set(this, void 0);
        _CDPJSHandle_remoteObject.set(this, void 0);
        __classPrivateFieldSet(this, _CDPJSHandle_context, context, "f");
        __classPrivateFieldSet(this, _CDPJSHandle_remoteObject, remoteObject, "f");
      }
      executionContext() {
        return __classPrivateFieldGet(this, _CDPJSHandle_context, "f");
      }
      get client() {
        return __classPrivateFieldGet(this, _CDPJSHandle_context, "f")._client;
      }
      /**
       * @see {@link ExecutionContext.evaluate} for more details.
       */
      async evaluate(pageFunction, ...args) {
        return await this.executionContext().evaluate(pageFunction, this, ...args);
      }
      /**
       * @see {@link ExecutionContext.evaluateHandle} for more details.
       */
      async evaluateHandle(pageFunction, ...args) {
        return await this.executionContext().evaluateHandle(pageFunction, this, ...args);
      }
      async getProperty(propertyName) {
        return this.evaluateHandle((object, propertyName2) => {
          return object[propertyName2];
        }, propertyName);
      }
      async getProperties() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").objectId);
        const response = await this.client.send("Runtime.getProperties", {
          objectId: __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").objectId,
          ownProperties: true
        });
        const result = /* @__PURE__ */ new Map();
        for (const property of response.result) {
          if (!property.enumerable || !property.value) {
            continue;
          }
          result.set(property.name, (0, util_js_1.createJSHandle)(__classPrivateFieldGet(this, _CDPJSHandle_context, "f"), property.value));
        }
        return result;
      }
      async jsonValue() {
        if (!__classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").objectId) {
          return (0, util_js_1.valueFromRemoteObject)(__classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f"));
        }
        const value = await this.evaluate((object) => {
          return object;
        });
        if (value === void 0) {
          throw new Error("Could not serialize referenced object");
        }
        return value;
      }
      /**
       * Either `null` or the handle itself if the handle is an
       * instance of {@link ElementHandle}.
       */
      asElement() {
        return null;
      }
      async dispose() {
        if (__classPrivateFieldGet(this, _CDPJSHandle_disposed, "f")) {
          return;
        }
        __classPrivateFieldSet(this, _CDPJSHandle_disposed, true, "f");
        await (0, util_js_1.releaseObject)(this.client, __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f"));
      }
      toString() {
        if (!__classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").objectId) {
          return "JSHandle:" + (0, util_js_1.valueFromRemoteObject)(__classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f"));
        }
        const type = __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").subtype || __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").type;
        return "JSHandle@" + type;
      }
      get id() {
        return __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f").objectId;
      }
      remoteObject() {
        return __classPrivateFieldGet(this, _CDPJSHandle_remoteObject, "f");
      }
    };
    exports2.CDPJSHandle = CDPJSHandle;
    _CDPJSHandle_disposed = /* @__PURE__ */ new WeakMap(), _CDPJSHandle_context = /* @__PURE__ */ new WeakMap(), _CDPJSHandle_remoteObject = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ElementHandle.js
var require_ElementHandle2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ElementHandle.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _CDPElementHandle_instances;
    var _CDPElementHandle_frame;
    var _CDPElementHandle_frameManager_get;
    var _CDPElementHandle_page_get;
    var _CDPElementHandle_checkVisibility;
    var _CDPElementHandle_scrollIntoViewIfNeeded;
    var _CDPElementHandle_getOOPIFOffsets;
    var _CDPElementHandle_getBoxModel;
    var _CDPElementHandle_fromProtocolQuad;
    var _CDPElementHandle_intersectQuadWithViewport;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CDPElementHandle = void 0;
    var ElementHandle_js_1 = require_ElementHandle();
    var assert_js_1 = require_assert();
    var AsyncIterableUtil_js_1 = require_AsyncIterableUtil();
    var GetQueryHandler_js_1 = require_GetQueryHandler();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var JSHandle_js_1 = require_JSHandle2();
    var LazyArg_js_1 = require_LazyArg();
    var util_js_1 = require_util2();
    var applyOffsetsToQuad = (quad, offsetX, offsetY) => {
      return quad.map((part) => {
        return { x: part.x + offsetX, y: part.y + offsetY };
      });
    };
    var CDPElementHandle = class extends ElementHandle_js_1.ElementHandle {
      constructor(context, remoteObject, frame) {
        super(new JSHandle_js_1.CDPJSHandle(context, remoteObject));
        _CDPElementHandle_instances.add(this);
        _CDPElementHandle_frame.set(this, void 0);
        __classPrivateFieldSet(this, _CDPElementHandle_frame, frame, "f");
      }
      /**
       * @internal
       */
      executionContext() {
        return this.handle.executionContext();
      }
      /**
       * @internal
       */
      get client() {
        return this.handle.client;
      }
      remoteObject() {
        return this.handle.remoteObject();
      }
      get frame() {
        return __classPrivateFieldGet(this, _CDPElementHandle_frame, "f");
      }
      async $(selector) {
        const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
        return await QueryHandler.queryOne(this, updatedSelector);
      }
      async $$(selector) {
        const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
        return AsyncIterableUtil_js_1.AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));
      }
      async $eval(selector, pageFunction, ...args) {
        const elementHandle = await this.$(selector);
        if (!elementHandle) {
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        }
        const result = await elementHandle.evaluate(pageFunction, ...args);
        await elementHandle.dispose();
        return result;
      }
      async $$eval(selector, pageFunction, ...args) {
        const results = await this.$$(selector);
        const elements = await this.evaluateHandle((_, ...elements2) => {
          return elements2;
        }, ...results);
        const [result] = await Promise.all([
          elements.evaluate(pageFunction, ...args),
          ...results.map((results2) => {
            return results2.dispose();
          })
        ]);
        await elements.dispose();
        return result;
      }
      async $x(expression) {
        if (expression.startsWith("//")) {
          expression = `.${expression}`;
        }
        return this.$$(`xpath/${expression}`);
      }
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
        return await QueryHandler.waitFor(this, updatedSelector, options);
      }
      async waitForXPath(xpath, options = {}) {
        if (xpath.startsWith("//")) {
          xpath = `.${xpath}`;
        }
        return this.waitForSelector(`xpath/${xpath}`, options);
      }
      async isVisible() {
        return __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_checkVisibility).call(this, true);
      }
      async isHidden() {
        return __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_checkVisibility).call(this, false);
      }
      async toElement(tagName) {
        const isMatchingTagName = await this.evaluate((node, tagName2) => {
          return node.nodeName === tagName2.toUpperCase();
        }, tagName);
        if (!isMatchingTagName) {
          throw new Error(`Element is not a(n) \`${tagName}\` element`);
        }
        return this;
      }
      async contentFrame() {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.remoteObject().objectId
        });
        if (typeof nodeInfo.node.frameId !== "string") {
          return null;
        }
        return __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_frameManager_get).frame(nodeInfo.node.frameId);
      }
      async scrollIntoView() {
        await this.assertConnectedElement();
        try {
          await this.client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: this.remoteObject().objectId
          });
        } catch (error) {
          (0, util_js_1.debugError)(error);
          await this.evaluate(async (element) => {
            element.scrollIntoView({
              block: "center",
              inline: "center",
              // @ts-expect-error Chrome still supports behavior: instant but
              // it's not in the spec so TS shouts We don't want to make this
              // breaking change in Puppeteer yet so we'll ignore the line.
              behavior: "instant"
            });
          });
        }
      }
      async clickablePoint(offset) {
        const [result, layoutMetrics] = await Promise.all([
          this.client.send("DOM.getContentQuads", {
            objectId: this.remoteObject().objectId
          }).catch(util_js_1.debugError),
          __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get)._client().send("Page.getLayoutMetrics")
        ]);
        if (!result || !result.quads.length) {
          throw new Error("Node is either not clickable or not an HTMLElement");
        }
        const { clientWidth, clientHeight } = layoutMetrics.cssLayoutViewport || layoutMetrics.layoutViewport;
        const { offsetX, offsetY } = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _CDPElementHandle_frame, "f"));
        const quads = result.quads.map((quad2) => {
          return __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, quad2);
        }).map((quad2) => {
          return applyOffsetsToQuad(quad2, offsetX, offsetY);
        }).map((quad2) => {
          return __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_intersectQuadWithViewport).call(this, quad2, clientWidth, clientHeight);
        }).filter((quad2) => {
          return computeQuadArea(quad2) > 1;
        });
        if (!quads.length) {
          throw new Error("Node is either not clickable or not an HTMLElement");
        }
        const quad = quads[0];
        if (offset) {
          let minX = Number.MAX_SAFE_INTEGER;
          let minY = Number.MAX_SAFE_INTEGER;
          for (const point of quad) {
            if (point.x < minX) {
              minX = point.x;
            }
            if (point.y < minY) {
              minY = point.y;
            }
          }
          if (minX !== Number.MAX_SAFE_INTEGER && minY !== Number.MAX_SAFE_INTEGER) {
            return {
              x: minX + offset.x,
              y: minY + offset.y
            };
          }
        }
        let x = 0;
        let y = 0;
        for (const point of quad) {
          x += point.x;
          y += point.y;
        }
        return {
          x: x / 4,
          y: y / 4
        };
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page.mouse} to hover over the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async hover() {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const { x, y } = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.move(x, y);
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page.mouse} to click in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async click(options = {}) {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const { x, y } = await this.clickablePoint(options.offset);
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.click(x, y, options);
      }
      /**
       * This method creates and captures a dragevent from the element.
       */
      async drag(target) {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).isDragInterceptionEnabled(), "Drag Interception is not enabled!");
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const start = await this.clickablePoint();
        return await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.drag(start, target);
      }
      async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const target = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragEnter(target, data);
      }
      async dragOver(data = { items: [], dragOperationsMask: 1 }) {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const target = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragOver(target, data);
      }
      async drop(data = { items: [], dragOperationsMask: 1 }) {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const destination = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.drop(destination, data);
      }
      async dragAndDrop(target, options) {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const startPoint = await this.clickablePoint();
        const targetPoint = await target.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragAndDrop(startPoint, targetPoint, options);
      }
      async select(...values) {
        for (const value of values) {
          (0, assert_js_1.assert)((0, util_js_1.isString)(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        }
        return this.evaluate((element, vals) => {
          const values2 = new Set(vals);
          if (!(element instanceof HTMLSelectElement)) {
            throw new Error("Element is not a <select> element.");
          }
          const selectedValues = /* @__PURE__ */ new Set();
          if (!element.multiple) {
            for (const option of element.options) {
              option.selected = false;
            }
            for (const option of element.options) {
              if (values2.has(option.value)) {
                option.selected = true;
                selectedValues.add(option.value);
                break;
              }
            }
          } else {
            for (const option of element.options) {
              option.selected = values2.has(option.value);
              if (option.selected) {
                selectedValues.add(option.value);
              }
            }
          }
          element.dispatchEvent(new Event("input", { bubbles: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
          return [...selectedValues.values()];
        }, values);
      }
      async uploadFile(...filePaths) {
        const isMultiple = await this.evaluate((element) => {
          return element.multiple;
        });
        (0, assert_js_1.assert)(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
        let path;
        try {
          path = await Promise.resolve().then(() => __importStar(require("path")));
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
          }
          throw error;
        }
        const files = filePaths.map((filePath) => {
          if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
            return filePath;
          } else {
            return path.resolve(filePath);
          }
        });
        const { objectId } = this.remoteObject();
        const { node } = await this.client.send("DOM.describeNode", {
          objectId
        });
        const { backendNodeId } = node;
        if (files.length === 0) {
          await this.evaluate((element) => {
            element.files = new DataTransfer().files;
            element.dispatchEvent(new Event("input", { bubbles: true }));
            element.dispatchEvent(new Event("change", { bubbles: true }));
          });
        } else {
          await this.client.send("DOM.setFileInputFiles", {
            objectId,
            files,
            backendNodeId
          });
        }
      }
      async tap() {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const { x, y } = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchStart(x, y);
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchEnd();
      }
      async touchStart() {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const { x, y } = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchStart(x, y);
      }
      async touchMove() {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        const { x, y } = await this.clickablePoint();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchMove(x, y);
      }
      async touchEnd() {
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchEnd();
      }
      async focus() {
        await this.evaluate((element) => {
          if (!(element instanceof HTMLElement)) {
            throw new Error("Cannot focus non-HTMLElement");
          }
          return element.focus();
        });
      }
      async type(text, options) {
        await this.focus();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).keyboard.type(text, options);
      }
      async press(key, options) {
        await this.focus();
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).keyboard.press(key, options);
      }
      async boundingBox() {
        const result = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getBoxModel).call(this);
        if (!result) {
          return null;
        }
        const { offsetX, offsetY } = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _CDPElementHandle_frame, "f"));
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x: x + offsetX, y: y + offsetY, width, height };
      }
      async boxModel() {
        const result = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getBoxModel).call(this);
        if (!result) {
          return null;
        }
        const { offsetX, offsetY } = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet(this, _CDPElementHandle_frame, "f"));
        const { content, padding, border, margin, width, height } = result.model;
        return {
          content: applyOffsetsToQuad(__classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, content), offsetX, offsetY),
          padding: applyOffsetsToQuad(__classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, padding), offsetX, offsetY),
          border: applyOffsetsToQuad(__classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, border), offsetX, offsetY),
          margin: applyOffsetsToQuad(__classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, margin), offsetX, offsetY),
          width,
          height
        };
      }
      async screenshot(options = {}) {
        let needsViewportReset = false;
        let boundingBox = await this.boundingBox();
        (0, assert_js_1.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
        const viewport = __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).viewport();
        if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {
          const newViewport = {
            width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
            height: Math.max(viewport.height, Math.ceil(boundingBox.height))
          };
          await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).setViewport(Object.assign({}, viewport, newViewport));
          needsViewportReset = true;
        }
        await __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_scrollIntoViewIfNeeded).call(this);
        boundingBox = await this.boundingBox();
        (0, assert_js_1.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
        (0, assert_js_1.assert)(boundingBox.width !== 0, "Node has 0 width.");
        (0, assert_js_1.assert)(boundingBox.height !== 0, "Node has 0 height.");
        const layoutMetrics = await this.client.send("Page.getLayoutMetrics");
        const { pageX, pageY } = layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;
        const clip = Object.assign({}, boundingBox);
        clip.x += pageX;
        clip.y += pageY;
        const imageData = await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).screenshot(Object.assign({}, {
          clip
        }, options));
        if (needsViewportReset && viewport) {
          await __classPrivateFieldGet(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).setViewport(viewport);
        }
        return imageData;
      }
    };
    exports2.CDPElementHandle = CDPElementHandle;
    _CDPElementHandle_frame = /* @__PURE__ */ new WeakMap(), _CDPElementHandle_instances = /* @__PURE__ */ new WeakSet(), _CDPElementHandle_frameManager_get = function _CDPElementHandle_frameManager_get2() {
      return __classPrivateFieldGet(this, _CDPElementHandle_frame, "f")._frameManager;
    }, _CDPElementHandle_page_get = function _CDPElementHandle_page_get2() {
      return __classPrivateFieldGet(this, _CDPElementHandle_frame, "f").page();
    }, _CDPElementHandle_checkVisibility = async function _CDPElementHandle_checkVisibility2(visibility) {
      const element = await this.frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].adoptHandle(this);
      try {
        return await this.frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].evaluate(async (PuppeteerUtil, element2, visibility2) => {
          return Boolean(PuppeteerUtil.checkVisibility(element2, visibility2));
        }, LazyArg_js_1.LazyArg.create((context) => {
          return context.puppeteerUtil;
        }), element, visibility);
      } finally {
        await element.dispose();
      }
    }, _CDPElementHandle_scrollIntoViewIfNeeded = async function _CDPElementHandle_scrollIntoViewIfNeeded2() {
      if (await this.isIntersectingViewport({
        threshold: 1
      })) {
        return;
      }
      await this.scrollIntoView();
    }, _CDPElementHandle_getOOPIFOffsets = async function _CDPElementHandle_getOOPIFOffsets2(frame) {
      let offsetX = 0;
      let offsetY = 0;
      let currentFrame = frame;
      while (currentFrame && currentFrame.parentFrame()) {
        const parent = currentFrame.parentFrame();
        if (!currentFrame.isOOPFrame() || !parent) {
          currentFrame = parent;
          continue;
        }
        const { backendNodeId } = await parent._client().send("DOM.getFrameOwner", {
          frameId: currentFrame._id
        });
        const result = await parent._client().send("DOM.getBoxModel", {
          backendNodeId
        });
        if (!result) {
          break;
        }
        const contentBoxQuad = result.model.content;
        const topLeftCorner = __classPrivateFieldGet(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, contentBoxQuad)[0];
        offsetX += topLeftCorner.x;
        offsetY += topLeftCorner.y;
        currentFrame = parent;
      }
      return { offsetX, offsetY };
    }, _CDPElementHandle_getBoxModel = function _CDPElementHandle_getBoxModel2() {
      const params = {
        objectId: this.id
      };
      return this.client.send("DOM.getBoxModel", params).catch((error) => {
        return (0, util_js_1.debugError)(error);
      });
    }, _CDPElementHandle_fromProtocolQuad = function _CDPElementHandle_fromProtocolQuad2(quad) {
      return [
        { x: quad[0], y: quad[1] },
        { x: quad[2], y: quad[3] },
        { x: quad[4], y: quad[5] },
        { x: quad[6], y: quad[7] }
      ];
    }, _CDPElementHandle_intersectQuadWithViewport = function _CDPElementHandle_intersectQuadWithViewport2(quad, width, height) {
      return quad.map((point) => {
        return {
          x: Math.min(Math.max(point.x, 0), width),
          y: Math.min(Math.max(point.y, 0), height)
        };
      });
    };
    function computeQuadArea(quad) {
      let area = 0;
      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }
      return Math.abs(area);
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Errors.js
var require_Errors = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Errors.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ProtocolError_code;
    var _ProtocolError_originalMessage;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errors = exports2.ProtocolError = exports2.TimeoutError = exports2.CustomError = void 0;
    var CustomError = class extends Error {
      /**
       * @internal
       */
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    exports2.CustomError = CustomError;
    var TimeoutError = class extends CustomError {
    };
    exports2.TimeoutError = TimeoutError;
    var ProtocolError = class extends CustomError {
      constructor() {
        super(...arguments);
        _ProtocolError_code.set(this, void 0);
        _ProtocolError_originalMessage.set(this, "");
      }
      set code(code) {
        __classPrivateFieldSet(this, _ProtocolError_code, code, "f");
      }
      /**
       * @readonly
       * @public
       */
      get code() {
        return __classPrivateFieldGet(this, _ProtocolError_code, "f");
      }
      set originalMessage(originalMessage) {
        __classPrivateFieldSet(this, _ProtocolError_originalMessage, originalMessage, "f");
      }
      /**
       * @readonly
       * @public
       */
      get originalMessage() {
        return __classPrivateFieldGet(this, _ProtocolError_originalMessage, "f");
      }
    };
    exports2.ProtocolError = ProtocolError;
    _ProtocolError_code = /* @__PURE__ */ new WeakMap(), _ProtocolError_originalMessage = /* @__PURE__ */ new WeakMap();
    exports2.errors = Object.freeze({
      TimeoutError,
      ProtocolError
    });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/util.js
var require_util2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setPageContent = exports2.getReadableFromProtocolStream = exports2.getReadableAsBuffer = exports2.importFSPromises = exports2.waitWithTimeout = exports2.pageBindingInitString = exports2.addPageBinding = exports2.evaluationString = exports2.createJSHandle = exports2.waitForEvent = exports2.isDate = exports2.isRegExp = exports2.isPlainObject = exports2.isNumber = exports2.isString = exports2.removeEventListeners = exports2.addEventListener = exports2.releaseObject = exports2.valueFromRemoteObject = exports2.getExceptionMessage = exports2.debugError = void 0;
    var environment_js_1 = require_environment();
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var Debug_js_1 = require_Debug();
    var ElementHandle_js_1 = require_ElementHandle2();
    var Errors_js_1 = require_Errors();
    var JSHandle_js_1 = require_JSHandle2();
    exports2.debugError = (0, Debug_js_1.debug)("puppeteer:error");
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception) {
        return exceptionDetails.exception.description || exceptionDetails.exception.value;
      }
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location})`;
        }
      }
      return message;
    }
    exports2.getExceptionMessage = getExceptionMessage;
    function valueFromRemoteObject(remoteObject) {
      (0, assert_js_1.assert)(!remoteObject.objectId, "Cannot extract value when objectId is given");
      if (remoteObject.unserializableValue) {
        if (remoteObject.type === "bigint") {
          return BigInt(remoteObject.unserializableValue.replace("n", ""));
        }
        switch (remoteObject.unserializableValue) {
          case "-0":
            return -0;
          case "NaN":
            return NaN;
          case "Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          default:
            throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
        }
      }
      return remoteObject.value;
    }
    exports2.valueFromRemoteObject = valueFromRemoteObject;
    async function releaseObject(client, remoteObject) {
      if (!remoteObject.objectId) {
        return;
      }
      await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
        (0, exports2.debugError)(error);
      });
    }
    exports2.releaseObject = releaseObject;
    function addEventListener(emitter, eventName, handler) {
      emitter.on(eventName, handler);
      return { emitter, eventName, handler };
    }
    exports2.addEventListener = addEventListener;
    function removeEventListeners(listeners) {
      for (const listener of listeners) {
        listener.emitter.removeListener(listener.eventName, listener.handler);
      }
      listeners.length = 0;
    }
    exports2.removeEventListeners = removeEventListeners;
    var isString = (obj) => {
      return typeof obj === "string" || obj instanceof String;
    };
    exports2.isString = isString;
    var isNumber = (obj) => {
      return typeof obj === "number" || obj instanceof Number;
    };
    exports2.isNumber = isNumber;
    var isPlainObject = (obj) => {
      return typeof obj === "object" && (obj === null || obj === void 0 ? void 0 : obj.constructor) === Object;
    };
    exports2.isPlainObject = isPlainObject;
    var isRegExp = (obj) => {
      return typeof obj === "object" && (obj === null || obj === void 0 ? void 0 : obj.constructor) === RegExp;
    };
    exports2.isRegExp = isRegExp;
    var isDate = (obj) => {
      return typeof obj === "object" && (obj === null || obj === void 0 ? void 0 : obj.constructor) === Date;
    };
    exports2.isDate = isDate;
    async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
      let eventTimeout;
      let resolveCallback;
      let rejectCallback;
      const promise = new Promise((resolve, reject) => {
        resolveCallback = resolve;
        rejectCallback = reject;
      });
      const listener = addEventListener(emitter, eventName, async (event) => {
        if (!await predicate(event)) {
          return;
        }
        resolveCallback(event);
      });
      if (timeout) {
        eventTimeout = setTimeout(() => {
          rejectCallback(new Errors_js_1.TimeoutError("Timeout exceeded while waiting for event"));
        }, timeout);
      }
      function cleanup() {
        removeEventListeners([listener]);
        clearTimeout(eventTimeout);
      }
      const result = await Promise.race([promise, abortPromise]).then((r) => {
        cleanup();
        return r;
      }, (error) => {
        cleanup();
        throw error;
      });
      if ((0, ErrorLike_js_1.isErrorLike)(result)) {
        throw result;
      }
      return result;
    }
    exports2.waitForEvent = waitForEvent;
    function createJSHandle(context, remoteObject) {
      if (remoteObject.subtype === "node" && context._world) {
        return new ElementHandle_js_1.CDPElementHandle(context, remoteObject, context._world.frame());
      }
      return new JSHandle_js_1.CDPJSHandle(context, remoteObject);
    }
    exports2.createJSHandle = createJSHandle;
    function evaluationString(fun, ...args) {
      if ((0, exports2.isString)(fun)) {
        (0, assert_js_1.assert)(args.length === 0, "Cannot evaluate a string with arguments");
        return fun;
      }
      function serializeArgument(arg) {
        if (Object.is(arg, void 0)) {
          return "undefined";
        }
        return JSON.stringify(arg);
      }
      return `(${fun})(${args.map(serializeArgument).join(",")})`;
    }
    exports2.evaluationString = evaluationString;
    function addPageBinding(type, name) {
      const callCDP = globalThis[name];
      Object.assign(globalThis, {
        [name](...args) {
          var _a, _b, _c;
          const callPuppeteer = globalThis[name];
          (_a = callPuppeteer.args) !== null && _a !== void 0 ? _a : callPuppeteer.args = /* @__PURE__ */ new Map();
          (_b = callPuppeteer.callbacks) !== null && _b !== void 0 ? _b : callPuppeteer.callbacks = /* @__PURE__ */ new Map();
          const seq = ((_c = callPuppeteer.lastSeq) !== null && _c !== void 0 ? _c : 0) + 1;
          callPuppeteer.lastSeq = seq;
          callPuppeteer.args.set(seq, args);
          callCDP(JSON.stringify({
            type,
            name,
            seq,
            args,
            isTrivial: !args.some((value) => {
              return value instanceof Node;
            })
          }));
          return new Promise((resolve, reject) => {
            callPuppeteer.callbacks.set(seq, {
              resolve(value) {
                callPuppeteer.args.delete(seq);
                resolve(value);
              },
              reject(value) {
                callPuppeteer.args.delete(seq);
                reject(value);
              }
            });
          });
        }
      });
    }
    exports2.addPageBinding = addPageBinding;
    function pageBindingInitString(type, name) {
      return evaluationString(addPageBinding, type, name);
    }
    exports2.pageBindingInitString = pageBindingInitString;
    async function waitWithTimeout(promise, taskName, timeout) {
      let reject;
      const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
      const timeoutPromise = new Promise((_, rej) => {
        return reject = rej;
      });
      let timeoutTimer = null;
      if (timeout) {
        timeoutTimer = setTimeout(() => {
          return reject(timeoutError);
        }, timeout);
      }
      try {
        return await Promise.race([promise, timeoutPromise]);
      } finally {
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
      }
    }
    exports2.waitWithTimeout = waitWithTimeout;
    var fs = null;
    async function importFSPromises() {
      if (!fs) {
        try {
          fs = await Promise.resolve().then(() => __importStar(require("fs/promises")));
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error("Cannot write to a path outside of a Node-like environment.");
          }
          throw error;
        }
      }
      return fs;
    }
    exports2.importFSPromises = importFSPromises;
    async function getReadableAsBuffer(readable, path) {
      const buffers = [];
      if (path) {
        const fs2 = await importFSPromises();
        const fileHandle = await fs2.open(path, "w+");
        try {
          for await (const chunk of readable) {
            buffers.push(chunk);
            await fileHandle.writeFile(chunk);
          }
        } finally {
          await fileHandle.close();
        }
      } else {
        for await (const chunk of readable) {
          buffers.push(chunk);
        }
      }
      try {
        return Buffer.concat(buffers);
      } catch (error) {
        return null;
      }
    }
    exports2.getReadableAsBuffer = getReadableAsBuffer;
    async function getReadableFromProtocolStream(client, handle) {
      if (!environment_js_1.isNode) {
        throw new Error("Cannot create a stream outside of Node.js environment.");
      }
      const { Readable } = await Promise.resolve().then(() => __importStar(require("stream")));
      let eof = false;
      return new Readable({
        async read(size) {
          if (eof) {
            return;
          }
          try {
            const response = await client.send("IO.read", { handle, size });
            this.push(response.data, response.base64Encoded ? "base64" : void 0);
            if (response.eof) {
              eof = true;
              await client.send("IO.close", { handle });
              this.push(null);
            }
          } catch (error) {
            if ((0, ErrorLike_js_1.isErrorLike)(error)) {
              this.destroy(error);
              return;
            }
            throw error;
          }
        }
      });
    }
    exports2.getReadableFromProtocolStream = getReadableFromProtocolStream;
    async function setPageContent(page, content) {
      return page.evaluate((html) => {
        document.open();
        document.write(html);
        document.close();
      }, content);
    }
    exports2.setPageContent = setPageContent;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/Page.js
var require_Page = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/Page.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Page_handlerMap;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unitToPixels = exports2.supportedMetrics = exports2.Page = void 0;
    var EventEmitter_js_1 = require_EventEmitter();
    var PDFOptions_js_1 = require_PDFOptions();
    var util_js_1 = require_util2();
    var assert_js_1 = require_assert();
    var Page = class extends EventEmitter_js_1.EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
        _Page_handlerMap.set(this, /* @__PURE__ */ new WeakMap());
      }
      /**
       * `true` if drag events are being intercepted, `false` otherwise.
       */
      isDragInterceptionEnabled() {
        throw new Error("Not implemented");
      }
      /**
       * `true` if the page has JavaScript enabled, `false` otherwise.
       */
      isJavaScriptEnabled() {
        throw new Error("Not implemented");
      }
      /**
       * Listen to page events.
       *
       * :::note
       *
       * This method exists to define event typings and handle proper wireup of
       * cooperative request interception. Actual event listening and dispatching is
       * delegated to {@link EventEmitter}.
       *
       * :::
       */
      on(eventName, handler) {
        if (eventName === "request") {
          const wrap = __classPrivateFieldGet(this, _Page_handlerMap, "f").get(handler) || ((event) => {
            event.enqueueInterceptAction(() => {
              return handler(event);
            });
          });
          __classPrivateFieldGet(this, _Page_handlerMap, "f").set(handler, wrap);
          return super.on(eventName, wrap);
        }
        return super.on(eventName, handler);
      }
      once(eventName, handler) {
        return super.once(eventName, handler);
      }
      off(eventName, handler) {
        if (eventName === "request") {
          handler = __classPrivateFieldGet(this, _Page_handlerMap, "f").get(handler) || handler;
        }
        return super.off(eventName, handler);
      }
      waitForFileChooser() {
        throw new Error("Not implemented");
      }
      async setGeolocation() {
        throw new Error("Not implemented");
      }
      /**
       * A target this page was created from.
       */
      target() {
        throw new Error("Not implemented");
      }
      /**
       * Get the browser the page belongs to.
       */
      browser() {
        throw new Error("Not implemented");
      }
      /**
       * Get the browser context that the page belongs to.
       */
      browserContext() {
        throw new Error("Not implemented");
      }
      /**
       * The page's main frame.
       *
       * @remarks
       * Page is guaranteed to have a main frame which persists during navigations.
       */
      mainFrame() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Keyboard}
       */
      get keyboard() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Touchscreen}
       */
      get touchscreen() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Coverage}
       */
      get coverage() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Tracing}
       */
      get tracing() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Accessibility}
       */
      get accessibility() {
        throw new Error("Not implemented");
      }
      /**
       * An array of all frames attached to the page.
       */
      frames() {
        throw new Error("Not implemented");
      }
      /**
       * All of the dedicated {@link
       * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |
       * WebWorkers} associated with the page.
       *
       * @remarks
       * This does not contain ServiceWorkers
       */
      workers() {
        throw new Error("Not implemented");
      }
      async setRequestInterception() {
        throw new Error("Not implemented");
      }
      async setDragInterception() {
        throw new Error("Not implemented");
      }
      setOfflineMode() {
        throw new Error("Not implemented");
      }
      emulateNetworkConditions() {
        throw new Error("Not implemented");
      }
      setDefaultNavigationTimeout() {
        throw new Error("Not implemented");
      }
      setDefaultTimeout() {
        throw new Error("Not implemented");
      }
      /**
       * Maximum time in milliseconds.
       */
      getDefaultTimeout() {
        throw new Error("Not implemented");
      }
      async $() {
        throw new Error("Not implemented");
      }
      async $$() {
        throw new Error("Not implemented");
      }
      async evaluateHandle() {
        throw new Error("Not implemented");
      }
      async queryObjects() {
        throw new Error("Not implemented");
      }
      async $eval() {
        throw new Error("Not implemented");
      }
      async $$eval() {
        throw new Error("Not implemented");
      }
      async $x() {
        throw new Error("Not implemented");
      }
      async cookies() {
        throw new Error("Not implemented");
      }
      async deleteCookie() {
        throw new Error("Not implemented");
      }
      async setCookie() {
        throw new Error("Not implemented");
      }
      async addScriptTag() {
        throw new Error("Not implemented");
      }
      async addStyleTag() {
        throw new Error("Not implemented");
      }
      async exposeFunction() {
        throw new Error("Not implemented");
      }
      async authenticate() {
        throw new Error("Not implemented");
      }
      async setExtraHTTPHeaders() {
        throw new Error("Not implemented");
      }
      async setUserAgent() {
        throw new Error("Not implemented");
      }
      /**
       * Object containing metrics as key/value pairs.
       *
       * @returns
       *
       * - `Timestamp` : The timestamp when the metrics sample was taken.
       *
       * - `Documents` : Number of documents in the page.
       *
       * - `Frames` : Number of frames in the page.
       *
       * - `JSEventListeners` : Number of events in the page.
       *
       * - `Nodes` : Number of DOM nodes in the page.
       *
       * - `LayoutCount` : Total number of full or partial page layout.
       *
       * - `RecalcStyleCount` : Total number of page style recalculations.
       *
       * - `LayoutDuration` : Combined durations of all page layouts.
       *
       * - `RecalcStyleDuration` : Combined duration of all page style
       *   recalculations.
       *
       * - `ScriptDuration` : Combined duration of JavaScript execution.
       *
       * - `TaskDuration` : Combined duration of all tasks performed by the browser.
       *
       * - `JSHeapUsedSize` : Used JavaScript heap size.
       *
       * - `JSHeapTotalSize` : Total JavaScript heap size.
       *
       * @remarks
       * All timestamps are in monotonic time: monotonically increasing time
       * in seconds since an arbitrary point in the past.
       */
      async metrics() {
        throw new Error("Not implemented");
      }
      /**
       * The page's URL.
       * @remarks Shortcut for
       * {@link Frame.url | page.mainFrame().url()}.
       */
      url() {
        throw new Error("Not implemented");
      }
      /**
       * The full HTML contents of the page, including the DOCTYPE.
       */
      async content() {
        throw new Error("Not implemented");
      }
      async setContent() {
        throw new Error("Not implemented");
      }
      async goto() {
        throw new Error("Not implemented");
      }
      async reload() {
        throw new Error("Not implemented");
      }
      async waitForNavigation() {
        throw new Error("Not implemented");
      }
      async waitForRequest() {
        throw new Error("Not implemented");
      }
      async waitForResponse() {
        throw new Error("Not implemented");
      }
      async waitForNetworkIdle() {
        throw new Error("Not implemented");
      }
      async waitForFrame() {
        throw new Error("Not implemented");
      }
      async goBack() {
        throw new Error("Not implemented");
      }
      async goForward() {
        throw new Error("Not implemented");
      }
      /**
       * Brings page to front (activates tab).
       */
      async bringToFront() {
        throw new Error("Not implemented");
      }
      /**
       * Emulates a given device's metrics and user agent.
       *
       * To aid emulation, Puppeteer provides a list of known devices that can be
       * via {@link KnownDevices}.
       *
       * @remarks
       * This method is a shortcut for calling two methods:
       * {@link Page.setUserAgent} and {@link Page.setViewport}.
       *
       * @remarks
       * This method will resize the page. A lot of websites don't expect phones to
       * change size, so you should emulate before navigating to the page.
       *
       * @example
       *
       * ```ts
       * import {KnownDevices} from 'puppeteer';
       * const iPhone = KnownDevices['iPhone 6'];
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   await page.emulate(iPhone);
       *   await page.goto('https://www.google.com');
       *   // other actions...
       *   await browser.close();
       * })();
       * ```
       */
      async emulate(device) {
        await Promise.all([
          this.setUserAgent(device.userAgent),
          this.setViewport(device.viewport)
        ]);
      }
      async setJavaScriptEnabled() {
        throw new Error("Not implemented");
      }
      async setBypassCSP() {
        throw new Error("Not implemented");
      }
      async emulateMediaType() {
        throw new Error("Not implemented");
      }
      async emulateCPUThrottling() {
        throw new Error("Not implemented");
      }
      async emulateMediaFeatures() {
        throw new Error("Not implemented");
      }
      async emulateTimezone() {
        throw new Error("Not implemented");
      }
      async emulateIdleState() {
        throw new Error("Not implemented");
      }
      async emulateVisionDeficiency() {
        throw new Error("Not implemented");
      }
      async setViewport() {
        throw new Error("Not implemented");
      }
      /**
       * Current page viewport settings.
       *
       * @returns
       *
       * - `width`: page's width in pixels
       *
       * - `height`: page's height in pixels
       *
       * - `deviceScaleFactor`: Specify device scale factor (can be though of as
       *   dpr). Defaults to `1`.
       *
       * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults
       *   to `false`.
       *
       * - `hasTouch`: Specifies if viewport supports touch events. Defaults to
       *   `false`.
       *
       * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to
       *   `false`.
       */
      viewport() {
        throw new Error("Not implemented");
      }
      async evaluate() {
        throw new Error("Not implemented");
      }
      async evaluateOnNewDocument() {
        throw new Error("Not implemented");
      }
      async setCacheEnabled() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      async _maybeWriteBufferToFile(path, buffer) {
        if (!path) {
          return;
        }
        const fs = await (0, util_js_1.importFSPromises)();
        await fs.writeFile(path, buffer);
      }
      async screenshot() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      _getPDFOptions(options = {}, lengthUnit = "in") {
        var _a, _b, _c, _d, _e, _f;
        const defaults = {
          scale: 1,
          displayHeaderFooter: false,
          headerTemplate: "",
          footerTemplate: "",
          printBackground: false,
          landscape: false,
          pageRanges: "",
          preferCSSPageSize: false,
          omitBackground: false,
          timeout: 3e4
        };
        let width = 8.5;
        let height = 11;
        if (options.format) {
          const format = PDFOptions_js_1.paperFormats[options.format.toLowerCase()];
          (0, assert_js_1.assert)(format, "Unknown paper format: " + options.format);
          width = format.width;
          height = format.height;
        } else {
          width = (_a = convertPrintParameterToInches(options.width, lengthUnit)) !== null && _a !== void 0 ? _a : width;
          height = (_b = convertPrintParameterToInches(options.height, lengthUnit)) !== null && _b !== void 0 ? _b : height;
        }
        const margin = {
          top: convertPrintParameterToInches((_c = options.margin) === null || _c === void 0 ? void 0 : _c.top, lengthUnit) || 0,
          left: convertPrintParameterToInches((_d = options.margin) === null || _d === void 0 ? void 0 : _d.left, lengthUnit) || 0,
          bottom: convertPrintParameterToInches((_e = options.margin) === null || _e === void 0 ? void 0 : _e.bottom, lengthUnit) || 0,
          right: convertPrintParameterToInches((_f = options.margin) === null || _f === void 0 ? void 0 : _f.right, lengthUnit) || 0
        };
        const output = {
          ...defaults,
          ...options,
          width,
          height,
          margin
        };
        return output;
      }
      async createPDFStream() {
        throw new Error("Not implemented");
      }
      async pdf() {
        throw new Error("Not implemented");
      }
      /**
       * The page's title
       *
       * @remarks
       * Shortcut for {@link Frame.title | page.mainFrame().title()}.
       */
      async title() {
        throw new Error("Not implemented");
      }
      async close() {
        throw new Error("Not implemented");
      }
      /**
       * Indicates that the page has been closed.
       * @returns
       */
      isClosed() {
        throw new Error("Not implemented");
      }
      /**
       * {@inheritDoc Mouse}
       */
      get mouse() {
        throw new Error("Not implemented");
      }
      click() {
        throw new Error("Not implemented");
      }
      focus() {
        throw new Error("Not implemented");
      }
      hover() {
        throw new Error("Not implemented");
      }
      select() {
        throw new Error("Not implemented");
      }
      tap() {
        throw new Error("Not implemented");
      }
      type() {
        throw new Error("Not implemented");
      }
      waitForTimeout() {
        throw new Error("Not implemented");
      }
      async waitForSelector() {
        throw new Error("Not implemented");
      }
      waitForXPath() {
        throw new Error("Not implemented");
      }
      waitForFunction() {
        throw new Error("Not implemented");
      }
      waitForDevicePrompt() {
        throw new Error("Not implemented");
      }
    };
    exports2.Page = Page;
    _Page_handlerMap = /* @__PURE__ */ new WeakMap();
    exports2.supportedMetrics = /* @__PURE__ */ new Set([
      "Timestamp",
      "Documents",
      "Frames",
      "JSEventListeners",
      "Nodes",
      "LayoutCount",
      "RecalcStyleCount",
      "LayoutDuration",
      "RecalcStyleDuration",
      "ScriptDuration",
      "TaskDuration",
      "JSHeapUsedSize",
      "JSHeapTotalSize"
    ]);
    exports2.unitToPixels = {
      px: 1,
      in: 96,
      cm: 37.8,
      mm: 3.78
    };
    function convertPrintParameterToInches(parameter, lengthUnit = "in") {
      if (typeof parameter === "undefined") {
        return void 0;
      }
      let pixels;
      if ((0, util_js_1.isNumber)(parameter)) {
        pixels = parameter;
      } else if ((0, util_js_1.isString)(parameter)) {
        const text = parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = "";
        if (unit in exports2.unitToPixels) {
          valueText = text.substring(0, text.length - 2);
        } else {
          unit = "px";
          valueText = text;
        }
        const value = Number(valueText);
        (0, assert_js_1.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
        pixels = value * exports2.unitToPixels[unit];
      } else {
        throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
      }
      return pixels / exports2.unitToPixels[lengthUnit];
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/HTTPResponse.js
var require_HTTPResponse = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/HTTPResponse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTTPResponse = void 0;
    var HTTPResponse = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * @internal
       */
      _resolveBody(_err) {
        throw new Error("Not implemented");
      }
      /**
       * The IP address and port number used to connect to the remote
       * server.
       */
      remoteAddress() {
        throw new Error("Not implemented");
      }
      /**
       * The URL of the response.
       */
      url() {
        throw new Error("Not implemented");
      }
      /**
       * True if the response was successful (status in the range 200-299).
       */
      ok() {
        throw new Error("Not implemented");
      }
      /**
       * The status code of the response (e.g., 200 for a success).
       */
      status() {
        throw new Error("Not implemented");
      }
      /**
       * The status text of the response (e.g. usually an "OK" for a
       * success).
       */
      statusText() {
        throw new Error("Not implemented");
      }
      /**
       * An object with HTTP headers associated with the response. All
       * header names are lower-case.
       */
      headers() {
        throw new Error("Not implemented");
      }
      /**
       * {@link SecurityDetails} if the response was received over the
       * secure connection, or `null` otherwise.
       */
      securityDetails() {
        throw new Error("Not implemented");
      }
      /**
       * Timing information related to the response.
       */
      timing() {
        throw new Error("Not implemented");
      }
      /**
       * Promise which resolves to a buffer with response body.
       */
      buffer() {
        throw new Error("Not implemented");
      }
      /**
       * Promise which resolves to a text representation of response body.
       */
      async text() {
        const content = await this.buffer();
        return content.toString("utf8");
      }
      /**
       * Promise which resolves to a JSON representation of response body.
       *
       * @remarks
       *
       * This method will throw if the response body is not parsable via
       * `JSON.parse`.
       */
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
      /**
       * A matching {@link HTTPRequest} object.
       */
      request() {
        throw new Error("Not implemented");
      }
      /**
       * True if the response was served from either the browser's disk
       * cache or memory cache.
       */
      fromCache() {
        throw new Error("Not implemented");
      }
      /**
       * True if the response was served by a service worker.
       */
      fromServiceWorker() {
        throw new Error("Not implemented");
      }
      /**
       * A {@link Frame} that initiated this response, or `null` if
       * navigating to error pages.
       */
      frame() {
        throw new Error("Not implemented");
      }
    };
    exports2.HTTPResponse = HTTPResponse;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/HTTPRequest.js
var require_HTTPRequest = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/HTTPRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STATUS_TEXTS = exports2.headersArray = exports2.InterceptResolutionAction = exports2.HTTPRequest = exports2.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = void 0;
    exports2.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;
    var HTTPRequest = class {
      /**
       * Warning! Using this client can break Puppeteer. Use with caution.
       *
       * @experimental
       */
      get client() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      constructor() {
        this._requestId = "";
        this._failureText = null;
        this._response = null;
        this._fromMemoryCache = false;
        this._redirectChain = [];
      }
      /**
       * The URL of the request
       */
      url() {
        throw new Error("Not implemented");
      }
      /**
       * The `ContinueRequestOverrides` that will be used
       * if the interception is allowed to continue (ie, `abort()` and
       * `respond()` aren't called).
       */
      continueRequestOverrides() {
        throw new Error("Not implemented");
      }
      /**
       * The `ResponseForRequest` that gets used if the
       * interception is allowed to respond (ie, `abort()` is not called).
       */
      responseForRequest() {
        throw new Error("Not implemented");
      }
      /**
       * The most recent reason for aborting the request
       */
      abortErrorReason() {
        throw new Error("Not implemented");
      }
      /**
       * An InterceptResolutionState object describing the current resolution
       * action and priority.
       *
       * InterceptResolutionState contains:
       * action: InterceptResolutionAction
       * priority?: number
       *
       * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
       * `disabled`, `none`, or `already-handled`.
       */
      interceptResolutionState() {
        throw new Error("Not implemented");
      }
      /**
       * Is `true` if the intercept resolution has already been handled,
       * `false` otherwise.
       */
      isInterceptResolutionHandled() {
        throw new Error("Not implemented");
      }
      enqueueInterceptAction() {
        throw new Error("Not implemented");
      }
      /**
       * Awaits pending interception handlers and then decides how to fulfill
       * the request interception.
       */
      async finalizeInterceptions() {
        throw new Error("Not implemented");
      }
      /**
       * Contains the request's resource type as it was perceived by the rendering
       * engine.
       */
      resourceType() {
        throw new Error("Not implemented");
      }
      /**
       * The method used (`GET`, `POST`, etc.)
       */
      method() {
        throw new Error("Not implemented");
      }
      /**
       * The request's post body, if any.
       */
      postData() {
        throw new Error("Not implemented");
      }
      /**
       * An object with HTTP headers associated with the request. All
       * header names are lower-case.
       */
      headers() {
        throw new Error("Not implemented");
      }
      /**
       * A matching `HTTPResponse` object, or null if the response has not
       * been received yet.
       */
      response() {
        throw new Error("Not implemented");
      }
      /**
       * The frame that initiated the request, or null if navigating to
       * error pages.
       */
      frame() {
        throw new Error("Not implemented");
      }
      /**
       * True if the request is the driver of the current frame's navigation.
       */
      isNavigationRequest() {
        throw new Error("Not implemented");
      }
      /**
       * The initiator of the request.
       */
      initiator() {
        throw new Error("Not implemented");
      }
      /**
       * A `redirectChain` is a chain of requests initiated to fetch a resource.
       * @remarks
       *
       * `redirectChain` is shared between all the requests of the same chain.
       *
       * For example, if the website `http://example.com` has a single redirect to
       * `https://example.com`, then the chain will contain one request:
       *
       * ```ts
       * const response = await page.goto('http://example.com');
       * const chain = response.request().redirectChain();
       * console.log(chain.length); // 1
       * console.log(chain[0].url()); // 'http://example.com'
       * ```
       *
       * If the website `https://google.com` has no redirects, then the chain will be empty:
       *
       * ```ts
       * const response = await page.goto('https://google.com');
       * const chain = response.request().redirectChain();
       * console.log(chain.length); // 0
       * ```
       *
       * @returns the chain of requests - if a server responds with at least a
       * single redirect, this chain will contain all requests that were redirected.
       */
      redirectChain() {
        throw new Error("Not implemented");
      }
      /**
       * Access information about the request's failure.
       *
       * @remarks
       *
       * @example
       *
       * Example of logging all failed requests:
       *
       * ```ts
       * page.on('requestfailed', request => {
       *   console.log(request.url() + ' ' + request.failure().errorText);
       * });
       * ```
       *
       * @returns `null` unless the request failed. If the request fails this can
       * return an object with `errorText` containing a human-readable error
       * message, e.g. `net::ERR_FAILED`. It is not guaranteed that there will be
       * failure text if the request fails.
       */
      failure() {
        throw new Error("Not implemented");
      }
      async continue() {
        throw new Error("Not implemented");
      }
      async respond() {
        throw new Error("Not implemented");
      }
      async abort() {
        throw new Error("Not implemented");
      }
    };
    exports2.HTTPRequest = HTTPRequest;
    var InterceptResolutionAction;
    (function(InterceptResolutionAction2) {
      InterceptResolutionAction2["Abort"] = "abort";
      InterceptResolutionAction2["Respond"] = "respond";
      InterceptResolutionAction2["Continue"] = "continue";
      InterceptResolutionAction2["Disabled"] = "disabled";
      InterceptResolutionAction2["None"] = "none";
      InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
    })(InterceptResolutionAction = exports2.InterceptResolutionAction || (exports2.InterceptResolutionAction = {}));
    function headersArray(headers) {
      const result = [];
      for (const name in headers) {
        const value = headers[name];
        if (!Object.is(value, void 0)) {
          const values = Array.isArray(value) ? value : [value];
          result.push(...values.map((value2) => {
            return { name, value: value2 + "" };
          }));
        }
      }
      return result;
    }
    exports2.headersArray = headersArray;
    exports2.STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/api/api.js
var require_api = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/api/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Browser(), exports2);
    __exportStar(require_BrowserContext(), exports2);
    __exportStar(require_Page(), exports2);
    __exportStar(require_JSHandle(), exports2);
    __exportStar(require_ElementHandle(), exports2);
    __exportStar(require_HTTPResponse(), exports2);
    __exportStar(require_HTTPRequest(), exports2);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Accessibility.js
var require_Accessibility = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Accessibility.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Accessibility_client;
    var _AXNode_instances;
    var _AXNode_richlyEditable;
    var _AXNode_editable;
    var _AXNode_focusable;
    var _AXNode_hidden;
    var _AXNode_name;
    var _AXNode_role;
    var _AXNode_ignored;
    var _AXNode_cachedHasFocusableChild;
    var _AXNode_isPlainTextField;
    var _AXNode_isTextOnlyObject;
    var _AXNode_hasFocusableChild;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Accessibility = void 0;
    var Accessibility = class {
      /**
       * @internal
       */
      constructor(client) {
        _Accessibility_client.set(this, void 0);
        __classPrivateFieldSet(this, _Accessibility_client, client, "f");
      }
      /**
       * Captures the current state of the accessibility tree.
       * The returned object represents the root accessible node of the page.
       *
       * @remarks
       *
       * **NOTE** The Chrome accessibility tree contains nodes that go unused on
       * most platforms and by most screen readers. Puppeteer will discard them as
       * well for an easier to process tree, unless `interestingOnly` is set to
       * `false`.
       *
       * @example
       * An example of dumping the entire accessibility tree:
       *
       * ```ts
       * const snapshot = await page.accessibility.snapshot();
       * console.log(snapshot);
       * ```
       *
       * @example
       * An example of logging the focused node's name:
       *
       * ```ts
       * const snapshot = await page.accessibility.snapshot();
       * const node = findFocusedNode(snapshot);
       * console.log(node && node.name);
       *
       * function findFocusedNode(node) {
       *   if (node.focused) return node;
       *   for (const child of node.children || []) {
       *     const foundNode = findFocusedNode(child);
       *     return foundNode;
       *   }
       *   return null;
       * }
       * ```
       *
       * @returns An AXNode object representing the snapshot.
       */
      async snapshot(options = {}) {
        var _a, _b;
        const { interestingOnly = true, root = null } = options;
        const { nodes } = await __classPrivateFieldGet(this, _Accessibility_client, "f").send("Accessibility.getFullAXTree");
        let backendNodeId;
        if (root) {
          const { node } = await __classPrivateFieldGet(this, _Accessibility_client, "f").send("DOM.describeNode", {
            objectId: root.id
          });
          backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(nodes);
        let needle = defaultRoot;
        if (backendNodeId) {
          needle = defaultRoot.find((node) => {
            return node.payload.backendDOMNodeId === backendNodeId;
          });
          if (!needle) {
            return null;
          }
        }
        if (!interestingOnly) {
          return (_a = this.serializeTree(needle)[0]) !== null && _a !== void 0 ? _a : null;
        }
        const interestingNodes = /* @__PURE__ */ new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle)) {
          return null;
        }
        return (_b = this.serializeTree(needle, interestingNodes)[0]) !== null && _b !== void 0 ? _b : null;
      }
      serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children) {
          children.push(...this.serializeTree(child, interestingNodes));
        }
        if (interestingNodes && !interestingNodes.has(node)) {
          return children;
        }
        const serializedNode = node.serialize();
        if (children.length) {
          serializedNode.children = children;
        }
        return [serializedNode];
      }
      collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl)) {
          collection.add(node);
        }
        if (node.isLeafNode()) {
          return;
        }
        insideControl = insideControl || node.isControl();
        for (const child of node.children) {
          this.collectInterestingNodes(collection, child, insideControl);
        }
      }
    };
    exports2.Accessibility = Accessibility;
    _Accessibility_client = /* @__PURE__ */ new WeakMap();
    var AXNode = class {
      constructor(payload) {
        _AXNode_instances.add(this);
        this.children = [];
        _AXNode_richlyEditable.set(this, false);
        _AXNode_editable.set(this, false);
        _AXNode_focusable.set(this, false);
        _AXNode_hidden.set(this, false);
        _AXNode_name.set(this, void 0);
        _AXNode_role.set(this, void 0);
        _AXNode_ignored.set(this, void 0);
        _AXNode_cachedHasFocusableChild.set(this, void 0);
        this.payload = payload;
        __classPrivateFieldSet(this, _AXNode_name, this.payload.name ? this.payload.name.value : "", "f");
        __classPrivateFieldSet(this, _AXNode_role, this.payload.role ? this.payload.role.value : "Unknown", "f");
        __classPrivateFieldSet(this, _AXNode_ignored, this.payload.ignored, "f");
        for (const property of this.payload.properties || []) {
          if (property.name === "editable") {
            __classPrivateFieldSet(this, _AXNode_richlyEditable, property.value.value === "richtext", "f");
            __classPrivateFieldSet(this, _AXNode_editable, true, "f");
          }
          if (property.name === "focusable") {
            __classPrivateFieldSet(this, _AXNode_focusable, property.value.value, "f");
          }
          if (property.name === "hidden") {
            __classPrivateFieldSet(this, _AXNode_hidden, property.value.value, "f");
          }
        }
      }
      find(predicate) {
        if (predicate(this)) {
          return this;
        }
        for (const child of this.children) {
          const result = child.find(predicate);
          if (result) {
            return result;
          }
        }
        return null;
      }
      isLeafNode() {
        if (!this.children.length) {
          return true;
        }
        if (__classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_isPlainTextField).call(this) || __classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_isTextOnlyObject).call(this)) {
          return true;
        }
        switch (__classPrivateFieldGet(this, _AXNode_role, "f")) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (__classPrivateFieldGet(this, _AXNode_instances, "m", _AXNode_hasFocusableChild).call(this)) {
          return false;
        }
        if (__classPrivateFieldGet(this, _AXNode_focusable, "f") && __classPrivateFieldGet(this, _AXNode_name, "f")) {
          return true;
        }
        if (__classPrivateFieldGet(this, _AXNode_role, "f") === "heading" && __classPrivateFieldGet(this, _AXNode_name, "f")) {
          return true;
        }
        return false;
      }
      isControl() {
        switch (__classPrivateFieldGet(this, _AXNode_role, "f")) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
          case "treeitem":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = __classPrivateFieldGet(this, _AXNode_role, "f");
        if (role === "Ignored" || __classPrivateFieldGet(this, _AXNode_hidden, "f") || __classPrivateFieldGet(this, _AXNode_ignored, "f")) {
          return false;
        }
        if (__classPrivateFieldGet(this, _AXNode_focusable, "f") || __classPrivateFieldGet(this, _AXNode_richlyEditable, "f")) {
          return true;
        }
        if (this.isControl()) {
          return true;
        }
        if (insideControl) {
          return false;
        }
        return this.isLeafNode() && !!__classPrivateFieldGet(this, _AXNode_name, "f");
      }
      serialize() {
        const properties = /* @__PURE__ */ new Map();
        for (const property of this.payload.properties || []) {
          properties.set(property.name.toLowerCase(), property.value.value);
        }
        if (this.payload.name) {
          properties.set("name", this.payload.name.value);
        }
        if (this.payload.value) {
          properties.set("value", this.payload.value.value);
        }
        if (this.payload.description) {
          properties.set("description", this.payload.description.value);
        }
        const node = {
          role: __classPrivateFieldGet(this, _AXNode_role, "f")
        };
        const userStringProperties = [
          "name",
          "value",
          "description",
          "keyshortcuts",
          "roledescription",
          "valuetext"
        ];
        const getUserStringPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty)) {
            continue;
          }
          node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        const getBooleanPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && __classPrivateFieldGet(this, _AXNode_role, "f") === "RootWebArea") {
            continue;
          }
          const value = getBooleanPropertyValue(booleanProperty);
          if (!value) {
            continue;
          }
          node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ["checked", "pressed"];
        for (const tristateProperty of tristateProperties) {
          if (!properties.has(tristateProperty)) {
            continue;
          }
          const value = properties.get(tristateProperty);
          node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        const getNumericalPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty)) {
            continue;
          }
          node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        const getTokenPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const tokenProperty of tokenProperties) {
          const value = getTokenPropertyValue(tokenProperty);
          if (!value || value === "false") {
            continue;
          }
          node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
      }
      static createTree(payloads) {
        const nodeById = /* @__PURE__ */ new Map();
        for (const payload of payloads) {
          nodeById.set(payload.nodeId, new AXNode(payload));
        }
        for (const node of nodeById.values()) {
          for (const childId of node.payload.childIds || []) {
            const child = nodeById.get(childId);
            if (child) {
              node.children.push(child);
            }
          }
        }
        return nodeById.values().next().value;
      }
    };
    _AXNode_richlyEditable = /* @__PURE__ */ new WeakMap(), _AXNode_editable = /* @__PURE__ */ new WeakMap(), _AXNode_focusable = /* @__PURE__ */ new WeakMap(), _AXNode_hidden = /* @__PURE__ */ new WeakMap(), _AXNode_name = /* @__PURE__ */ new WeakMap(), _AXNode_role = /* @__PURE__ */ new WeakMap(), _AXNode_ignored = /* @__PURE__ */ new WeakMap(), _AXNode_cachedHasFocusableChild = /* @__PURE__ */ new WeakMap(), _AXNode_instances = /* @__PURE__ */ new WeakSet(), _AXNode_isPlainTextField = function _AXNode_isPlainTextField2() {
      if (__classPrivateFieldGet(this, _AXNode_richlyEditable, "f")) {
        return false;
      }
      if (__classPrivateFieldGet(this, _AXNode_editable, "f")) {
        return true;
      }
      return __classPrivateFieldGet(this, _AXNode_role, "f") === "textbox" || __classPrivateFieldGet(this, _AXNode_role, "f") === "searchbox";
    }, _AXNode_isTextOnlyObject = function _AXNode_isTextOnlyObject2() {
      const role = __classPrivateFieldGet(this, _AXNode_role, "f");
      return role === "LineBreak" || role === "text" || role === "InlineTextBox";
    }, _AXNode_hasFocusableChild = function _AXNode_hasFocusableChild2() {
      if (__classPrivateFieldGet(this, _AXNode_cachedHasFocusableChild, "f") === void 0) {
        __classPrivateFieldSet(this, _AXNode_cachedHasFocusableChild, false, "f");
        for (const child of this.children) {
          if (__classPrivateFieldGet(child, _AXNode_focusable, "f") || __classPrivateFieldGet(child, _AXNode_instances, "m", _AXNode_hasFocusableChild2).call(child)) {
            __classPrivateFieldSet(this, _AXNode_cachedHasFocusableChild, true, "f");
            break;
          }
        }
      }
      return __classPrivateFieldGet(this, _AXNode_cachedHasFocusableChild, "f");
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/DeferredPromise.js
var require_DeferredPromise = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/DeferredPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDeferredPromise = void 0;
    var Errors_js_1 = require_Errors();
    function createDeferredPromise(opts) {
      let isResolved = false;
      let isRejected = false;
      let resolver;
      let rejector;
      const taskPromise = new Promise((resolve, reject) => {
        resolver = resolve;
        rejector = reject;
      });
      const timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {
        isRejected = true;
        rejector(new Errors_js_1.TimeoutError(opts.message));
      }, opts.timeout) : void 0;
      return Object.assign(taskPromise, {
        resolved: () => {
          return isResolved;
        },
        finished: () => {
          return isResolved || isRejected;
        },
        resolve: (value) => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          isResolved = true;
          resolver(value);
        },
        reject: (err) => {
          clearTimeout(timeoutId);
          isRejected = true;
          rejector(err);
        }
      });
    }
    exports2.createDeferredPromise = createDeferredPromise;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/DebuggableDeferredPromise.js
var require_DebuggableDeferredPromise = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/DebuggableDeferredPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDebuggableDeferredPromise = void 0;
    var environment_js_1 = require_environment();
    var DeferredPromise_js_1 = require_DeferredPromise();
    function createDebuggableDeferredPromise(message) {
      if (environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT > 0) {
        return (0, DeferredPromise_js_1.createDeferredPromise)({
          message,
          timeout: environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT
        });
      }
      return (0, DeferredPromise_js_1.createDeferredPromise)();
    }
    exports2.createDebuggableDeferredPromise = createDebuggableDeferredPromise;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/util/util.js
var require_util3 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/util/util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_assert(), exports2);
    __exportStar(require_DebuggableDeferredPromise(), exports2);
    __exportStar(require_DeferredPromise(), exports2);
    __exportStar(require_ErrorLike(), exports2);
    __exportStar(require_AsyncIterableUtil(), exports2);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Connection.js
var require_Connection = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Connection.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Callback_id;
    var _Callback_error;
    var _Callback_promise;
    var _Callback_timer;
    var _Callback_label;
    var _CallbackRegistry_callbacks;
    var _CallbackRegistry_idGenerator;
    var _Connection_instances;
    var _Connection_url;
    var _Connection_transport;
    var _Connection_delay;
    var _Connection_timeout;
    var _Connection_sessions;
    var _Connection_closed;
    var _Connection_manuallyAttached;
    var _Connection_callbacks;
    var _Connection_onClose;
    var _CDPSessionImpl_sessionId;
    var _CDPSessionImpl_targetType;
    var _CDPSessionImpl_callbacks;
    var _CDPSessionImpl_connection;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTargetClosedError = exports2.CDPSessionImpl = exports2.CDPSession = exports2.CDPSessionEmittedEvents = exports2.Connection = exports2.CallbackRegistry = exports2.ConnectionEmittedEvents = void 0;
    var assert_js_1 = require_assert();
    var util_js_1 = require_util3();
    var Debug_js_1 = require_Debug();
    var Errors_js_1 = require_Errors();
    var EventEmitter_js_1 = require_EventEmitter();
    var debugProtocolSend = (0, Debug_js_1.debug)("puppeteer:protocol:SEND \u25BA");
    var debugProtocolReceive = (0, Debug_js_1.debug)("puppeteer:protocol:RECV \u25C0");
    exports2.ConnectionEmittedEvents = {
      Disconnected: Symbol("Connection.Disconnected")
    };
    function createIncrementalIdGenerator() {
      let id = 0;
      return () => {
        return ++id;
      };
    }
    var Callback = class {
      constructor(id, label, timeout) {
        _Callback_id.set(this, void 0);
        _Callback_error.set(this, new Errors_js_1.ProtocolError());
        _Callback_promise.set(this, (0, util_js_1.createDeferredPromise)());
        _Callback_timer.set(this, void 0);
        _Callback_label.set(this, void 0);
        __classPrivateFieldSet(this, _Callback_id, id, "f");
        __classPrivateFieldSet(this, _Callback_label, label, "f");
        if (timeout) {
          __classPrivateFieldSet(this, _Callback_timer, setTimeout(() => {
            __classPrivateFieldGet(this, _Callback_promise, "f").reject(rewriteError(__classPrivateFieldGet(this, _Callback_error, "f"), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
          }, timeout), "f");
        }
      }
      resolve(value) {
        clearTimeout(__classPrivateFieldGet(this, _Callback_timer, "f"));
        __classPrivateFieldGet(this, _Callback_promise, "f").resolve(value);
      }
      reject(error) {
        clearTimeout(__classPrivateFieldGet(this, _Callback_timer, "f"));
        __classPrivateFieldGet(this, _Callback_promise, "f").reject(error);
      }
      get id() {
        return __classPrivateFieldGet(this, _Callback_id, "f");
      }
      get promise() {
        return __classPrivateFieldGet(this, _Callback_promise, "f");
      }
      get error() {
        return __classPrivateFieldGet(this, _Callback_error, "f");
      }
      get label() {
        return __classPrivateFieldGet(this, _Callback_label, "f");
      }
    };
    _Callback_id = /* @__PURE__ */ new WeakMap(), _Callback_error = /* @__PURE__ */ new WeakMap(), _Callback_promise = /* @__PURE__ */ new WeakMap(), _Callback_timer = /* @__PURE__ */ new WeakMap(), _Callback_label = /* @__PURE__ */ new WeakMap();
    var CallbackRegistry = class {
      constructor() {
        _CallbackRegistry_callbacks.set(this, /* @__PURE__ */ new Map());
        _CallbackRegistry_idGenerator.set(this, createIncrementalIdGenerator());
      }
      create(label, timeout, request) {
        const callback = new Callback(__classPrivateFieldGet(this, _CallbackRegistry_idGenerator, "f").call(this), label, timeout);
        __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").set(callback.id, callback);
        try {
          request(callback.id);
        } catch (error) {
          callback.promise.catch(() => {
            __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").delete(callback.id);
          });
          callback.reject(error);
          throw error;
        }
        return callback.promise.finally(() => {
          __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").delete(callback.id);
        });
      }
      reject(id, message, originalMessage) {
        const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").get(id);
        if (!callback) {
          return;
        }
        this._reject(callback, message, originalMessage);
      }
      _reject(callback, message, originalMessage) {
        callback.reject(rewriteError(callback.error, `Protocol error (${callback.label}): ${message}`, originalMessage));
      }
      resolve(id, value) {
        const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").get(id);
        if (!callback) {
          return;
        }
        callback.resolve(value);
      }
      clear() {
        for (const callback of __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").values()) {
          this._reject(callback, "Target closed");
        }
        __classPrivateFieldGet(this, _CallbackRegistry_callbacks, "f").clear();
      }
    };
    exports2.CallbackRegistry = CallbackRegistry;
    _CallbackRegistry_callbacks = /* @__PURE__ */ new WeakMap(), _CallbackRegistry_idGenerator = /* @__PURE__ */ new WeakMap();
    var Connection = class extends EventEmitter_js_1.EventEmitter {
      constructor(url, transport, delay = 0, timeout) {
        super();
        _Connection_instances.add(this);
        _Connection_url.set(this, void 0);
        _Connection_transport.set(this, void 0);
        _Connection_delay.set(this, void 0);
        _Connection_timeout.set(this, void 0);
        _Connection_sessions.set(this, /* @__PURE__ */ new Map());
        _Connection_closed.set(this, false);
        _Connection_manuallyAttached.set(this, /* @__PURE__ */ new Set());
        _Connection_callbacks.set(this, new CallbackRegistry());
        __classPrivateFieldSet(this, _Connection_url, url, "f");
        __classPrivateFieldSet(this, _Connection_delay, delay, "f");
        __classPrivateFieldSet(this, _Connection_timeout, timeout !== null && timeout !== void 0 ? timeout : 18e4, "f");
        __classPrivateFieldSet(this, _Connection_transport, transport, "f");
        __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = this.onMessage.bind(this);
        __classPrivateFieldGet(this, _Connection_transport, "f").onclose = __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).bind(this);
      }
      static fromSession(session) {
        return session.connection();
      }
      get timeout() {
        return __classPrivateFieldGet(this, _Connection_timeout, "f");
      }
      /**
       * @internal
       */
      get _closed() {
        return __classPrivateFieldGet(this, _Connection_closed, "f");
      }
      /**
       * @internal
       */
      get _sessions() {
        return __classPrivateFieldGet(this, _Connection_sessions, "f");
      }
      /**
       * @param sessionId - The session id
       * @returns The current CDP session if it exists
       */
      session(sessionId) {
        return __classPrivateFieldGet(this, _Connection_sessions, "f").get(sessionId) || null;
      }
      url() {
        return __classPrivateFieldGet(this, _Connection_url, "f");
      }
      send(method, ...paramArgs) {
        const params = paramArgs.length ? paramArgs[0] : void 0;
        return this._rawSend(__classPrivateFieldGet(this, _Connection_callbacks, "f"), method, params);
      }
      /**
       * @internal
       */
      _rawSend(callbacks, method, params, sessionId) {
        return callbacks.create(method, __classPrivateFieldGet(this, _Connection_timeout, "f"), (id) => {
          const stringifiedMessage = JSON.stringify({
            method,
            params,
            id,
            sessionId
          });
          debugProtocolSend(stringifiedMessage);
          __classPrivateFieldGet(this, _Connection_transport, "f").send(stringifiedMessage);
        });
      }
      /**
       * @internal
       */
      async closeBrowser() {
        await this.send("Browser.close");
      }
      /**
       * @internal
       */
      async onMessage(message) {
        if (__classPrivateFieldGet(this, _Connection_delay, "f")) {
          await new Promise((f) => {
            return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, "f"));
          });
        }
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if (object.method === "Target.attachedToTarget") {
          const sessionId = object.params.sessionId;
          const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);
          __classPrivateFieldGet(this, _Connection_sessions, "f").set(sessionId, session);
          this.emit("sessionattached", session);
          const parentSession = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
          if (parentSession) {
            parentSession.emit("sessionattached", session);
          }
        } else if (object.method === "Target.detachedFromTarget") {
          const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.params.sessionId);
          if (session) {
            session._onClosed();
            __classPrivateFieldGet(this, _Connection_sessions, "f").delete(object.params.sessionId);
            this.emit("sessiondetached", session);
            const parentSession = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
            if (parentSession) {
              parentSession.emit("sessiondetached", session);
            }
          }
        }
        if (object.sessionId) {
          const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(object.sessionId);
          if (session) {
            session._onMessage(object);
          }
        } else if (object.id) {
          if (object.error) {
            __classPrivateFieldGet(this, _Connection_callbacks, "f").reject(object.id, createProtocolErrorMessage(object), object.error.message);
          } else {
            __classPrivateFieldGet(this, _Connection_callbacks, "f").resolve(object.id, object.result);
          }
        } else {
          this.emit(object.method, object.params);
        }
      }
      dispose() {
        __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).call(this);
        __classPrivateFieldGet(this, _Connection_transport, "f").close();
      }
      /**
       * @internal
       */
      isAutoAttached(targetId) {
        return !__classPrivateFieldGet(this, _Connection_manuallyAttached, "f").has(targetId);
      }
      /**
       * @internal
       */
      async _createSession(targetInfo, isAutoAttachEmulated = true) {
        if (!isAutoAttachEmulated) {
          __classPrivateFieldGet(this, _Connection_manuallyAttached, "f").add(targetInfo.targetId);
        }
        const { sessionId } = await this.send("Target.attachToTarget", {
          targetId: targetInfo.targetId,
          flatten: true
        });
        __classPrivateFieldGet(this, _Connection_manuallyAttached, "f").delete(targetInfo.targetId);
        const session = __classPrivateFieldGet(this, _Connection_sessions, "f").get(sessionId);
        if (!session) {
          throw new Error("CDPSession creation failed.");
        }
        return session;
      }
      /**
       * @param targetInfo - The target info
       * @returns The CDP session that is created
       */
      async createSession(targetInfo) {
        return await this._createSession(targetInfo, false);
      }
    };
    exports2.Connection = Connection;
    _Connection_url = /* @__PURE__ */ new WeakMap(), _Connection_transport = /* @__PURE__ */ new WeakMap(), _Connection_delay = /* @__PURE__ */ new WeakMap(), _Connection_timeout = /* @__PURE__ */ new WeakMap(), _Connection_sessions = /* @__PURE__ */ new WeakMap(), _Connection_closed = /* @__PURE__ */ new WeakMap(), _Connection_manuallyAttached = /* @__PURE__ */ new WeakMap(), _Connection_callbacks = /* @__PURE__ */ new WeakMap(), _Connection_instances = /* @__PURE__ */ new WeakSet(), _Connection_onClose = function _Connection_onClose2() {
      if (__classPrivateFieldGet(this, _Connection_closed, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _Connection_closed, true, "f");
      __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = void 0;
      __classPrivateFieldGet(this, _Connection_transport, "f").onclose = void 0;
      __classPrivateFieldGet(this, _Connection_callbacks, "f").clear();
      for (const session of __classPrivateFieldGet(this, _Connection_sessions, "f").values()) {
        session._onClosed();
      }
      __classPrivateFieldGet(this, _Connection_sessions, "f").clear();
      this.emit(exports2.ConnectionEmittedEvents.Disconnected);
    };
    exports2.CDPSessionEmittedEvents = {
      Disconnected: Symbol("CDPSession.Disconnected")
    };
    var CDPSession = class extends EventEmitter_js_1.EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      connection() {
        throw new Error("Not implemented");
      }
      send() {
        throw new Error("Not implemented");
      }
      /**
       * Detaches the cdpSession from the target. Once detached, the cdpSession object
       * won't emit any events and can't be used to send messages.
       */
      async detach() {
        throw new Error("Not implemented");
      }
      /**
       * Returns the session's id.
       */
      id() {
        throw new Error("Not implemented");
      }
    };
    exports2.CDPSession = CDPSession;
    var CDPSessionImpl = class extends CDPSession {
      /**
       * @internal
       */
      constructor(connection, targetType, sessionId) {
        super();
        _CDPSessionImpl_sessionId.set(this, void 0);
        _CDPSessionImpl_targetType.set(this, void 0);
        _CDPSessionImpl_callbacks.set(this, new CallbackRegistry());
        _CDPSessionImpl_connection.set(this, void 0);
        __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, "f");
        __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, "f");
        __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, "f");
      }
      connection() {
        return __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f");
      }
      send(method, ...paramArgs) {
        if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")) {
          return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, "f")} has been closed.`));
        }
        const params = paramArgs.length ? paramArgs[0] : void 0;
        return __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")._rawSend(__classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f"), method, params, __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f"));
      }
      /**
       * @internal
       */
      _onMessage(object) {
        if (object.id) {
          if (object.error) {
            __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").reject(object.id, createProtocolErrorMessage(object), object.error.message);
          } else {
            __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").resolve(object.id, object.result);
          }
        } else {
          (0, assert_js_1.assert)(!object.id);
          this.emit(object.method, object.params);
        }
      }
      /**
       * Detaches the cdpSession from the target. Once detached, the cdpSession object
       * won't emit any events and can't be used to send messages.
       */
      async detach() {
        if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, "f")) {
          throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, "f")} has been closed.`);
        }
        await __classPrivateFieldGet(this, _CDPSessionImpl_connection, "f").send("Target.detachFromTarget", {
          sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f")
        });
      }
      /**
       * @internal
       */
      _onClosed() {
        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, "f").clear();
        __classPrivateFieldSet(this, _CDPSessionImpl_connection, void 0, "f");
        this.emit(exports2.CDPSessionEmittedEvents.Disconnected);
      }
      /**
       * Returns the session's id.
       */
      id() {
        return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, "f");
      }
    };
    exports2.CDPSessionImpl = CDPSessionImpl;
    _CDPSessionImpl_sessionId = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_targetType = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_callbacks = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_connection = /* @__PURE__ */ new WeakMap();
    function createProtocolErrorMessage(object) {
      let message = `${object.error.message}`;
      if ("data" in object.error) {
        message += ` ${object.error.data}`;
      }
      return message;
    }
    function rewriteError(error, message, originalMessage) {
      error.message = message;
      error.originalMessage = originalMessage !== null && originalMessage !== void 0 ? originalMessage : error.originalMessage;
      return error;
    }
    function isTargetClosedError(err) {
      return err.message.includes("Target closed") || err.message.includes("Session closed");
    }
    exports2.isTargetClosedError = isTargetClosedError;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ChromeTargetManager.js
var require_ChromeTargetManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ChromeTargetManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ChromeTargetManager_instances;
    var _ChromeTargetManager_connection;
    var _ChromeTargetManager_discoveredTargetsByTargetId;
    var _ChromeTargetManager_attachedTargetsByTargetId;
    var _ChromeTargetManager_attachedTargetsBySessionId;
    var _ChromeTargetManager_ignoredTargets;
    var _ChromeTargetManager_targetFilterCallback;
    var _ChromeTargetManager_targetFactory;
    var _ChromeTargetManager_targetInterceptors;
    var _ChromeTargetManager_attachedToTargetListenersBySession;
    var _ChromeTargetManager_detachedFromTargetListenersBySession;
    var _ChromeTargetManager_initializePromise;
    var _ChromeTargetManager_targetsIdsForInit;
    var _ChromeTargetManager_storeExistingTargetsForInit;
    var _ChromeTargetManager_setupAttachmentListeners;
    var _ChromeTargetManager_removeAttachmentListeners;
    var _ChromeTargetManager_onSessionDetached;
    var _ChromeTargetManager_onTargetCreated;
    var _ChromeTargetManager_onTargetDestroyed;
    var _ChromeTargetManager_onTargetInfoChanged;
    var _ChromeTargetManager_onAttachedToTarget;
    var _ChromeTargetManager_finishInitializationIfReady;
    var _ChromeTargetManager_onDetachedFromTarget;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChromeTargetManager = void 0;
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var Connection_js_1 = require_Connection();
    var EventEmitter_js_1 = require_EventEmitter();
    var util_js_1 = require_util2();
    var ChromeTargetManager = class extends EventEmitter_js_1.EventEmitter {
      constructor(connection, targetFactory, targetFilterCallback) {
        super();
        _ChromeTargetManager_instances.add(this);
        _ChromeTargetManager_connection.set(this, void 0);
        _ChromeTargetManager_discoveredTargetsByTargetId.set(this, /* @__PURE__ */ new Map());
        _ChromeTargetManager_attachedTargetsByTargetId.set(this, /* @__PURE__ */ new Map());
        _ChromeTargetManager_attachedTargetsBySessionId.set(this, /* @__PURE__ */ new Map());
        _ChromeTargetManager_ignoredTargets.set(this, /* @__PURE__ */ new Set());
        _ChromeTargetManager_targetFilterCallback.set(this, void 0);
        _ChromeTargetManager_targetFactory.set(this, void 0);
        _ChromeTargetManager_targetInterceptors.set(this, /* @__PURE__ */ new WeakMap());
        _ChromeTargetManager_attachedToTargetListenersBySession.set(this, /* @__PURE__ */ new WeakMap());
        _ChromeTargetManager_detachedFromTargetListenersBySession.set(this, /* @__PURE__ */ new WeakMap());
        _ChromeTargetManager_initializePromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _ChromeTargetManager_targetsIdsForInit.set(this, /* @__PURE__ */ new Set());
        _ChromeTargetManager_storeExistingTargetsForInit.set(this, () => {
          for (const [targetId, targetInfo] of __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").entries()) {
            if ((!__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f") || __classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f").call(this, targetInfo)) && targetInfo.type !== "browser") {
              __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").add(targetId);
            }
          }
        });
        _ChromeTargetManager_onSessionDetached.set(this, (session) => {
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_removeAttachmentListeners).call(this, session);
          __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").delete(session);
        });
        _ChromeTargetManager_onTargetCreated.set(this, async (event) => {
          __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
          this.emit("targetDiscovered", event.targetInfo);
          if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
            if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetInfo.targetId)) {
              return;
            }
            const target = __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, event.targetInfo, void 0);
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(event.targetInfo.targetId, target);
          }
        });
        _ChromeTargetManager_onTargetDestroyed.set(this, (event) => {
          const targetInfo = __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").get(event.targetId);
          __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").delete(event.targetId);
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, event.targetId);
          if ((targetInfo === null || targetInfo === void 0 ? void 0 : targetInfo.type) === "service_worker" && __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetId)) {
            const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(event.targetId);
            this.emit("targetGone", target);
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").delete(event.targetId);
          }
        });
        _ChromeTargetManager_onTargetInfoChanged.set(this, (event) => {
          __classPrivateFieldGet(this, _ChromeTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
          if (__classPrivateFieldGet(this, _ChromeTargetManager_ignoredTargets, "f").has(event.targetInfo.targetId) || !__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(event.targetInfo.targetId) || !event.targetInfo.attached) {
            return;
          }
          const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(event.targetInfo.targetId);
          this.emit("targetChanged", {
            target,
            targetInfo: event.targetInfo
          });
        });
        _ChromeTargetManager_onAttachedToTarget.set(this, async (parentSession, event) => {
          const targetInfo = event.targetInfo;
          const session = __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").session(event.sessionId);
          if (!session) {
            throw new Error(`Session ${event.sessionId} was not created.`);
          }
          const silentDetach = async () => {
            await session.send("Runtime.runIfWaitingForDebugger").catch(util_js_1.debugError);
            await parentSession.send("Target.detachFromTarget", {
              sessionId: session.id()
            }).catch(util_js_1.debugError);
          };
          if (!__classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").isAutoAttached(targetInfo.targetId)) {
            return;
          }
          if (targetInfo.type === "service_worker" && __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").isAutoAttached(targetInfo.targetId)) {
            __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, targetInfo.targetId);
            await silentDetach();
            if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(targetInfo.targetId)) {
              return;
            }
            const target2 = __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, targetInfo);
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(targetInfo.targetId, target2);
            this.emit("targetAvailable", target2);
            return;
          }
          if (__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f") && !__classPrivateFieldGet(this, _ChromeTargetManager_targetFilterCallback, "f").call(this, targetInfo)) {
            __classPrivateFieldGet(this, _ChromeTargetManager_ignoredTargets, "f").add(targetInfo.targetId);
            __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this, targetInfo.targetId);
            await silentDetach();
            return;
          }
          const existingTarget = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").has(targetInfo.targetId);
          const target = existingTarget ? __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(targetInfo.targetId) : __classPrivateFieldGet(this, _ChromeTargetManager_targetFactory, "f").call(this, targetInfo, session);
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_setupAttachmentListeners).call(this, session);
          if (existingTarget) {
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").set(session.id(), __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").get(targetInfo.targetId));
          } else {
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").set(targetInfo.targetId, target);
            __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").set(session.id(), target);
          }
          for (const interceptor of __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(parentSession) || []) {
            if (!(parentSession instanceof Connection_js_1.Connection)) {
              (0, assert_js_1.assert)(__classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").has(parentSession.id()));
            }
            interceptor(target, parentSession instanceof Connection_js_1.Connection ? null : __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").get(parentSession.id()));
          }
          __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").delete(target._targetId);
          if (!existingTarget) {
            this.emit("targetAvailable", target);
          }
          __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this);
          await Promise.all([
            session.send("Target.setAutoAttach", {
              waitForDebuggerOnStart: true,
              flatten: true,
              autoAttach: true
            }),
            session.send("Runtime.runIfWaitingForDebugger")
          ]).catch(util_js_1.debugError);
        });
        _ChromeTargetManager_onDetachedFromTarget.set(this, (_parentSession, event) => {
          const target = __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").get(event.sessionId);
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsBySessionId, "f").delete(event.sessionId);
          if (!target) {
            return;
          }
          __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f").delete(target._targetId);
          this.emit("targetGone", target);
        });
        __classPrivateFieldSet(this, _ChromeTargetManager_connection, connection, "f");
        __classPrivateFieldSet(this, _ChromeTargetManager_targetFilterCallback, targetFilterCallback, "f");
        __classPrivateFieldSet(this, _ChromeTargetManager_targetFactory, targetFactory, "f");
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetCreated", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetCreated, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetDestroyed", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetDestroyed, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("Target.targetInfoChanged", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetInfoChanged, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").on("sessiondetached", __classPrivateFieldGet(this, _ChromeTargetManager_onSessionDetached, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_setupAttachmentListeners).call(this, __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").send("Target.setDiscoverTargets", {
          discover: true,
          filter: [{ type: "tab", exclude: true }, {}]
        }).then(__classPrivateFieldGet(this, _ChromeTargetManager_storeExistingTargetsForInit, "f")).catch(util_js_1.debugError);
      }
      async initialize() {
        await __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").send("Target.setAutoAttach", {
          waitForDebuggerOnStart: true,
          flatten: true,
          autoAttach: true
        });
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_finishInitializationIfReady).call(this);
        await __classPrivateFieldGet(this, _ChromeTargetManager_initializePromise, "f");
      }
      dispose() {
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetCreated", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetCreated, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetDestroyed", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetDestroyed, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("Target.targetInfoChanged", __classPrivateFieldGet(this, _ChromeTargetManager_onTargetInfoChanged, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f").off("sessiondetached", __classPrivateFieldGet(this, _ChromeTargetManager_onSessionDetached, "f"));
        __classPrivateFieldGet(this, _ChromeTargetManager_instances, "m", _ChromeTargetManager_removeAttachmentListeners).call(this, __classPrivateFieldGet(this, _ChromeTargetManager_connection, "f"));
      }
      getAvailableTargets() {
        return __classPrivateFieldGet(this, _ChromeTargetManager_attachedTargetsByTargetId, "f");
      }
      addTargetInterceptor(session, interceptor) {
        const interceptors = __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(session) || [];
        interceptors.push(interceptor);
        __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").set(session, interceptors);
      }
      removeTargetInterceptor(client, interceptor) {
        const interceptors = __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").get(client) || [];
        __classPrivateFieldGet(this, _ChromeTargetManager_targetInterceptors, "f").set(client, interceptors.filter((currentInterceptor) => {
          return currentInterceptor !== interceptor;
        }));
      }
    };
    exports2.ChromeTargetManager = ChromeTargetManager;
    _ChromeTargetManager_connection = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_discoveredTargetsByTargetId = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_attachedTargetsByTargetId = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_attachedTargetsBySessionId = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_ignoredTargets = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_targetFilterCallback = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_targetFactory = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_targetInterceptors = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_detachedFromTargetListenersBySession = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_initializePromise = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_targetsIdsForInit = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_storeExistingTargetsForInit = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onSessionDetached = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onTargetCreated = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onTargetDestroyed = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onTargetInfoChanged = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onAttachedToTarget = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_onDetachedFromTarget = /* @__PURE__ */ new WeakMap(), _ChromeTargetManager_instances = /* @__PURE__ */ new WeakSet(), _ChromeTargetManager_setupAttachmentListeners = function _ChromeTargetManager_setupAttachmentListeners2(session) {
      const listener = (event) => {
        return __classPrivateFieldGet(this, _ChromeTargetManager_onAttachedToTarget, "f").call(this, session, event);
      };
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").has(session));
      __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").set(session, listener);
      session.on("Target.attachedToTarget", listener);
      const detachedListener = (event) => {
        return __classPrivateFieldGet(this, _ChromeTargetManager_onDetachedFromTarget, "f").call(this, session, event);
      };
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").has(session));
      __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").set(session, detachedListener);
      session.on("Target.detachedFromTarget", detachedListener);
    }, _ChromeTargetManager_removeAttachmentListeners = function _ChromeTargetManager_removeAttachmentListeners2(session) {
      if (__classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").has(session)) {
        session.off("Target.attachedToTarget", __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").get(session));
        __classPrivateFieldGet(this, _ChromeTargetManager_attachedToTargetListenersBySession, "f").delete(session);
      }
      if (__classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").has(session)) {
        session.off("Target.detachedFromTarget", __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").get(session));
        __classPrivateFieldGet(this, _ChromeTargetManager_detachedFromTargetListenersBySession, "f").delete(session);
      }
    }, _ChromeTargetManager_finishInitializationIfReady = function _ChromeTargetManager_finishInitializationIfReady2(targetId) {
      targetId !== void 0 && __classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").delete(targetId);
      if (__classPrivateFieldGet(this, _ChromeTargetManager_targetsIdsForInit, "f").size === 0) {
        __classPrivateFieldGet(this, _ChromeTargetManager_initializePromise, "f").resolve();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FirefoxTargetManager.js
var require_FirefoxTargetManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/FirefoxTargetManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FirefoxTargetManager_instances;
    var _FirefoxTargetManager_connection;
    var _FirefoxTargetManager_discoveredTargetsByTargetId;
    var _FirefoxTargetManager_availableTargetsByTargetId;
    var _FirefoxTargetManager_availableTargetsBySessionId;
    var _FirefoxTargetManager_ignoredTargets;
    var _FirefoxTargetManager_targetFilterCallback;
    var _FirefoxTargetManager_targetFactory;
    var _FirefoxTargetManager_targetInterceptors;
    var _FirefoxTargetManager_attachedToTargetListenersBySession;
    var _FirefoxTargetManager_initializePromise;
    var _FirefoxTargetManager_targetsIdsForInit;
    var _FirefoxTargetManager_onSessionDetached;
    var _FirefoxTargetManager_onTargetCreated;
    var _FirefoxTargetManager_onTargetDestroyed;
    var _FirefoxTargetManager_onAttachedToTarget;
    var _FirefoxTargetManager_finishInitializationIfReady;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FirefoxTargetManager = void 0;
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var Connection_js_1 = require_Connection();
    var EventEmitter_js_1 = require_EventEmitter();
    var FirefoxTargetManager = class extends EventEmitter_js_1.EventEmitter {
      constructor(connection, targetFactory, targetFilterCallback) {
        super();
        _FirefoxTargetManager_instances.add(this);
        _FirefoxTargetManager_connection.set(this, void 0);
        _FirefoxTargetManager_discoveredTargetsByTargetId.set(this, /* @__PURE__ */ new Map());
        _FirefoxTargetManager_availableTargetsByTargetId.set(this, /* @__PURE__ */ new Map());
        _FirefoxTargetManager_availableTargetsBySessionId.set(this, /* @__PURE__ */ new Map());
        _FirefoxTargetManager_ignoredTargets.set(this, /* @__PURE__ */ new Set());
        _FirefoxTargetManager_targetFilterCallback.set(this, void 0);
        _FirefoxTargetManager_targetFactory.set(this, void 0);
        _FirefoxTargetManager_targetInterceptors.set(this, /* @__PURE__ */ new WeakMap());
        _FirefoxTargetManager_attachedToTargetListenersBySession.set(this, /* @__PURE__ */ new WeakMap());
        _FirefoxTargetManager_initializePromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _FirefoxTargetManager_targetsIdsForInit.set(this, /* @__PURE__ */ new Set());
        _FirefoxTargetManager_onSessionDetached.set(this, (session) => {
          this.removeSessionListeners(session);
          __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").delete(session);
          __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").delete(session.id());
        });
        _FirefoxTargetManager_onTargetCreated.set(this, async (event) => {
          if (__classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").has(event.targetInfo.targetId)) {
            return;
          }
          __classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").set(event.targetInfo.targetId, event.targetInfo);
          if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
            const target2 = __classPrivateFieldGet(this, _FirefoxTargetManager_targetFactory, "f").call(this, event.targetInfo, void 0);
            __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").set(event.targetInfo.targetId, target2);
            __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, target2._targetId);
            return;
          }
          if (__classPrivateFieldGet(this, _FirefoxTargetManager_targetFilterCallback, "f") && !__classPrivateFieldGet(this, _FirefoxTargetManager_targetFilterCallback, "f").call(this, event.targetInfo)) {
            __classPrivateFieldGet(this, _FirefoxTargetManager_ignoredTargets, "f").add(event.targetInfo.targetId);
            __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, event.targetInfo.targetId);
            return;
          }
          const target = __classPrivateFieldGet(this, _FirefoxTargetManager_targetFactory, "f").call(this, event.targetInfo, void 0);
          __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").set(event.targetInfo.targetId, target);
          this.emit("targetAvailable", target);
          __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, target._targetId);
        });
        _FirefoxTargetManager_onTargetDestroyed.set(this, (event) => {
          __classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").delete(event.targetId);
          __classPrivateFieldGet(this, _FirefoxTargetManager_instances, "m", _FirefoxTargetManager_finishInitializationIfReady).call(this, event.targetId);
          const target = __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(event.targetId);
          if (target) {
            this.emit("targetGone", target);
            __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").delete(event.targetId);
          }
        });
        _FirefoxTargetManager_onAttachedToTarget.set(this, async (parentSession, event) => {
          const targetInfo = event.targetInfo;
          const session = __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").session(event.sessionId);
          if (!session) {
            throw new Error(`Session ${event.sessionId} was not created.`);
          }
          const target = __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(targetInfo.targetId);
          (0, assert_js_1.assert)(target, `Target ${targetInfo.targetId} is missing`);
          this.setupAttachmentListeners(session);
          __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").set(session.id(), __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f").get(targetInfo.targetId));
          for (const hook of __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(parentSession) || []) {
            if (!(parentSession instanceof Connection_js_1.Connection)) {
              (0, assert_js_1.assert)(__classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").has(parentSession.id()));
            }
            await hook(target, parentSession instanceof Connection_js_1.Connection ? null : __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsBySessionId, "f").get(parentSession.id()));
          }
        });
        __classPrivateFieldSet(this, _FirefoxTargetManager_connection, connection, "f");
        __classPrivateFieldSet(this, _FirefoxTargetManager_targetFilterCallback, targetFilterCallback, "f");
        __classPrivateFieldSet(this, _FirefoxTargetManager_targetFactory, targetFactory, "f");
        __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("Target.targetCreated", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetCreated, "f"));
        __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("Target.targetDestroyed", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetDestroyed, "f"));
        __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").on("sessiondetached", __classPrivateFieldGet(this, _FirefoxTargetManager_onSessionDetached, "f"));
        this.setupAttachmentListeners(__classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f"));
      }
      addTargetInterceptor(client, interceptor) {
        const interceptors = __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(client) || [];
        interceptors.push(interceptor);
        __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").set(client, interceptors);
      }
      removeTargetInterceptor(client, interceptor) {
        const interceptors = __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").get(client) || [];
        __classPrivateFieldGet(this, _FirefoxTargetManager_targetInterceptors, "f").set(client, interceptors.filter((currentInterceptor) => {
          return currentInterceptor !== interceptor;
        }));
      }
      setupAttachmentListeners(session) {
        const listener = (event) => {
          return __classPrivateFieldGet(this, _FirefoxTargetManager_onAttachedToTarget, "f").call(this, session, event);
        };
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").has(session));
        __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").set(session, listener);
        session.on("Target.attachedToTarget", listener);
      }
      removeSessionListeners(session) {
        if (__classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").has(session)) {
          session.off("Target.attachedToTarget", __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").get(session));
          __classPrivateFieldGet(this, _FirefoxTargetManager_attachedToTargetListenersBySession, "f").delete(session);
        }
      }
      getAvailableTargets() {
        return __classPrivateFieldGet(this, _FirefoxTargetManager_availableTargetsByTargetId, "f");
      }
      dispose() {
        __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").off("Target.targetCreated", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetCreated, "f"));
        __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").off("Target.targetDestroyed", __classPrivateFieldGet(this, _FirefoxTargetManager_onTargetDestroyed, "f"));
      }
      async initialize() {
        await __classPrivateFieldGet(this, _FirefoxTargetManager_connection, "f").send("Target.setDiscoverTargets", {
          discover: true,
          filter: [{}]
        });
        __classPrivateFieldSet(this, _FirefoxTargetManager_targetsIdsForInit, new Set(__classPrivateFieldGet(this, _FirefoxTargetManager_discoveredTargetsByTargetId, "f").keys()), "f");
        await __classPrivateFieldGet(this, _FirefoxTargetManager_initializePromise, "f");
      }
    };
    exports2.FirefoxTargetManager = FirefoxTargetManager;
    _FirefoxTargetManager_connection = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_discoveredTargetsByTargetId = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_availableTargetsByTargetId = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_availableTargetsBySessionId = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_ignoredTargets = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_targetFilterCallback = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_targetFactory = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_targetInterceptors = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_initializePromise = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_targetsIdsForInit = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_onSessionDetached = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_onTargetCreated = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_onTargetDestroyed = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_onAttachedToTarget = /* @__PURE__ */ new WeakMap(), _FirefoxTargetManager_instances = /* @__PURE__ */ new WeakSet(), _FirefoxTargetManager_finishInitializationIfReady = function _FirefoxTargetManager_finishInitializationIfReady2(targetId) {
      __classPrivateFieldGet(this, _FirefoxTargetManager_targetsIdsForInit, "f").delete(targetId);
      if (__classPrivateFieldGet(this, _FirefoxTargetManager_targetsIdsForInit, "f").size === 0) {
        __classPrivateFieldGet(this, _FirefoxTargetManager_initializePromise, "f").resolve();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Binding.js
var require_Binding = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Binding.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Binding_name;
    var _Binding_fn;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Binding = void 0;
    var JSHandle_js_1 = require_JSHandle();
    var ErrorLike_js_1 = require_ErrorLike();
    var util_js_1 = require_util2();
    var Binding = class {
      constructor(name, fn) {
        _Binding_name.set(this, void 0);
        _Binding_fn.set(this, void 0);
        __classPrivateFieldSet(this, _Binding_name, name, "f");
        __classPrivateFieldSet(this, _Binding_fn, fn, "f");
      }
      get name() {
        return __classPrivateFieldGet(this, _Binding_name, "f");
      }
      /**
       * @param context - Context to run the binding in; the context should have
       * the binding added to it beforehand.
       * @param id - ID of the call. This should come from the CDP
       * `onBindingCalled` response.
       * @param args - Plain arguments from CDP.
       */
      async run(context, id, args, isTrivial) {
        const garbage = [];
        try {
          if (!isTrivial) {
            const handles = await context.evaluateHandle((name, seq) => {
              return globalThis[name].args.get(seq);
            }, __classPrivateFieldGet(this, _Binding_name, "f"), id);
            try {
              const properties = await handles.getProperties();
              for (const [index, handle] of properties) {
                if (index in args) {
                  switch (handle.remoteObject().subtype) {
                    case "node":
                      args[+index] = handle;
                      break;
                    default:
                      garbage.push(handle.dispose());
                  }
                } else {
                  garbage.push(handle.dispose());
                }
              }
            } finally {
              await handles.dispose();
            }
          }
          await context.evaluate((name, seq, result) => {
            const callbacks = globalThis[name].callbacks;
            callbacks.get(seq).resolve(result);
            callbacks.delete(seq);
          }, __classPrivateFieldGet(this, _Binding_name, "f"), id, await __classPrivateFieldGet(this, _Binding_fn, "f").call(this, ...args));
          for (const arg of args) {
            if (arg instanceof JSHandle_js_1.JSHandle) {
              garbage.push(arg.dispose());
            }
          }
        } catch (error) {
          if ((0, ErrorLike_js_1.isErrorLike)(error)) {
            await context.evaluate((name, seq, message, stack) => {
              const error2 = new Error(message);
              error2.stack = stack;
              const callbacks = globalThis[name].callbacks;
              callbacks.get(seq).reject(error2);
              callbacks.delete(seq);
            }, __classPrivateFieldGet(this, _Binding_name, "f"), id, error.message, error.stack).catch(util_js_1.debugError);
          } else {
            await context.evaluate((name, seq, error2) => {
              const callbacks = globalThis[name].callbacks;
              callbacks.get(seq).reject(error2);
              callbacks.delete(seq);
            }, __classPrivateFieldGet(this, _Binding_name, "f"), id, error).catch(util_js_1.debugError);
          }
        } finally {
          await Promise.all(garbage);
        }
      }
    };
    exports2.Binding = Binding;
    _Binding_name = /* @__PURE__ */ new WeakMap(), _Binding_fn = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ConsoleMessage.js
var require_ConsoleMessage = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ConsoleMessage.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ConsoleMessage_type;
    var _ConsoleMessage_text;
    var _ConsoleMessage_args;
    var _ConsoleMessage_stackTraceLocations;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleMessage = void 0;
    var ConsoleMessage = class {
      /**
       * @public
       */
      constructor(type, text, args, stackTraceLocations) {
        _ConsoleMessage_type.set(this, void 0);
        _ConsoleMessage_text.set(this, void 0);
        _ConsoleMessage_args.set(this, void 0);
        _ConsoleMessage_stackTraceLocations.set(this, void 0);
        __classPrivateFieldSet(this, _ConsoleMessage_type, type, "f");
        __classPrivateFieldSet(this, _ConsoleMessage_text, text, "f");
        __classPrivateFieldSet(this, _ConsoleMessage_args, args, "f");
        __classPrivateFieldSet(this, _ConsoleMessage_stackTraceLocations, stackTraceLocations, "f");
      }
      /**
       * The type of the console message.
       */
      type() {
        return __classPrivateFieldGet(this, _ConsoleMessage_type, "f");
      }
      /**
       * The text of the console message.
       */
      text() {
        return __classPrivateFieldGet(this, _ConsoleMessage_text, "f");
      }
      /**
       * An array of arguments passed to the console.
       */
      args() {
        return __classPrivateFieldGet(this, _ConsoleMessage_args, "f");
      }
      /**
       * The location of the console message.
       */
      location() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _ConsoleMessage_stackTraceLocations, "f")[0]) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * The array of locations on the stack of the console message.
       */
      stackTrace() {
        return __classPrivateFieldGet(this, _ConsoleMessage_stackTraceLocations, "f");
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
    _ConsoleMessage_type = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_text = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_args = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_stackTraceLocations = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ExecutionContext.js
var require_ExecutionContext = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ExecutionContext.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _ExecutionContext_instances;
    var _ExecutionContext_bindingsInstalled;
    var _ExecutionContext_puppeteerUtil;
    var _ExecutionContext_installGlobalBinding;
    var _ExecutionContext_evaluate;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExecutionContext = exports2.EVALUATION_SCRIPT_URL = void 0;
    var AsyncIterableUtil_js_1 = require_AsyncIterableUtil();
    var Function_js_1 = require_Function();
    var AriaQueryHandler_js_1 = require_AriaQueryHandler();
    var Binding_js_1 = require_Binding();
    var ElementHandle_js_1 = require_ElementHandle2();
    var JSHandle_js_1 = require_JSHandle2();
    var LazyArg_js_1 = require_LazyArg();
    var ScriptInjector_js_1 = require_ScriptInjector();
    var util_js_1 = require_util2();
    exports2.EVALUATION_SCRIPT_URL = "pptr://__puppeteer_evaluation_script__";
    var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
    var ExecutionContext = class {
      constructor(client, contextPayload, world) {
        _ExecutionContext_instances.add(this);
        _ExecutionContext_bindingsInstalled.set(this, false);
        _ExecutionContext_puppeteerUtil.set(this, void 0);
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
        if (contextPayload.name) {
          this._contextName = contextPayload.name;
        }
      }
      get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!__classPrivateFieldGet(this, _ExecutionContext_bindingsInstalled, "f")) {
          promise = Promise.all([
            __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_installGlobalBinding).call(this, new Binding_js_1.Binding("__ariaQuerySelector", AriaQueryHandler_js_1.ARIAQueryHandler.queryOne)),
            __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_installGlobalBinding).call(this, new Binding_js_1.Binding("__ariaQuerySelectorAll", async (element, selector) => {
              const results = AriaQueryHandler_js_1.ARIAQueryHandler.queryAll(element, selector);
              return element.executionContext().evaluateHandle((...elements) => {
                return elements;
              }, ...await AsyncIterableUtil_js_1.AsyncIterableUtil.collect(results));
            }))
          ]);
          __classPrivateFieldSet(this, _ExecutionContext_bindingsInstalled, true, "f");
        }
        ScriptInjector_js_1.scriptInjector.inject((script) => {
          if (__classPrivateFieldGet(this, _ExecutionContext_puppeteerUtil, "f")) {
            void __classPrivateFieldGet(this, _ExecutionContext_puppeteerUtil, "f").then((handle) => {
              void handle.dispose();
            });
          }
          __classPrivateFieldSet(this, _ExecutionContext_puppeteerUtil, promise.then(() => {
            return this.evaluateHandle(script);
          }), "f");
        }, !__classPrivateFieldGet(this, _ExecutionContext_puppeteerUtil, "f"));
        return __classPrivateFieldGet(this, _ExecutionContext_puppeteerUtil, "f");
      }
      /**
       * Evaluates the given function.
       *
       * @example
       *
       * ```ts
       * const executionContext = await page.mainFrame().executionContext();
       * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
       * console.log(result); // prints "56"
       * ```
       *
       * @example
       * A string can also be passed in instead of a function:
       *
       * ```ts
       * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
       * ```
       *
       * @example
       * Handles can also be passed as `args`. They resolve to their referenced object:
       *
       * ```ts
       * const oneHandle = await executionContext.evaluateHandle(() => 1);
       * const twoHandle = await executionContext.evaluateHandle(() => 2);
       * const result = await executionContext.evaluate(
       *   (a, b) => a + b,
       *   oneHandle,
       *   twoHandle
       * );
       * await oneHandle.dispose();
       * await twoHandle.dispose();
       * console.log(result); // prints '3'.
       * ```
       *
       * @param pageFunction - The function to evaluate.
       * @param args - Additional arguments to pass into the function.
       * @returns The result of evaluating the function. If the result is an object,
       * a vanilla object containing the serializable properties of the result is
       * returned.
       */
      async evaluate(pageFunction, ...args) {
        return await __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, true, pageFunction, ...args);
      }
      /**
       * Evaluates the given function.
       *
       * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
       * handle to the result of the function.
       *
       * This method may be better suited if the object cannot be serialized (e.g.
       * `Map`) and requires further manipulation.
       *
       * @example
       *
       * ```ts
       * const context = await page.mainFrame().executionContext();
       * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
       *   () => Promise.resolve(self)
       * );
       * ```
       *
       * @example
       * A string can also be passed in instead of a function.
       *
       * ```ts
       * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
       * ```
       *
       * @example
       * Handles can also be passed as `args`. They resolve to their referenced object:
       *
       * ```ts
       * const bodyHandle: ElementHandle<HTMLBodyElement> =
       *   await context.evaluateHandle(() => {
       *     return document.body;
       *   });
       * const stringHandle: JSHandle<string> = await context.evaluateHandle(
       *   body => body.innerHTML,
       *   body
       * );
       * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
       * // Always dispose your garbage! :)
       * await bodyHandle.dispose();
       * await stringHandle.dispose();
       * ```
       *
       * @param pageFunction - The function to evaluate.
       * @param args - Additional arguments to pass into the function.
       * @returns A {@link JSHandle | handle} to the result of evaluating the
       * function. If the result is a `Node`, then this will return an
       * {@link ElementHandle | element handle}.
       */
      async evaluateHandle(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, false, pageFunction, ...args);
      }
    };
    exports2.ExecutionContext = ExecutionContext;
    _ExecutionContext_bindingsInstalled = /* @__PURE__ */ new WeakMap(), _ExecutionContext_puppeteerUtil = /* @__PURE__ */ new WeakMap(), _ExecutionContext_instances = /* @__PURE__ */ new WeakSet(), _ExecutionContext_installGlobalBinding = async function _ExecutionContext_installGlobalBinding2(binding) {
      try {
        if (this._world) {
          this._world._bindings.set(binding.name, binding);
          await this._world._addBindingToContext(this, binding.name);
        }
      } catch {
      }
    }, _ExecutionContext_evaluate = async function _ExecutionContext_evaluate2(returnByValue, pageFunction, ...args) {
      const suffix = `//# sourceURL=${exports2.EVALUATION_SCRIPT_URL}`;
      if ((0, util_js_1.isString)(pageFunction)) {
        const contextId = this._contextId;
        const expression = pageFunction;
        const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + "\n" + suffix;
        const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
          expression: expressionWithSourceUrl,
          contextId,
          returnByValue,
          awaitPromise: true,
          userGesture: true
        }).catch(rewriteError);
        if (exceptionDetails2) {
          throw new Error("Evaluation failed: " + (0, util_js_1.getExceptionMessage)(exceptionDetails2));
        }
        return returnByValue ? (0, util_js_1.valueFromRemoteObject)(remoteObject2) : (0, util_js_1.createJSHandle)(this, remoteObject2);
      }
      let callFunctionOnPromise;
      try {
        callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: `${(0, Function_js_1.stringifyFunction)(pageFunction)}
${suffix}
`,
          executionContextId: this._contextId,
          arguments: await Promise.all(args.map(convertArgument.bind(this))),
          returnByValue,
          awaitPromise: true,
          userGesture: true
        });
      } catch (error) {
        if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
          error.message += " Recursive objects are not allowed.";
        }
        throw error;
      }
      const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
      if (exceptionDetails) {
        throw new Error("Evaluation failed: " + (0, util_js_1.getExceptionMessage)(exceptionDetails));
      }
      return returnByValue ? (0, util_js_1.valueFromRemoteObject)(remoteObject) : (0, util_js_1.createJSHandle)(this, remoteObject);
      async function convertArgument(arg) {
        if (arg instanceof LazyArg_js_1.LazyArg) {
          arg = await arg.get(this);
        }
        if (typeof arg === "bigint") {
          return { unserializableValue: `${arg.toString()}n` };
        }
        if (Object.is(arg, -0)) {
          return { unserializableValue: "-0" };
        }
        if (Object.is(arg, Infinity)) {
          return { unserializableValue: "Infinity" };
        }
        if (Object.is(arg, -Infinity)) {
          return { unserializableValue: "-Infinity" };
        }
        if (Object.is(arg, NaN)) {
          return { unserializableValue: "NaN" };
        }
        const objectHandle = arg && (arg instanceof JSHandle_js_1.CDPJSHandle || arg instanceof ElementHandle_js_1.CDPElementHandle) ? arg : null;
        if (objectHandle) {
          if (objectHandle.executionContext() !== this) {
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          }
          if (objectHandle.disposed) {
            throw new Error("JSHandle is disposed!");
          }
          if (objectHandle.remoteObject().unserializableValue) {
            return {
              unserializableValue: objectHandle.remoteObject().unserializableValue
            };
          }
          if (!objectHandle.remoteObject().objectId) {
            return { value: objectHandle.remoteObject().value };
          }
          return { objectId: objectHandle.remoteObject().objectId };
        }
        return { value: arg };
      }
    };
    var rewriteError = (error) => {
      if (error.message.includes("Object reference chain is too long")) {
        return { result: { type: "undefined" } };
      }
      if (error.message.includes("Object couldn't be returned by value")) {
        return { result: { type: "undefined" } };
      }
      if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      }
      throw error;
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Coverage.js
var require_Coverage = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Coverage.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Coverage_jsCoverage;
    var _Coverage_cssCoverage;
    var _JSCoverage_instances;
    var _JSCoverage_client;
    var _JSCoverage_enabled;
    var _JSCoverage_scriptURLs;
    var _JSCoverage_scriptSources;
    var _JSCoverage_eventListeners;
    var _JSCoverage_resetOnNavigation;
    var _JSCoverage_reportAnonymousScripts;
    var _JSCoverage_includeRawScriptCoverage;
    var _JSCoverage_onExecutionContextsCleared;
    var _JSCoverage_onScriptParsed;
    var _CSSCoverage_instances;
    var _CSSCoverage_client;
    var _CSSCoverage_enabled;
    var _CSSCoverage_stylesheetURLs;
    var _CSSCoverage_stylesheetSources;
    var _CSSCoverage_eventListeners;
    var _CSSCoverage_resetOnNavigation;
    var _CSSCoverage_onExecutionContextsCleared;
    var _CSSCoverage_onStyleSheet;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CSSCoverage = exports2.JSCoverage = exports2.Coverage = void 0;
    var assert_js_1 = require_assert();
    var ExecutionContext_js_1 = require_ExecutionContext();
    var util_js_1 = require_util2();
    var util_js_2 = require_util2();
    var Coverage = class {
      constructor(client) {
        _Coverage_jsCoverage.set(this, void 0);
        _Coverage_cssCoverage.set(this, void 0);
        __classPrivateFieldSet(this, _Coverage_jsCoverage, new JSCoverage(client), "f");
        __classPrivateFieldSet(this, _Coverage_cssCoverage, new CSSCoverage(client), "f");
      }
      /**
       * @param options - Set of configurable options for coverage defaults to
       * `resetOnNavigation : true, reportAnonymousScripts : false,`
       * `includeRawScriptCoverage : false, useBlockCoverage : true`
       * @returns Promise that resolves when coverage is started.
       *
       * @remarks
       * Anonymous scripts are ones that don't have an associated url. These are
       * scripts that are dynamically created on the page using `eval` or
       * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
       * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
       * comment is present, in which case that will the be URL).
       */
      async startJSCoverage(options = {}) {
        return await __classPrivateFieldGet(this, _Coverage_jsCoverage, "f").start(options);
      }
      /**
       * Promise that resolves to the array of coverage reports for
       * all scripts.
       *
       * @remarks
       * JavaScript Coverage doesn't include anonymous scripts by default.
       * However, scripts with sourceURLs are reported.
       */
      async stopJSCoverage() {
        return await __classPrivateFieldGet(this, _Coverage_jsCoverage, "f").stop();
      }
      /**
       * @param options - Set of configurable options for coverage, defaults to
       * `resetOnNavigation : true`
       * @returns Promise that resolves when coverage is started.
       */
      async startCSSCoverage(options = {}) {
        return await __classPrivateFieldGet(this, _Coverage_cssCoverage, "f").start(options);
      }
      /**
       * Promise that resolves to the array of coverage reports
       * for all stylesheets.
       *
       * @remarks
       * CSS Coverage doesn't include dynamically injected style tags
       * without sourceURLs.
       */
      async stopCSSCoverage() {
        return await __classPrivateFieldGet(this, _Coverage_cssCoverage, "f").stop();
      }
    };
    exports2.Coverage = Coverage;
    _Coverage_jsCoverage = /* @__PURE__ */ new WeakMap(), _Coverage_cssCoverage = /* @__PURE__ */ new WeakMap();
    var JSCoverage = class {
      constructor(client) {
        _JSCoverage_instances.add(this);
        _JSCoverage_client.set(this, void 0);
        _JSCoverage_enabled.set(this, false);
        _JSCoverage_scriptURLs.set(this, /* @__PURE__ */ new Map());
        _JSCoverage_scriptSources.set(this, /* @__PURE__ */ new Map());
        _JSCoverage_eventListeners.set(this, []);
        _JSCoverage_resetOnNavigation.set(this, false);
        _JSCoverage_reportAnonymousScripts.set(this, false);
        _JSCoverage_includeRawScriptCoverage.set(this, false);
        __classPrivateFieldSet(this, _JSCoverage_client, client, "f");
      }
      async start(options = {}) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _JSCoverage_enabled, "f"), "JSCoverage is already enabled");
        const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
        __classPrivateFieldSet(this, _JSCoverage_resetOnNavigation, resetOnNavigation, "f");
        __classPrivateFieldSet(this, _JSCoverage_reportAnonymousScripts, reportAnonymousScripts, "f");
        __classPrivateFieldSet(this, _JSCoverage_includeRawScriptCoverage, includeRawScriptCoverage, "f");
        __classPrivateFieldSet(this, _JSCoverage_enabled, true, "f");
        __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").clear();
        __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").clear();
        __classPrivateFieldSet(this, _JSCoverage_eventListeners, [
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _JSCoverage_client, "f"), "Debugger.scriptParsed", __classPrivateFieldGet(this, _JSCoverage_instances, "m", _JSCoverage_onScriptParsed).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _JSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet(this, _JSCoverage_instances, "m", _JSCoverage_onExecutionContextsCleared).bind(this))
        ], "f");
        await Promise.all([
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.enable"),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.startPreciseCoverage", {
            callCount: __classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, "f"),
            detailed: useBlockCoverage
          }),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.enable"),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.setSkipAllPauses", { skip: true })
        ]);
      }
      async stop() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _JSCoverage_enabled, "f"), "JSCoverage is not enabled");
        __classPrivateFieldSet(this, _JSCoverage_enabled, false, "f");
        const result = await Promise.all([
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.takePreciseCoverage"),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.stopPreciseCoverage"),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Profiler.disable"),
          __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.disable")
        ]);
        (0, util_js_2.removeEventListeners)(__classPrivateFieldGet(this, _JSCoverage_eventListeners, "f"));
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
          let url = __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").get(entry.scriptId);
          if (!url && __classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, "f")) {
            url = "debugger://VM" + entry.scriptId;
          }
          const text = __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").get(entry.scriptId);
          if (text === void 0 || url === void 0) {
            continue;
          }
          const flattenRanges = [];
          for (const func of entry.functions) {
            flattenRanges.push(...func.ranges);
          }
          const ranges = convertToDisjointRanges(flattenRanges);
          if (!__classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, "f")) {
            coverage.push({ url, ranges, text });
          } else {
            coverage.push({ url, ranges, text, rawScriptCoverage: entry });
          }
        }
        return coverage;
      }
    };
    exports2.JSCoverage = JSCoverage;
    _JSCoverage_client = /* @__PURE__ */ new WeakMap(), _JSCoverage_enabled = /* @__PURE__ */ new WeakMap(), _JSCoverage_scriptURLs = /* @__PURE__ */ new WeakMap(), _JSCoverage_scriptSources = /* @__PURE__ */ new WeakMap(), _JSCoverage_eventListeners = /* @__PURE__ */ new WeakMap(), _JSCoverage_resetOnNavigation = /* @__PURE__ */ new WeakMap(), _JSCoverage_reportAnonymousScripts = /* @__PURE__ */ new WeakMap(), _JSCoverage_includeRawScriptCoverage = /* @__PURE__ */ new WeakMap(), _JSCoverage_instances = /* @__PURE__ */ new WeakSet(), _JSCoverage_onExecutionContextsCleared = function _JSCoverage_onExecutionContextsCleared2() {
      if (!__classPrivateFieldGet(this, _JSCoverage_resetOnNavigation, "f")) {
        return;
      }
      __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").clear();
      __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").clear();
    }, _JSCoverage_onScriptParsed = async function _JSCoverage_onScriptParsed2(event) {
      if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL) {
        return;
      }
      if (!event.url && !__classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, "f")) {
        return;
      }
      try {
        const response = await __classPrivateFieldGet(this, _JSCoverage_client, "f").send("Debugger.getScriptSource", {
          scriptId: event.scriptId
        });
        __classPrivateFieldGet(this, _JSCoverage_scriptURLs, "f").set(event.scriptId, event.url);
        __classPrivateFieldGet(this, _JSCoverage_scriptSources, "f").set(event.scriptId, response.scriptSource);
      } catch (error) {
        (0, util_js_1.debugError)(error);
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        _CSSCoverage_instances.add(this);
        _CSSCoverage_client.set(this, void 0);
        _CSSCoverage_enabled.set(this, false);
        _CSSCoverage_stylesheetURLs.set(this, /* @__PURE__ */ new Map());
        _CSSCoverage_stylesheetSources.set(this, /* @__PURE__ */ new Map());
        _CSSCoverage_eventListeners.set(this, []);
        _CSSCoverage_resetOnNavigation.set(this, false);
        __classPrivateFieldSet(this, _CSSCoverage_client, client, "f");
      }
      async start(options = {}) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _CSSCoverage_enabled, "f"), "CSSCoverage is already enabled");
        const { resetOnNavigation = true } = options;
        __classPrivateFieldSet(this, _CSSCoverage_resetOnNavigation, resetOnNavigation, "f");
        __classPrivateFieldSet(this, _CSSCoverage_enabled, true, "f");
        __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").clear();
        __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").clear();
        __classPrivateFieldSet(this, _CSSCoverage_eventListeners, [
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _CSSCoverage_client, "f"), "CSS.styleSheetAdded", __classPrivateFieldGet(this, _CSSCoverage_instances, "m", _CSSCoverage_onStyleSheet).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _CSSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet(this, _CSSCoverage_instances, "m", _CSSCoverage_onExecutionContextsCleared).bind(this))
        ], "f");
        await Promise.all([
          __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("DOM.enable"),
          __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.enable"),
          __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.startRuleUsageTracking")
        ]);
      }
      async stop() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CSSCoverage_enabled, "f"), "CSSCoverage is not enabled");
        __classPrivateFieldSet(this, _CSSCoverage_enabled, false, "f");
        const ruleTrackingResponse = await __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.stopRuleUsageTracking");
        await Promise.all([
          __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.disable"),
          __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("DOM.disable")
        ]);
        (0, util_js_2.removeEventListeners)(__classPrivateFieldGet(this, _CSSCoverage_eventListeners, "f"));
        const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
          let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
          if (!ranges) {
            ranges = [];
            styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
          }
          ranges.push({
            startOffset: entry.startOffset,
            endOffset: entry.endOffset,
            count: entry.used ? 1 : 0
          });
        }
        const coverage = [];
        for (const styleSheetId of __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").keys()) {
          const url = __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").get(styleSheetId);
          (0, assert_js_1.assert)(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
          const text = __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").get(styleSheetId);
          (0, assert_js_1.assert)(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
          const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
          coverage.push({ url, ranges, text });
        }
        return coverage;
      }
    };
    exports2.CSSCoverage = CSSCoverage;
    _CSSCoverage_client = /* @__PURE__ */ new WeakMap(), _CSSCoverage_enabled = /* @__PURE__ */ new WeakMap(), _CSSCoverage_stylesheetURLs = /* @__PURE__ */ new WeakMap(), _CSSCoverage_stylesheetSources = /* @__PURE__ */ new WeakMap(), _CSSCoverage_eventListeners = /* @__PURE__ */ new WeakMap(), _CSSCoverage_resetOnNavigation = /* @__PURE__ */ new WeakMap(), _CSSCoverage_instances = /* @__PURE__ */ new WeakSet(), _CSSCoverage_onExecutionContextsCleared = function _CSSCoverage_onExecutionContextsCleared2() {
      if (!__classPrivateFieldGet(this, _CSSCoverage_resetOnNavigation, "f")) {
        return;
      }
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").clear();
      __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").clear();
    }, _CSSCoverage_onStyleSheet = async function _CSSCoverage_onStyleSheet2(event) {
      const header = event.header;
      if (!header.sourceURL) {
        return;
      }
      try {
        const response = await __classPrivateFieldGet(this, _CSSCoverage_client, "f").send("CSS.getStyleSheetText", {
          styleSheetId: header.styleSheetId
        });
        __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, "f").set(header.styleSheetId, header.sourceURL);
        __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, "f").set(header.styleSheetId, response.text);
      } catch (error) {
        (0, util_js_1.debugError)(error);
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset) {
          return a.offset - b.offset;
        }
        if (a.type !== b.type) {
          return b.type - a.type;
        }
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0) {
          return bLength - aLength;
        }
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results[results.length - 1];
          if (lastResult && lastResult.end === lastOffset) {
            lastResult.end = point.offset;
          } else {
            results.push({ start: lastOffset, end: point.offset });
          }
        }
        lastOffset = point.offset;
        if (point.type === 0) {
          hitCountStack.push(point.range.count);
        } else {
          hitCountStack.pop();
        }
      }
      return results.filter((range) => {
        return range.end - range.start > 0;
      });
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Dialog.js
var require_Dialog = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Dialog.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Dialog_client;
    var _Dialog_type;
    var _Dialog_message;
    var _Dialog_defaultValue;
    var _Dialog_handled;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dialog = void 0;
    var assert_js_1 = require_assert();
    var Dialog = class {
      /**
       * @internal
       */
      constructor(client, type, message, defaultValue = "") {
        _Dialog_client.set(this, void 0);
        _Dialog_type.set(this, void 0);
        _Dialog_message.set(this, void 0);
        _Dialog_defaultValue.set(this, void 0);
        _Dialog_handled.set(this, false);
        __classPrivateFieldSet(this, _Dialog_client, client, "f");
        __classPrivateFieldSet(this, _Dialog_type, type, "f");
        __classPrivateFieldSet(this, _Dialog_message, message, "f");
        __classPrivateFieldSet(this, _Dialog_defaultValue, defaultValue, "f");
      }
      /**
       * The type of the dialog.
       */
      type() {
        return __classPrivateFieldGet(this, _Dialog_type, "f");
      }
      /**
       * The message displayed in the dialog.
       */
      message() {
        return __classPrivateFieldGet(this, _Dialog_message, "f");
      }
      /**
       * The default value of the prompt, or an empty string if the dialog
       * is not a `prompt`.
       */
      defaultValue() {
        return __classPrivateFieldGet(this, _Dialog_defaultValue, "f");
      }
      /**
       * A promise that resolves when the dialog has been accepted.
       *
       * @param promptText - optional text that will be entered in the dialog
       * prompt. Has no effect if the dialog's type is not `prompt`.
       *
       */
      async accept(promptText) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Dialog_handled, "f"), "Cannot accept dialog which is already handled!");
        __classPrivateFieldSet(this, _Dialog_handled, true, "f");
        await __classPrivateFieldGet(this, _Dialog_client, "f").send("Page.handleJavaScriptDialog", {
          accept: true,
          promptText
        });
      }
      /**
       * A promise which will resolve once the dialog has been dismissed
       */
      async dismiss() {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Dialog_handled, "f"), "Cannot dismiss dialog which is already handled!");
        __classPrivateFieldSet(this, _Dialog_handled, true, "f");
        await __classPrivateFieldGet(this, _Dialog_client, "f").send("Page.handleJavaScriptDialog", {
          accept: false
        });
      }
    };
    exports2.Dialog = Dialog;
    _Dialog_client = /* @__PURE__ */ new WeakMap(), _Dialog_type = /* @__PURE__ */ new WeakMap(), _Dialog_message = /* @__PURE__ */ new WeakMap(), _Dialog_defaultValue = /* @__PURE__ */ new WeakMap(), _Dialog_handled = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/EmulationManager.js
var require_EmulationManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/EmulationManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _EmulationManager_client;
    var _EmulationManager_emulatingMobile;
    var _EmulationManager_hasTouch;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmulationManager = void 0;
    var EmulationManager = class {
      constructor(client) {
        _EmulationManager_client.set(this, void 0);
        _EmulationManager_emulatingMobile.set(this, false);
        _EmulationManager_hasTouch.set(this, false);
        __classPrivateFieldSet(this, _EmulationManager_client, client, "f");
      }
      async emulateViewport(viewport) {
        var _a;
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = (_a = viewport.deviceScaleFactor) !== null && _a !== void 0 ? _a : 1;
        const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
          __classPrivateFieldGet(this, _EmulationManager_client, "f").send("Emulation.setDeviceMetricsOverride", {
            mobile,
            width,
            height,
            deviceScaleFactor,
            screenOrientation
          }),
          __classPrivateFieldGet(this, _EmulationManager_client, "f").send("Emulation.setTouchEmulationEnabled", {
            enabled: hasTouch
          })
        ]);
        const reloadNeeded = __classPrivateFieldGet(this, _EmulationManager_emulatingMobile, "f") !== mobile || __classPrivateFieldGet(this, _EmulationManager_hasTouch, "f") !== hasTouch;
        __classPrivateFieldSet(this, _EmulationManager_emulatingMobile, mobile, "f");
        __classPrivateFieldSet(this, _EmulationManager_hasTouch, hasTouch, "f");
        return reloadNeeded;
      }
    };
    exports2.EmulationManager = EmulationManager;
    _EmulationManager_client = /* @__PURE__ */ new WeakMap(), _EmulationManager_emulatingMobile = /* @__PURE__ */ new WeakMap(), _EmulationManager_hasTouch = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FileChooser.js
var require_FileChooser = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/FileChooser.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FileChooser_element;
    var _FileChooser_multiple;
    var _FileChooser_handled;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileChooser = void 0;
    var assert_js_1 = require_assert();
    var FileChooser = class {
      /**
       * @internal
       */
      constructor(element, event) {
        _FileChooser_element.set(this, void 0);
        _FileChooser_multiple.set(this, void 0);
        _FileChooser_handled.set(this, false);
        __classPrivateFieldSet(this, _FileChooser_element, element, "f");
        __classPrivateFieldSet(this, _FileChooser_multiple, event.mode !== "selectSingle", "f");
      }
      /**
       * Whether file chooser allow for
       * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
       * file selection.
       */
      isMultiple() {
        return __classPrivateFieldGet(this, _FileChooser_multiple, "f");
      }
      /**
       * Accept the file chooser request with the given file paths.
       *
       * @remarks This will not validate whether the file paths exists. Also, if a
       * path is relative, then it is resolved against the
       * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
       * For locals script connecting to remote chrome environments, paths must be
       * absolute.
       */
      async accept(paths) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FileChooser_handled, "f"), "Cannot accept FileChooser which is already handled!");
        __classPrivateFieldSet(this, _FileChooser_handled, true, "f");
        await __classPrivateFieldGet(this, _FileChooser_element, "f").uploadFile(...paths);
      }
      /**
       * Closes the file chooser without selecting any files.
       */
      cancel() {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _FileChooser_handled, "f"), "Cannot cancel FileChooser which is already handled!");
        __classPrivateFieldSet(this, _FileChooser_handled, true, "f");
      }
    };
    exports2.FileChooser = FileChooser;
    _FileChooser_element = /* @__PURE__ */ new WeakMap(), _FileChooser_multiple = /* @__PURE__ */ new WeakMap(), _FileChooser_handled = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/DeviceRequestPrompt.js
var require_DeviceRequestPrompt = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/DeviceRequestPrompt.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _DeviceRequestPrompt_instances;
    var _DeviceRequestPrompt_client;
    var _DeviceRequestPrompt_timeoutSettings;
    var _DeviceRequestPrompt_id;
    var _DeviceRequestPrompt_handled;
    var _DeviceRequestPrompt_updateDevicesHandle;
    var _DeviceRequestPrompt_waitForDevicePromises;
    var _DeviceRequestPrompt_updateDevices;
    var _DeviceRequestPromptManager_instances;
    var _DeviceRequestPromptManager_client;
    var _DeviceRequestPromptManager_timeoutSettings;
    var _DeviceRequestPromptManager_deviceRequestPromptPromises;
    var _DeviceRequestPromptManager_onDeviceRequestPrompted;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeviceRequestPromptManager = exports2.DeviceRequestPrompt = exports2.DeviceRequestPromptDevice = void 0;
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var DeviceRequestPromptDevice = class {
      /**
       * @internal
       */
      constructor(id, name) {
        this.id = id;
        this.name = name;
      }
    };
    exports2.DeviceRequestPromptDevice = DeviceRequestPromptDevice;
    var DeviceRequestPrompt = class {
      /**
       * @internal
       */
      constructor(client, timeoutSettings, firstEvent) {
        _DeviceRequestPrompt_instances.add(this);
        _DeviceRequestPrompt_client.set(this, void 0);
        _DeviceRequestPrompt_timeoutSettings.set(this, void 0);
        _DeviceRequestPrompt_id.set(this, void 0);
        _DeviceRequestPrompt_handled.set(this, false);
        _DeviceRequestPrompt_updateDevicesHandle.set(this, __classPrivateFieldGet(this, _DeviceRequestPrompt_instances, "m", _DeviceRequestPrompt_updateDevices).bind(this));
        _DeviceRequestPrompt_waitForDevicePromises.set(this, /* @__PURE__ */ new Set());
        this.devices = [];
        __classPrivateFieldSet(this, _DeviceRequestPrompt_client, client, "f");
        __classPrivateFieldSet(this, _DeviceRequestPrompt_timeoutSettings, timeoutSettings, "f");
        __classPrivateFieldSet(this, _DeviceRequestPrompt_id, firstEvent.id, "f");
        __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").on("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
        __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").on("Target.detachedFromTarget", () => {
          __classPrivateFieldSet(this, _DeviceRequestPrompt_client, null, "f");
        });
        __classPrivateFieldGet(this, _DeviceRequestPrompt_instances, "m", _DeviceRequestPrompt_updateDevices).call(this, firstEvent);
      }
      /**
       * Resolve to the first device in the prompt matching a filter.
       */
      async waitForDevice(filter, options = {}) {
        for (const device of this.devices) {
          if (filter(device)) {
            return device;
          }
        }
        const { timeout = __classPrivateFieldGet(this, _DeviceRequestPrompt_timeoutSettings, "f").timeout() } = options;
        const promise = (0, DeferredPromise_js_1.createDeferredPromise)({
          message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout}ms exceeded`,
          timeout
        });
        const handle = { filter, promise };
        __classPrivateFieldGet(this, _DeviceRequestPrompt_waitForDevicePromises, "f").add(handle);
        try {
          return await promise;
        } finally {
          __classPrivateFieldGet(this, _DeviceRequestPrompt_waitForDevicePromises, "f").delete(handle);
        }
      }
      /**
       * Select a device in the prompt's list.
       */
      async select(device) {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f") !== null, "Cannot select device through detached session!");
        (0, assert_js_1.assert)(this.devices.includes(device), "Cannot select unknown device!");
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _DeviceRequestPrompt_handled, "f"), "Cannot select DeviceRequestPrompt which is already handled!");
        __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").off("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
        __classPrivateFieldSet(this, _DeviceRequestPrompt_handled, true, "f");
        return __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").send("DeviceAccess.selectPrompt", {
          id: __classPrivateFieldGet(this, _DeviceRequestPrompt_id, "f"),
          deviceId: device.id
        });
      }
      /**
       * Cancel the prompt.
       */
      async cancel() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f") !== null, "Cannot cancel prompt through detached session!");
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _DeviceRequestPrompt_handled, "f"), "Cannot cancel DeviceRequestPrompt which is already handled!");
        __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").off("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
        __classPrivateFieldSet(this, _DeviceRequestPrompt_handled, true, "f");
        return __classPrivateFieldGet(this, _DeviceRequestPrompt_client, "f").send("DeviceAccess.cancelPrompt", { id: __classPrivateFieldGet(this, _DeviceRequestPrompt_id, "f") });
      }
    };
    exports2.DeviceRequestPrompt = DeviceRequestPrompt;
    _DeviceRequestPrompt_client = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_timeoutSettings = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_id = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_handled = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_updateDevicesHandle = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_waitForDevicePromises = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_instances = /* @__PURE__ */ new WeakSet(), _DeviceRequestPrompt_updateDevices = function _DeviceRequestPrompt_updateDevices2(event) {
      if (event.id !== __classPrivateFieldGet(this, _DeviceRequestPrompt_id, "f")) {
        return;
      }
      for (const rawDevice of event.devices) {
        if (this.devices.some((device) => {
          return device.id === rawDevice.id;
        })) {
          continue;
        }
        const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
        this.devices.push(newDevice);
        for (const waitForDevicePromise of __classPrivateFieldGet(this, _DeviceRequestPrompt_waitForDevicePromises, "f")) {
          if (waitForDevicePromise.filter(newDevice)) {
            waitForDevicePromise.promise.resolve(newDevice);
          }
        }
      }
    };
    var DeviceRequestPromptManager = class {
      /**
       * @internal
       */
      constructor(client, timeoutSettings) {
        _DeviceRequestPromptManager_instances.add(this);
        _DeviceRequestPromptManager_client.set(this, void 0);
        _DeviceRequestPromptManager_timeoutSettings.set(this, void 0);
        _DeviceRequestPromptManager_deviceRequestPromptPromises.set(this, /* @__PURE__ */ new Set());
        __classPrivateFieldSet(this, _DeviceRequestPromptManager_client, client, "f");
        __classPrivateFieldSet(this, _DeviceRequestPromptManager_timeoutSettings, timeoutSettings, "f");
        __classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f").on("DeviceAccess.deviceRequestPrompted", (event) => {
          __classPrivateFieldGet(this, _DeviceRequestPromptManager_instances, "m", _DeviceRequestPromptManager_onDeviceRequestPrompted).call(this, event);
        });
        __classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f").on("Target.detachedFromTarget", () => {
          __classPrivateFieldSet(this, _DeviceRequestPromptManager_client, null, "f");
        });
      }
      /**
       * Wait for device prompt created by an action like calling WebBluetooth's
       * requestDevice.
       */
      async waitForDevicePrompt(options = {}) {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f") !== null, "Cannot wait for device prompt through detached session!");
        const needsEnable = __classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f").size === 0;
        let enablePromise;
        if (needsEnable) {
          enablePromise = __classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f").send("DeviceAccess.enable");
        }
        const { timeout = __classPrivateFieldGet(this, _DeviceRequestPromptManager_timeoutSettings, "f").timeout() } = options;
        const promise = (0, DeferredPromise_js_1.createDeferredPromise)({
          message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout}ms exceeded`,
          timeout
        });
        __classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f").add(promise);
        try {
          const [result] = await Promise.all([promise, enablePromise]);
          return result;
        } finally {
          __classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f").delete(promise);
        }
      }
    };
    exports2.DeviceRequestPromptManager = DeviceRequestPromptManager;
    _DeviceRequestPromptManager_client = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_timeoutSettings = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_deviceRequestPromptPromises = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_instances = /* @__PURE__ */ new WeakSet(), _DeviceRequestPromptManager_onDeviceRequestPrompted = function _DeviceRequestPromptManager_onDeviceRequestPrompted2(event) {
      if (!__classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f").size) {
        return;
      }
      (0, assert_js_1.assert)(__classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f") !== null);
      const devicePrompt = new DeviceRequestPrompt(__classPrivateFieldGet(this, _DeviceRequestPromptManager_client, "f"), __classPrivateFieldGet(this, _DeviceRequestPromptManager_timeoutSettings, "f"), event);
      for (const promise of __classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f")) {
        promise.resolve(devicePrompt);
      }
      __classPrivateFieldGet(this, _DeviceRequestPromptManager_deviceRequestPromptPromises, "f").clear();
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPRequest.js
var require_HTTPRequest2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPRequest.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _HTTPRequest_instances;
    var _HTTPRequest_client;
    var _HTTPRequest_isNavigationRequest;
    var _HTTPRequest_allowInterception;
    var _HTTPRequest_interceptionHandled;
    var _HTTPRequest_url;
    var _HTTPRequest_resourceType;
    var _HTTPRequest_method;
    var _HTTPRequest_postData;
    var _HTTPRequest_headers;
    var _HTTPRequest_frame;
    var _HTTPRequest_continueRequestOverrides;
    var _HTTPRequest_responseForRequest;
    var _HTTPRequest_abortErrorReason;
    var _HTTPRequest_interceptResolutionState;
    var _HTTPRequest_interceptHandlers;
    var _HTTPRequest_initiator;
    var _HTTPRequest_continue;
    var _HTTPRequest_respond;
    var _HTTPRequest_abort;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTTPRequest = void 0;
    var HTTPRequest_js_1 = require_HTTPRequest();
    var assert_js_1 = require_assert();
    var util_js_1 = require_util2();
    var HTTPRequest = class extends HTTPRequest_js_1.HTTPRequest {
      get client() {
        return __classPrivateFieldGet(this, _HTTPRequest_client, "f");
      }
      constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
        super();
        _HTTPRequest_instances.add(this);
        this._failureText = null;
        this._response = null;
        this._fromMemoryCache = false;
        _HTTPRequest_client.set(this, void 0);
        _HTTPRequest_isNavigationRequest.set(this, void 0);
        _HTTPRequest_allowInterception.set(this, void 0);
        _HTTPRequest_interceptionHandled.set(this, false);
        _HTTPRequest_url.set(this, void 0);
        _HTTPRequest_resourceType.set(this, void 0);
        _HTTPRequest_method.set(this, void 0);
        _HTTPRequest_postData.set(this, void 0);
        _HTTPRequest_headers.set(this, {});
        _HTTPRequest_frame.set(this, void 0);
        _HTTPRequest_continueRequestOverrides.set(this, void 0);
        _HTTPRequest_responseForRequest.set(this, null);
        _HTTPRequest_abortErrorReason.set(this, null);
        _HTTPRequest_interceptResolutionState.set(this, {
          action: HTTPRequest_js_1.InterceptResolutionAction.None
        });
        _HTTPRequest_interceptHandlers.set(this, void 0);
        _HTTPRequest_initiator.set(this, void 0);
        __classPrivateFieldSet(this, _HTTPRequest_client, client, "f");
        this._requestId = data.requestId;
        __classPrivateFieldSet(this, _HTTPRequest_isNavigationRequest, data.requestId === data.loaderId && data.type === "Document", "f");
        this._interceptionId = interceptionId;
        __classPrivateFieldSet(this, _HTTPRequest_allowInterception, allowInterception, "f");
        __classPrivateFieldSet(this, _HTTPRequest_url, data.request.url, "f");
        __classPrivateFieldSet(this, _HTTPRequest_resourceType, (data.type || "other").toLowerCase(), "f");
        __classPrivateFieldSet(this, _HTTPRequest_method, data.request.method, "f");
        __classPrivateFieldSet(this, _HTTPRequest_postData, data.request.postData, "f");
        __classPrivateFieldSet(this, _HTTPRequest_frame, frame, "f");
        this._redirectChain = redirectChain;
        __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, {}, "f");
        __classPrivateFieldSet(this, _HTTPRequest_interceptHandlers, [], "f");
        __classPrivateFieldSet(this, _HTTPRequest_initiator, data.initiator, "f");
        for (const [key, value] of Object.entries(data.request.headers)) {
          __classPrivateFieldGet(this, _HTTPRequest_headers, "f")[key.toLowerCase()] = value;
        }
      }
      url() {
        return __classPrivateFieldGet(this, _HTTPRequest_url, "f");
      }
      continueRequestOverrides() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        return __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, "f");
      }
      responseForRequest() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        return __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f");
      }
      abortErrorReason() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        return __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, "f");
      }
      interceptResolutionState() {
        if (!__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f")) {
          return { action: HTTPRequest_js_1.InterceptResolutionAction.Disabled };
        }
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f")) {
          return { action: HTTPRequest_js_1.InterceptResolutionAction.AlreadyHandled };
        }
        return { ...__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f") };
      }
      isInterceptResolutionHandled() {
        return __classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f");
      }
      enqueueInterceptAction(pendingHandler) {
        __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, "f").push(pendingHandler);
      }
      async finalizeInterceptions() {
        await __classPrivateFieldGet(this, _HTTPRequest_interceptHandlers, "f").reduce((promiseChain, interceptAction) => {
          return promiseChain.then(interceptAction);
        }, Promise.resolve());
        const { action } = this.interceptResolutionState();
        switch (action) {
          case "abort":
            return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, __classPrivateFieldGet(this, _HTTPRequest_abortErrorReason, "f"));
          case "respond":
            if (__classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f") === null) {
              throw new Error("Response is missing for the interception");
            }
            return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, __classPrivateFieldGet(this, _HTTPRequest_responseForRequest, "f"));
          case "continue":
            return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, __classPrivateFieldGet(this, _HTTPRequest_continueRequestOverrides, "f"));
        }
      }
      resourceType() {
        return __classPrivateFieldGet(this, _HTTPRequest_resourceType, "f");
      }
      method() {
        return __classPrivateFieldGet(this, _HTTPRequest_method, "f");
      }
      postData() {
        return __classPrivateFieldGet(this, _HTTPRequest_postData, "f");
      }
      headers() {
        return __classPrivateFieldGet(this, _HTTPRequest_headers, "f");
      }
      response() {
        return this._response;
      }
      frame() {
        return __classPrivateFieldGet(this, _HTTPRequest_frame, "f");
      }
      isNavigationRequest() {
        return __classPrivateFieldGet(this, _HTTPRequest_isNavigationRequest, "f");
      }
      initiator() {
        return __classPrivateFieldGet(this, _HTTPRequest_initiator, "f");
      }
      redirectChain() {
        return this._redirectChain.slice();
      }
      failure() {
        if (!this._failureText) {
          return null;
        }
        return {
          errorText: this._failureText
        };
      }
      async continue(overrides = {}, priority) {
        if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
          return;
        }
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
        if (priority === void 0) {
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, overrides);
        }
        __classPrivateFieldSet(this, _HTTPRequest_continueRequestOverrides, overrides, "f");
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
          __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
            action: HTTPRequest_js_1.InterceptResolutionAction.Continue,
            priority
          }, "f");
          return;
        }
        if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
          if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "abort" || __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "respond") {
            return;
          }
          __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action = HTTPRequest_js_1.InterceptResolutionAction.Continue;
        }
        return;
      }
      async respond(response, priority) {
        if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
          return;
        }
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
        if (priority === void 0) {
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, response);
        }
        __classPrivateFieldSet(this, _HTTPRequest_responseForRequest, response, "f");
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority > __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
          __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
            action: HTTPRequest_js_1.InterceptResolutionAction.Respond,
            priority
          }, "f");
          return;
        }
        if (priority === __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
          if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action === "abort") {
            return;
          }
          __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").action = HTTPRequest_js_1.InterceptResolutionAction.Respond;
        }
      }
      async abort(errorCode = "failed", priority) {
        if (__classPrivateFieldGet(this, _HTTPRequest_url, "f").startsWith("data:")) {
          return;
        }
        const errorReason = errorReasons[errorCode];
        (0, assert_js_1.assert)(errorReason, "Unknown error code: " + errorCode);
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
        if (priority === void 0) {
          return __classPrivateFieldGet(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, errorReason);
        }
        __classPrivateFieldSet(this, _HTTPRequest_abortErrorReason, errorReason, "f");
        if (__classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority >= __classPrivateFieldGet(this, _HTTPRequest_interceptResolutionState, "f").priority) {
          __classPrivateFieldSet(this, _HTTPRequest_interceptResolutionState, {
            action: HTTPRequest_js_1.InterceptResolutionAction.Abort,
            priority
          }, "f");
          return;
        }
      }
    };
    exports2.HTTPRequest = HTTPRequest;
    _HTTPRequest_client = /* @__PURE__ */ new WeakMap(), _HTTPRequest_isNavigationRequest = /* @__PURE__ */ new WeakMap(), _HTTPRequest_allowInterception = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptionHandled = /* @__PURE__ */ new WeakMap(), _HTTPRequest_url = /* @__PURE__ */ new WeakMap(), _HTTPRequest_resourceType = /* @__PURE__ */ new WeakMap(), _HTTPRequest_method = /* @__PURE__ */ new WeakMap(), _HTTPRequest_postData = /* @__PURE__ */ new WeakMap(), _HTTPRequest_headers = /* @__PURE__ */ new WeakMap(), _HTTPRequest_frame = /* @__PURE__ */ new WeakMap(), _HTTPRequest_continueRequestOverrides = /* @__PURE__ */ new WeakMap(), _HTTPRequest_responseForRequest = /* @__PURE__ */ new WeakMap(), _HTTPRequest_abortErrorReason = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptResolutionState = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptHandlers = /* @__PURE__ */ new WeakMap(), _HTTPRequest_initiator = /* @__PURE__ */ new WeakMap(), _HTTPRequest_instances = /* @__PURE__ */ new WeakSet(), _HTTPRequest_continue = async function _HTTPRequest_continue2(overrides = {}) {
      const { url, method, postData, headers } = overrides;
      __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
      const postDataBinaryBase64 = postData ? Buffer.from(postData).toString("base64") : void 0;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
      }
      await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.continueRequest", {
        requestId: this._interceptionId,
        url,
        method,
        postData: postDataBinaryBase64,
        headers: headers ? (0, HTTPRequest_js_1.headersArray)(headers) : void 0
      }).catch((error) => {
        __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, "f");
        return handleError(error);
      });
    }, _HTTPRequest_respond = async function _HTTPRequest_respond2(response) {
      __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
      const responseBody = response.body && (0, util_js_1.isString)(response.body) ? Buffer.from(response.body) : response.body || null;
      const responseHeaders = {};
      if (response.headers) {
        for (const header of Object.keys(response.headers)) {
          const value = response.headers[header];
          responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
            return String(item);
          }) : String(value);
        }
      }
      if (response.contentType) {
        responseHeaders["content-type"] = response.contentType;
      }
      if (responseBody && !("content-length" in responseHeaders)) {
        responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
      }
      const status = response.status || 200;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
      }
      await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: status,
        responsePhrase: HTTPRequest_js_1.STATUS_TEXTS[status],
        responseHeaders: (0, HTTPRequest_js_1.headersArray)(responseHeaders),
        body: responseBody ? responseBody.toString("base64") : void 0
      }).catch((error) => {
        __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, false, "f");
        return handleError(error);
      });
    }, _HTTPRequest_abort = async function _HTTPRequest_abort2(errorReason) {
      __classPrivateFieldSet(this, _HTTPRequest_interceptionHandled, true, "f");
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
      }
      await __classPrivateFieldGet(this, _HTTPRequest_client, "f").send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason: errorReason || "Failed"
      }).catch(handleError);
    };
    var errorReasons = {
      aborted: "Aborted",
      accessdenied: "AccessDenied",
      addressunreachable: "AddressUnreachable",
      blockedbyclient: "BlockedByClient",
      blockedbyresponse: "BlockedByResponse",
      connectionaborted: "ConnectionAborted",
      connectionclosed: "ConnectionClosed",
      connectionfailed: "ConnectionFailed",
      connectionrefused: "ConnectionRefused",
      connectionreset: "ConnectionReset",
      internetdisconnected: "InternetDisconnected",
      namenotresolved: "NameNotResolved",
      timedout: "TimedOut",
      failed: "Failed"
    };
    async function handleError(error) {
      if (["Invalid header"].includes(error.originalMessage)) {
        throw error;
      }
      (0, util_js_1.debugError)(error);
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/SecurityDetails.js
var require_SecurityDetails = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/SecurityDetails.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _SecurityDetails_subjectName;
    var _SecurityDetails_issuer;
    var _SecurityDetails_validFrom;
    var _SecurityDetails_validTo;
    var _SecurityDetails_protocol;
    var _SecurityDetails_sanList;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecurityDetails = void 0;
    var SecurityDetails = class {
      /**
       * @internal
       */
      constructor(securityPayload) {
        _SecurityDetails_subjectName.set(this, void 0);
        _SecurityDetails_issuer.set(this, void 0);
        _SecurityDetails_validFrom.set(this, void 0);
        _SecurityDetails_validTo.set(this, void 0);
        _SecurityDetails_protocol.set(this, void 0);
        _SecurityDetails_sanList.set(this, void 0);
        __classPrivateFieldSet(this, _SecurityDetails_subjectName, securityPayload.subjectName, "f");
        __classPrivateFieldSet(this, _SecurityDetails_issuer, securityPayload.issuer, "f");
        __classPrivateFieldSet(this, _SecurityDetails_validFrom, securityPayload.validFrom, "f");
        __classPrivateFieldSet(this, _SecurityDetails_validTo, securityPayload.validTo, "f");
        __classPrivateFieldSet(this, _SecurityDetails_protocol, securityPayload.protocol, "f");
        __classPrivateFieldSet(this, _SecurityDetails_sanList, securityPayload.sanList, "f");
      }
      /**
       * The name of the issuer of the certificate.
       */
      issuer() {
        return __classPrivateFieldGet(this, _SecurityDetails_issuer, "f");
      }
      /**
       * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
       * marking the start of the certificate's validity.
       */
      validFrom() {
        return __classPrivateFieldGet(this, _SecurityDetails_validFrom, "f");
      }
      /**
       * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
       * marking the end of the certificate's validity.
       */
      validTo() {
        return __classPrivateFieldGet(this, _SecurityDetails_validTo, "f");
      }
      /**
       * The security protocol being used, e.g. "TLS 1.2".
       */
      protocol() {
        return __classPrivateFieldGet(this, _SecurityDetails_protocol, "f");
      }
      /**
       * The name of the subject to which the certificate was issued.
       */
      subjectName() {
        return __classPrivateFieldGet(this, _SecurityDetails_subjectName, "f");
      }
      /**
       * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
       */
      subjectAlternativeNames() {
        return __classPrivateFieldGet(this, _SecurityDetails_sanList, "f");
      }
    };
    exports2.SecurityDetails = SecurityDetails;
    _SecurityDetails_subjectName = /* @__PURE__ */ new WeakMap(), _SecurityDetails_issuer = /* @__PURE__ */ new WeakMap(), _SecurityDetails_validFrom = /* @__PURE__ */ new WeakMap(), _SecurityDetails_validTo = /* @__PURE__ */ new WeakMap(), _SecurityDetails_protocol = /* @__PURE__ */ new WeakMap(), _SecurityDetails_sanList = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPResponse.js
var require_HTTPResponse2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/HTTPResponse.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _HTTPResponse_instances;
    var _HTTPResponse_client;
    var _HTTPResponse_request;
    var _HTTPResponse_contentPromise;
    var _HTTPResponse_bodyLoadedPromise;
    var _HTTPResponse_remoteAddress;
    var _HTTPResponse_status;
    var _HTTPResponse_statusText;
    var _HTTPResponse_url;
    var _HTTPResponse_fromDiskCache;
    var _HTTPResponse_fromServiceWorker;
    var _HTTPResponse_headers;
    var _HTTPResponse_securityDetails;
    var _HTTPResponse_timing;
    var _HTTPResponse_parseStatusTextFromExtrInfo;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTTPResponse = void 0;
    var HTTPResponse_js_1 = require_HTTPResponse();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var Errors_js_1 = require_Errors();
    var SecurityDetails_js_1 = require_SecurityDetails();
    var HTTPResponse = class extends HTTPResponse_js_1.HTTPResponse {
      constructor(client, request, responsePayload, extraInfo) {
        super();
        _HTTPResponse_instances.add(this);
        _HTTPResponse_client.set(this, void 0);
        _HTTPResponse_request.set(this, void 0);
        _HTTPResponse_contentPromise.set(this, null);
        _HTTPResponse_bodyLoadedPromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _HTTPResponse_remoteAddress.set(this, void 0);
        _HTTPResponse_status.set(this, void 0);
        _HTTPResponse_statusText.set(this, void 0);
        _HTTPResponse_url.set(this, void 0);
        _HTTPResponse_fromDiskCache.set(this, void 0);
        _HTTPResponse_fromServiceWorker.set(this, void 0);
        _HTTPResponse_headers.set(this, {});
        _HTTPResponse_securityDetails.set(this, void 0);
        _HTTPResponse_timing.set(this, void 0);
        __classPrivateFieldSet(this, _HTTPResponse_client, client, "f");
        __classPrivateFieldSet(this, _HTTPResponse_request, request, "f");
        __classPrivateFieldSet(this, _HTTPResponse_remoteAddress, {
          ip: responsePayload.remoteIPAddress,
          port: responsePayload.remotePort
        }, "f");
        __classPrivateFieldSet(this, _HTTPResponse_statusText, __classPrivateFieldGet(this, _HTTPResponse_instances, "m", _HTTPResponse_parseStatusTextFromExtrInfo).call(this, extraInfo) || responsePayload.statusText, "f");
        __classPrivateFieldSet(this, _HTTPResponse_url, request.url(), "f");
        __classPrivateFieldSet(this, _HTTPResponse_fromDiskCache, !!responsePayload.fromDiskCache, "f");
        __classPrivateFieldSet(this, _HTTPResponse_fromServiceWorker, !!responsePayload.fromServiceWorker, "f");
        __classPrivateFieldSet(this, _HTTPResponse_status, extraInfo ? extraInfo.statusCode : responsePayload.status, "f");
        const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
        for (const [key, value] of Object.entries(headers)) {
          __classPrivateFieldGet(this, _HTTPResponse_headers, "f")[key.toLowerCase()] = value;
        }
        __classPrivateFieldSet(this, _HTTPResponse_securityDetails, responsePayload.securityDetails ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails) : null, "f");
        __classPrivateFieldSet(this, _HTTPResponse_timing, responsePayload.timing || null, "f");
      }
      _resolveBody(err) {
        if (err) {
          return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromise, "f").resolve(err);
        }
        return __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromise, "f").resolve();
      }
      remoteAddress() {
        return __classPrivateFieldGet(this, _HTTPResponse_remoteAddress, "f");
      }
      url() {
        return __classPrivateFieldGet(this, _HTTPResponse_url, "f");
      }
      ok() {
        return __classPrivateFieldGet(this, _HTTPResponse_status, "f") === 0 || __classPrivateFieldGet(this, _HTTPResponse_status, "f") >= 200 && __classPrivateFieldGet(this, _HTTPResponse_status, "f") <= 299;
      }
      status() {
        return __classPrivateFieldGet(this, _HTTPResponse_status, "f");
      }
      statusText() {
        return __classPrivateFieldGet(this, _HTTPResponse_statusText, "f");
      }
      headers() {
        return __classPrivateFieldGet(this, _HTTPResponse_headers, "f");
      }
      securityDetails() {
        return __classPrivateFieldGet(this, _HTTPResponse_securityDetails, "f");
      }
      timing() {
        return __classPrivateFieldGet(this, _HTTPResponse_timing, "f");
      }
      buffer() {
        if (!__classPrivateFieldGet(this, _HTTPResponse_contentPromise, "f")) {
          __classPrivateFieldSet(this, _HTTPResponse_contentPromise, __classPrivateFieldGet(this, _HTTPResponse_bodyLoadedPromise, "f").then(async (error) => {
            if (error) {
              throw error;
            }
            try {
              const response = await __classPrivateFieldGet(this, _HTTPResponse_client, "f").send("Network.getResponseBody", {
                requestId: __classPrivateFieldGet(this, _HTTPResponse_request, "f")._requestId
              });
              return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
            } catch (error2) {
              if (error2 instanceof Errors_js_1.ProtocolError && error2.originalMessage === "No resource with given identifier found") {
                throw new Errors_js_1.ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
              }
              throw error2;
            }
          }), "f");
        }
        return __classPrivateFieldGet(this, _HTTPResponse_contentPromise, "f");
      }
      request() {
        return __classPrivateFieldGet(this, _HTTPResponse_request, "f");
      }
      fromCache() {
        return __classPrivateFieldGet(this, _HTTPResponse_fromDiskCache, "f") || __classPrivateFieldGet(this, _HTTPResponse_request, "f")._fromMemoryCache;
      }
      fromServiceWorker() {
        return __classPrivateFieldGet(this, _HTTPResponse_fromServiceWorker, "f");
      }
      frame() {
        return __classPrivateFieldGet(this, _HTTPResponse_request, "f").frame();
      }
    };
    exports2.HTTPResponse = HTTPResponse;
    _HTTPResponse_client = /* @__PURE__ */ new WeakMap(), _HTTPResponse_request = /* @__PURE__ */ new WeakMap(), _HTTPResponse_contentPromise = /* @__PURE__ */ new WeakMap(), _HTTPResponse_bodyLoadedPromise = /* @__PURE__ */ new WeakMap(), _HTTPResponse_remoteAddress = /* @__PURE__ */ new WeakMap(), _HTTPResponse_status = /* @__PURE__ */ new WeakMap(), _HTTPResponse_statusText = /* @__PURE__ */ new WeakMap(), _HTTPResponse_url = /* @__PURE__ */ new WeakMap(), _HTTPResponse_fromDiskCache = /* @__PURE__ */ new WeakMap(), _HTTPResponse_fromServiceWorker = /* @__PURE__ */ new WeakMap(), _HTTPResponse_headers = /* @__PURE__ */ new WeakMap(), _HTTPResponse_securityDetails = /* @__PURE__ */ new WeakMap(), _HTTPResponse_timing = /* @__PURE__ */ new WeakMap(), _HTTPResponse_instances = /* @__PURE__ */ new WeakSet(), _HTTPResponse_parseStatusTextFromExtrInfo = function _HTTPResponse_parseStatusTextFromExtrInfo2(extraInfo) {
      if (!extraInfo || !extraInfo.headersText) {
        return;
      }
      const firstLine = extraInfo.headersText.split("\r", 1)[0];
      if (!firstLine) {
        return;
      }
      const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
      if (!match) {
        return;
      }
      const statusText = match[1];
      if (!statusText) {
        return;
      }
      return statusText;
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkEventManager.js
var require_NetworkEventManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkEventManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _NetworkEventManager_requestWillBeSentMap;
    var _NetworkEventManager_requestPausedMap;
    var _NetworkEventManager_httpRequestsMap;
    var _NetworkEventManager_responseReceivedExtraInfoMap;
    var _NetworkEventManager_queuedRedirectInfoMap;
    var _NetworkEventManager_queuedEventGroupMap;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NetworkEventManager = void 0;
    var NetworkEventManager = class {
      constructor() {
        _NetworkEventManager_requestWillBeSentMap.set(this, /* @__PURE__ */ new Map());
        _NetworkEventManager_requestPausedMap.set(this, /* @__PURE__ */ new Map());
        _NetworkEventManager_httpRequestsMap.set(this, /* @__PURE__ */ new Map());
        _NetworkEventManager_responseReceivedExtraInfoMap.set(this, /* @__PURE__ */ new Map());
        _NetworkEventManager_queuedRedirectInfoMap.set(this, /* @__PURE__ */ new Map());
        _NetworkEventManager_queuedEventGroupMap.set(this, /* @__PURE__ */ new Map());
      }
      forget(networkRequestId) {
        __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
        __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
        __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
        __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").delete(networkRequestId);
        __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").delete(networkRequestId);
      }
      responseExtraInfo(networkRequestId) {
        if (!__classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").has(networkRequestId)) {
          __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").set(networkRequestId, []);
        }
        return __classPrivateFieldGet(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").get(networkRequestId);
      }
      queuedRedirectInfo(fetchRequestId) {
        if (!__classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").has(fetchRequestId)) {
          __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").set(fetchRequestId, []);
        }
        return __classPrivateFieldGet(this, _NetworkEventManager_queuedRedirectInfoMap, "f").get(fetchRequestId);
      }
      queueRedirectInfo(fetchRequestId, redirectInfo) {
        this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
      }
      takeQueuedRedirectInfo(fetchRequestId) {
        return this.queuedRedirectInfo(fetchRequestId).shift();
      }
      numRequestsInProgress() {
        return [...__classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f")].filter(([, request]) => {
          return !request.response();
        }).length;
      }
      storeRequestWillBeSent(networkRequestId, event) {
        __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").set(networkRequestId, event);
      }
      getRequestWillBeSent(networkRequestId) {
        return __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").get(networkRequestId);
      }
      forgetRequestWillBeSent(networkRequestId) {
        __classPrivateFieldGet(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
      }
      getRequestPaused(networkRequestId) {
        return __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").get(networkRequestId);
      }
      forgetRequestPaused(networkRequestId) {
        __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
      }
      storeRequestPaused(networkRequestId, event) {
        __classPrivateFieldGet(this, _NetworkEventManager_requestPausedMap, "f").set(networkRequestId, event);
      }
      getRequest(networkRequestId) {
        return __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").get(networkRequestId);
      }
      storeRequest(networkRequestId, request) {
        __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").set(networkRequestId, request);
      }
      forgetRequest(networkRequestId) {
        __classPrivateFieldGet(this, _NetworkEventManager_httpRequestsMap, "f").delete(networkRequestId);
      }
      getQueuedEventGroup(networkRequestId) {
        return __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").get(networkRequestId);
      }
      queueEventGroup(networkRequestId, event) {
        __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").set(networkRequestId, event);
      }
      forgetQueuedEventGroup(networkRequestId) {
        __classPrivateFieldGet(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
      }
    };
    exports2.NetworkEventManager = NetworkEventManager;
    _NetworkEventManager_requestWillBeSentMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_requestPausedMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_httpRequestsMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_responseReceivedExtraInfoMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_queuedRedirectInfoMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_queuedEventGroupMap = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkManager.js
var require_NetworkManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/NetworkManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _NetworkManager_instances;
    var _NetworkManager_client;
    var _NetworkManager_ignoreHTTPSErrors;
    var _NetworkManager_frameManager;
    var _NetworkManager_networkEventManager;
    var _NetworkManager_extraHTTPHeaders;
    var _NetworkManager_credentials;
    var _NetworkManager_attemptedAuthentications;
    var _NetworkManager_userRequestInterceptionEnabled;
    var _NetworkManager_protocolRequestInterceptionEnabled;
    var _NetworkManager_userCacheDisabled;
    var _NetworkManager_emulatedNetworkConditions;
    var _NetworkManager_deferredInitPromise;
    var _NetworkManager_updateNetworkConditions;
    var _NetworkManager_updateProtocolRequestInterception;
    var _NetworkManager_cacheDisabled;
    var _NetworkManager_updateProtocolCacheDisabled;
    var _NetworkManager_onRequestWillBeSent;
    var _NetworkManager_onAuthRequired;
    var _NetworkManager_onRequestPaused;
    var _NetworkManager_patchRequestEventHeaders;
    var _NetworkManager_onRequestWithoutNetworkInstrumentation;
    var _NetworkManager_onRequest;
    var _NetworkManager_onRequestServedFromCache;
    var _NetworkManager_handleRequestRedirect;
    var _NetworkManager_emitResponseEvent;
    var _NetworkManager_onResponseReceived;
    var _NetworkManager_onResponseReceivedExtraInfo;
    var _NetworkManager_forgetRequest;
    var _NetworkManager_onLoadingFinished;
    var _NetworkManager_emitLoadingFinished;
    var _NetworkManager_onLoadingFailed;
    var _NetworkManager_emitLoadingFailed;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NetworkManager = exports2.NetworkManagerEmittedEvents = void 0;
    var assert_js_1 = require_assert();
    var DebuggableDeferredPromise_js_1 = require_DebuggableDeferredPromise();
    var EventEmitter_js_1 = require_EventEmitter();
    var HTTPRequest_js_1 = require_HTTPRequest2();
    var HTTPResponse_js_1 = require_HTTPResponse2();
    var NetworkEventManager_js_1 = require_NetworkEventManager();
    var util_js_1 = require_util2();
    exports2.NetworkManagerEmittedEvents = {
      Request: Symbol("NetworkManager.Request"),
      RequestServedFromCache: Symbol("NetworkManager.RequestServedFromCache"),
      Response: Symbol("NetworkManager.Response"),
      RequestFailed: Symbol("NetworkManager.RequestFailed"),
      RequestFinished: Symbol("NetworkManager.RequestFinished")
    };
    var NetworkManager = class extends EventEmitter_js_1.EventEmitter {
      constructor(client, ignoreHTTPSErrors, frameManager) {
        super();
        _NetworkManager_instances.add(this);
        _NetworkManager_client.set(this, void 0);
        _NetworkManager_ignoreHTTPSErrors.set(this, void 0);
        _NetworkManager_frameManager.set(this, void 0);
        _NetworkManager_networkEventManager.set(this, new NetworkEventManager_js_1.NetworkEventManager());
        _NetworkManager_extraHTTPHeaders.set(this, {});
        _NetworkManager_credentials.set(this, void 0);
        _NetworkManager_attemptedAuthentications.set(this, /* @__PURE__ */ new Set());
        _NetworkManager_userRequestInterceptionEnabled.set(this, false);
        _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);
        _NetworkManager_userCacheDisabled.set(this, false);
        _NetworkManager_emulatedNetworkConditions.set(this, {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        });
        _NetworkManager_deferredInitPromise.set(this, void 0);
        __classPrivateFieldSet(this, _NetworkManager_client, client, "f");
        __classPrivateFieldSet(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
        __classPrivateFieldSet(this, _NetworkManager_frameManager, frameManager, "f");
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Fetch.requestPaused", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestPaused).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Fetch.authRequired", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onAuthRequired).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.requestWillBeSent", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestWillBeSent).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.requestServedFromCache", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestServedFromCache).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.responseReceived", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceived).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.loadingFinished", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFinished).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.loadingFailed", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFailed).bind(this));
        __classPrivateFieldGet(this, _NetworkManager_client, "f").on("Network.responseReceivedExtraInfo", __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceivedExtraInfo).bind(this));
      }
      /**
       * Initialize calls should avoid async dependencies between CDP calls as those
       * might not resolve until after the target is resumed causing a deadlock.
       */
      initialize() {
        if (__classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f")) {
          return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
        }
        __classPrivateFieldSet(this, _NetworkManager_deferredInitPromise, (0, DebuggableDeferredPromise_js_1.createDebuggableDeferredPromise)("NetworkManager initialization timed out"), "f");
        const init = Promise.all([
          __classPrivateFieldGet(this, _NetworkManager_ignoreHTTPSErrors, "f") ? __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Security.setIgnoreCertificateErrors", {
            ignore: true
          }) : null,
          __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.enable")
        ]);
        const deferredInitPromise = __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
        init.then(() => {
          deferredInitPromise.resolve();
        }).catch((err) => {
          deferredInitPromise.reject(err);
        });
        return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, "f");
      }
      async authenticate(credentials) {
        __classPrivateFieldSet(this, _NetworkManager_credentials, credentials, "f");
        await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
      }
      async setExtraHTTPHeaders(extraHTTPHeaders) {
        __classPrivateFieldSet(this, _NetworkManager_extraHTTPHeaders, {}, "f");
        for (const key of Object.keys(extraHTTPHeaders)) {
          const value = extraHTTPHeaders[key];
          (0, assert_js_1.assert)((0, util_js_1.isString)(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
          __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f")[key.toLowerCase()] = value;
        }
        await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setExtraHTTPHeaders", {
          headers: __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f")
        });
      }
      extraHTTPHeaders() {
        return Object.assign({}, __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, "f"));
      }
      numRequestsInProgress() {
        return __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").numRequestsInProgress();
      }
      async setOfflineMode(value) {
        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").offline = value;
        await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
      }
      async emulateNetworkConditions(networkConditions) {
        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").upload = networkConditions ? networkConditions.upload : -1;
        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").download = networkConditions ? networkConditions.download : -1;
        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").latency = networkConditions ? networkConditions.latency : 0;
        await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
      }
      async setUserAgent(userAgent, userAgentMetadata) {
        await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setUserAgentOverride", {
          userAgent,
          userAgentMetadata
        });
      }
      async setCacheEnabled(enabled) {
        __classPrivateFieldSet(this, _NetworkManager_userCacheDisabled, !enabled, "f");
        await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this);
      }
      async setRequestInterception(value) {
        __classPrivateFieldSet(this, _NetworkManager_userRequestInterceptionEnabled, value, "f");
        await __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
      }
    };
    exports2.NetworkManager = NetworkManager;
    _NetworkManager_client = /* @__PURE__ */ new WeakMap(), _NetworkManager_ignoreHTTPSErrors = /* @__PURE__ */ new WeakMap(), _NetworkManager_frameManager = /* @__PURE__ */ new WeakMap(), _NetworkManager_networkEventManager = /* @__PURE__ */ new WeakMap(), _NetworkManager_extraHTTPHeaders = /* @__PURE__ */ new WeakMap(), _NetworkManager_credentials = /* @__PURE__ */ new WeakMap(), _NetworkManager_attemptedAuthentications = /* @__PURE__ */ new WeakMap(), _NetworkManager_userRequestInterceptionEnabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_protocolRequestInterceptionEnabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_userCacheDisabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_emulatedNetworkConditions = /* @__PURE__ */ new WeakMap(), _NetworkManager_deferredInitPromise = /* @__PURE__ */ new WeakMap(), _NetworkManager_instances = /* @__PURE__ */ new WeakSet(), _NetworkManager_updateNetworkConditions = async function _NetworkManager_updateNetworkConditions2() {
      await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.emulateNetworkConditions", {
        offline: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").offline,
        latency: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").latency,
        uploadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").upload,
        downloadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, "f").download
      });
    }, _NetworkManager_updateProtocolRequestInterception = async function _NetworkManager_updateProtocolRequestInterception2() {
      const enabled = __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") || !!__classPrivateFieldGet(this, _NetworkManager_credentials, "f");
      if (enabled === __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, "f");
      if (enabled) {
        await Promise.all([
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
          __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.enable", {
            handleAuthRequests: true,
            patterns: [{ urlPattern: "*" }]
          })
        ]);
      } else {
        await Promise.all([
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
          __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.disable")
        ]);
      }
    }, _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled2() {
      return __classPrivateFieldGet(this, _NetworkManager_userCacheDisabled, "f");
    }, _NetworkManager_updateProtocolCacheDisabled = async function _NetworkManager_updateProtocolCacheDisabled2() {
      await __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Network.setCacheDisabled", {
        cacheDisabled: __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_cacheDisabled).call(this)
      });
    }, _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent2(event) {
      if (__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") && !event.request.url.startsWith("data:")) {
        const { requestId: networkRequestId } = event;
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequestWillBeSent(networkRequestId, event);
        const requestPausedEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequestPaused(networkRequestId);
        if (requestPausedEvent) {
          const { requestId: fetchRequestId } = requestPausedEvent;
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, fetchRequestId);
          __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequestPaused(networkRequestId);
        }
        return;
      }
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, void 0);
    }, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired2(event) {
      let response = "Default";
      if (__classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").has(event.requestId)) {
        response = "CancelAuth";
      } else if (__classPrivateFieldGet(this, _NetworkManager_credentials, "f")) {
        response = "ProvideCredentials";
        __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").add(event.requestId);
      }
      const { username, password } = __classPrivateFieldGet(this, _NetworkManager_credentials, "f") || {
        username: void 0,
        password: void 0
      };
      __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.continueWithAuth", {
        requestId: event.requestId,
        authChallengeResponse: { response, username, password }
      }).catch(util_js_1.debugError);
    }, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused2(event) {
      if (!__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f") && __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
        __classPrivateFieldGet(this, _NetworkManager_client, "f").send("Fetch.continueRequest", {
          requestId: event.requestId
        }).catch(util_js_1.debugError);
      }
      const { networkId: networkRequestId, requestId: fetchRequestId } = event;
      if (!networkRequestId) {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequestWithoutNetworkInstrumentation).call(this, event);
        return;
      }
      const requestWillBeSentEvent = (() => {
        const requestWillBeSentEvent2 = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequestWillBeSent(networkRequestId);
        if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
          __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequestWillBeSent(networkRequestId);
          return;
        }
        return requestWillBeSentEvent2;
      })();
      if (requestWillBeSentEvent) {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);
      } else {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequestPaused(networkRequestId, event);
      }
    }, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders2(requestWillBeSentEvent, requestPausedEvent) {
      requestWillBeSentEvent.request.headers = {
        ...requestWillBeSentEvent.request.headers,
        // includes extra headers, like: Accept, Origin
        ...requestPausedEvent.request.headers
      };
    }, _NetworkManager_onRequestWithoutNetworkInstrumentation = function _NetworkManager_onRequestWithoutNetworkInstrumentation2(event) {
      const frame = event.frameId ? __classPrivateFieldGet(this, _NetworkManager_frameManager, "f").frame(event.frameId) : null;
      const request = new HTTPRequest_js_1.HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, "f"), frame, event.requestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f"), event, []);
      this.emit(exports2.NetworkManagerEmittedEvents.Request, request);
      void request.finalizeInterceptions();
    }, _NetworkManager_onRequest = function _NetworkManager_onRequest2(event, fetchRequestId) {
      let redirectChain = [];
      if (event.redirectResponse) {
        let redirectResponseExtraInfo = null;
        if (event.redirectHasExtraInfo) {
          redirectResponseExtraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
          if (!redirectResponseExtraInfo) {
            __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").queueRedirectInfo(event.requestId, {
              event,
              fetchRequestId
            });
            return;
          }
        }
        const request2 = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
        if (request2) {
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_handleRequestRedirect).call(this, request2, event.redirectResponse, redirectResponseExtraInfo);
          redirectChain = request2._redirectChain;
        }
      }
      const frame = event.frameId ? __classPrivateFieldGet(this, _NetworkManager_frameManager, "f").frame(event.frameId) : null;
      const request = new HTTPRequest_js_1.HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, "f"), frame, fetchRequestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, "f"), event, redirectChain);
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").storeRequest(event.requestId, request);
      this.emit(exports2.NetworkManagerEmittedEvents.Request, request);
      void request.finalizeInterceptions();
    }, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache2(event) {
      const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
      if (request) {
        request._fromMemoryCache = true;
      }
      this.emit(exports2.NetworkManagerEmittedEvents.RequestServedFromCache, request);
    }, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect2(request, responsePayload, extraInfo) {
      const response = new HTTPResponse_js_1.HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, "f"), request, responsePayload, extraInfo);
      request._response = response;
      request._redirectChain.push(request);
      response._resolveBody(new Error("Response body is unavailable for redirect responses"));
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, false);
      this.emit(exports2.NetworkManagerEmittedEvents.Response, response);
      this.emit(exports2.NetworkManagerEmittedEvents.RequestFinished, request);
    }, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent2(responseReceived, extraInfo) {
      const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(responseReceived.requestId);
      if (!request) {
        return;
      }
      const extraInfos = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(responseReceived.requestId);
      if (extraInfos.length) {
        (0, util_js_1.debugError)(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
      }
      if (responseReceived.response.fromDiskCache) {
        extraInfo = null;
      }
      const response = new HTTPResponse_js_1.HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, "f"), request, responseReceived.response, extraInfo);
      request._response = response;
      this.emit(exports2.NetworkManagerEmittedEvents.Response, response);
    }, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived2(event) {
      const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
      let extraInfo = null;
      if (request && !request._fromMemoryCache && event.hasExtraInfo) {
        extraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
        if (!extraInfo) {
          __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").queueEventGroup(event.requestId, {
            responseReceivedEvent: event
          });
          return;
        }
      }
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);
    }, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo2(event) {
      const redirectInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").takeQueuedRedirectInfo(event.requestId);
      if (redirectInfo) {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);
        return;
      }
      const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetQueuedEventGroup(event.requestId);
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);
        if (queuedEvents.loadingFinishedEvent) {
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);
        }
        if (queuedEvents.loadingFailedEvent) {
          __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);
        }
        return;
      }
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
    }, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest2(request, events) {
      const requestId = request._requestId;
      const interceptionId = request._interceptionId;
      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forgetRequest(requestId);
      interceptionId !== void 0 && __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, "f").delete(interceptionId);
      if (events) {
        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").forget(requestId);
      }
    }, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished2(event) {
      const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFinishedEvent = event;
      } else {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, event);
      }
    }, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished2(event) {
      var _a;
      const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
      if (!request) {
        return;
      }
      if (request.response()) {
        (_a = request.response()) === null || _a === void 0 ? void 0 : _a._resolveBody(null);
      }
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
      this.emit(exports2.NetworkManagerEmittedEvents.RequestFinished, request);
    }, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed2(event) {
      const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFailedEvent = event;
      } else {
        __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, event);
      }
    }, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed2(event) {
      const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
      if (!request) {
        return;
      }
      request._failureText = event.errorText;
      const response = request.response();
      if (response) {
        response._resolveBody(null);
      }
      __classPrivateFieldGet(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
      this.emit(exports2.NetworkManagerEmittedEvents.RequestFailed, request);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/LifecycleWatcher.js
var require_LifecycleWatcher = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/LifecycleWatcher.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _LifecycleWatcher_instances;
    var _LifecycleWatcher_expectedLifecycle;
    var _LifecycleWatcher_frameManager;
    var _LifecycleWatcher_frame;
    var _LifecycleWatcher_timeout;
    var _LifecycleWatcher_navigationRequest;
    var _LifecycleWatcher_eventListeners;
    var _LifecycleWatcher_initialLoaderId;
    var _LifecycleWatcher_sameDocumentNavigationPromise;
    var _LifecycleWatcher_lifecyclePromise;
    var _LifecycleWatcher_newDocumentNavigationPromise;
    var _LifecycleWatcher_terminationPromise;
    var _LifecycleWatcher_timeoutPromise;
    var _LifecycleWatcher_maximumTimer;
    var _LifecycleWatcher_hasSameDocumentNavigation;
    var _LifecycleWatcher_swapped;
    var _LifecycleWatcher_navigationResponseReceived;
    var _LifecycleWatcher_onRequest;
    var _LifecycleWatcher_onRequestFailed;
    var _LifecycleWatcher_onResponse;
    var _LifecycleWatcher_onFrameDetached;
    var _LifecycleWatcher_terminate;
    var _LifecycleWatcher_createTimeoutPromise;
    var _LifecycleWatcher_navigatedWithinDocument;
    var _LifecycleWatcher_navigated;
    var _LifecycleWatcher_frameSwapped;
    var _LifecycleWatcher_checkLifecycleComplete;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LifecycleWatcher = void 0;
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var Connection_js_1 = require_Connection();
    var Errors_js_1 = require_Errors();
    var FrameManager_js_1 = require_FrameManager();
    var NetworkManager_js_1 = require_NetworkManager();
    var util_js_1 = require_util2();
    var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
      ["load", "load"],
      ["domcontentloaded", "DOMContentLoaded"],
      ["networkidle0", "networkIdle"],
      ["networkidle2", "networkAlmostIdle"]
    ]);
    var noop = () => {
    };
    var LifecycleWatcher = class {
      constructor(frameManager, frame, waitUntil, timeout) {
        _LifecycleWatcher_instances.add(this);
        _LifecycleWatcher_expectedLifecycle.set(this, void 0);
        _LifecycleWatcher_frameManager.set(this, void 0);
        _LifecycleWatcher_frame.set(this, void 0);
        _LifecycleWatcher_timeout.set(this, void 0);
        _LifecycleWatcher_navigationRequest.set(this, null);
        _LifecycleWatcher_eventListeners.set(this, void 0);
        _LifecycleWatcher_initialLoaderId.set(this, void 0);
        _LifecycleWatcher_sameDocumentNavigationPromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _LifecycleWatcher_lifecyclePromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _LifecycleWatcher_newDocumentNavigationPromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _LifecycleWatcher_terminationPromise.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _LifecycleWatcher_timeoutPromise.set(this, void 0);
        _LifecycleWatcher_maximumTimer.set(this, void 0);
        _LifecycleWatcher_hasSameDocumentNavigation.set(this, void 0);
        _LifecycleWatcher_swapped.set(this, void 0);
        _LifecycleWatcher_navigationResponseReceived.set(this, void 0);
        if (Array.isArray(waitUntil)) {
          waitUntil = waitUntil.slice();
        } else if (typeof waitUntil === "string") {
          waitUntil = [waitUntil];
        }
        __classPrivateFieldSet(this, _LifecycleWatcher_initialLoaderId, frame._loaderId, "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_expectedLifecycle, waitUntil.map((value) => {
          const protocolEvent = puppeteerToProtocolLifecycle.get(value);
          (0, assert_js_1.assert)(protocolEvent, "Unknown value for options.waitUntil: " + value);
          return protocolEvent;
        }), "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_frameManager, frameManager, "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_frame, frame, "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_timeout, timeout, "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_eventListeners, [
          (0, util_js_1.addEventListener)(frameManager.client, Connection_js_1.CDPSessionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_terminate).bind(this, new Error("Navigation failed because browser has disconnected!"))),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.LifecycleEvent, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigatedWithinDocument).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigated).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameSwapped, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_frameSwapped).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onFrameDetached).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onRequest).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onResponse).bind(this)),
          (0, util_js_1.addEventListener)(__classPrivateFieldGet(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onRequestFailed).bind(this))
        ], "f");
        __classPrivateFieldSet(this, _LifecycleWatcher_timeoutPromise, __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_createTimeoutPromise).call(this), "f");
        __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
      }
      async navigationResponse() {
        var _a;
        await ((_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _a === void 0 ? void 0 : _a.catch(() => {
        }));
        return __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f") ? __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f").response() : null;
      }
      sameDocumentNavigationPromise() {
        return __classPrivateFieldGet(this, _LifecycleWatcher_sameDocumentNavigationPromise, "f");
      }
      newDocumentNavigationPromise() {
        return __classPrivateFieldGet(this, _LifecycleWatcher_newDocumentNavigationPromise, "f");
      }
      lifecyclePromise() {
        return __classPrivateFieldGet(this, _LifecycleWatcher_lifecyclePromise, "f");
      }
      timeoutOrTerminationPromise() {
        return Promise.race([__classPrivateFieldGet(this, _LifecycleWatcher_timeoutPromise, "f"), __classPrivateFieldGet(this, _LifecycleWatcher_terminationPromise, "f")]);
      }
      dispose() {
        (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _LifecycleWatcher_eventListeners, "f"));
        __classPrivateFieldGet(this, _LifecycleWatcher_maximumTimer, "f") !== void 0 && clearTimeout(__classPrivateFieldGet(this, _LifecycleWatcher_maximumTimer, "f"));
      }
    };
    exports2.LifecycleWatcher = LifecycleWatcher;
    _LifecycleWatcher_expectedLifecycle = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_frameManager = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_frame = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_timeout = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_navigationRequest = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_eventListeners = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_initialLoaderId = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_sameDocumentNavigationPromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_lifecyclePromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_newDocumentNavigationPromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_terminationPromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_timeoutPromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_maximumTimer = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_hasSameDocumentNavigation = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_swapped = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_navigationResponseReceived = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_instances = /* @__PURE__ */ new WeakSet(), _LifecycleWatcher_onRequest = function _LifecycleWatcher_onRequest2(request) {
      var _a, _b;
      if (request.frame() !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f") || !request.isNavigationRequest()) {
        return;
      }
      __classPrivateFieldSet(this, _LifecycleWatcher_navigationRequest, request, "f");
      (_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _a === void 0 ? void 0 : _a.resolve();
      __classPrivateFieldSet(this, _LifecycleWatcher_navigationResponseReceived, (0, DeferredPromise_js_1.createDeferredPromise)(), "f");
      if (request.response() !== null) {
        (_b = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _b === void 0 ? void 0 : _b.resolve();
      }
    }, _LifecycleWatcher_onRequestFailed = function _LifecycleWatcher_onRequestFailed2(request) {
      var _a, _b;
      if (((_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f")) === null || _a === void 0 ? void 0 : _a._requestId) !== request._requestId) {
        return;
      }
      (_b = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _b === void 0 ? void 0 : _b.resolve();
    }, _LifecycleWatcher_onResponse = function _LifecycleWatcher_onResponse2(response) {
      var _a, _b;
      if (((_a = __classPrivateFieldGet(this, _LifecycleWatcher_navigationRequest, "f")) === null || _a === void 0 ? void 0 : _a._requestId) !== response.request()._requestId) {
        return;
      }
      (_b = __classPrivateFieldGet(this, _LifecycleWatcher_navigationResponseReceived, "f")) === null || _b === void 0 ? void 0 : _b.resolve();
    }, _LifecycleWatcher_onFrameDetached = function _LifecycleWatcher_onFrameDetached2(frame) {
      if (__classPrivateFieldGet(this, _LifecycleWatcher_frame, "f") === frame) {
        __classPrivateFieldGet(this, _LifecycleWatcher_terminationPromise, "f").resolve(new Error("Navigating frame was detached"));
        return;
      }
      __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
    }, _LifecycleWatcher_terminate = function _LifecycleWatcher_terminate2(error) {
      __classPrivateFieldGet(this, _LifecycleWatcher_terminationPromise, "f").resolve(error);
    }, _LifecycleWatcher_createTimeoutPromise = async function _LifecycleWatcher_createTimeoutPromise2() {
      if (!__classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f")) {
        return new Promise(noop);
      }
      const errorMessage = "Navigation timeout of " + __classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f") + " ms exceeded";
      await new Promise((fulfill) => {
        return __classPrivateFieldSet(this, _LifecycleWatcher_maximumTimer, setTimeout(fulfill, __classPrivateFieldGet(this, _LifecycleWatcher_timeout, "f")), "f");
      });
      return new Errors_js_1.TimeoutError(errorMessage);
    }, _LifecycleWatcher_navigatedWithinDocument = function _LifecycleWatcher_navigatedWithinDocument2(frame) {
      if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _LifecycleWatcher_hasSameDocumentNavigation, true, "f");
      __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
    }, _LifecycleWatcher_navigated = function _LifecycleWatcher_navigated2(frame) {
      if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
        return;
      }
      __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
    }, _LifecycleWatcher_frameSwapped = function _LifecycleWatcher_frameSwapped2(frame) {
      if (frame !== __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _LifecycleWatcher_swapped, true, "f");
      __classPrivateFieldGet(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
    }, _LifecycleWatcher_checkLifecycleComplete = function _LifecycleWatcher_checkLifecycleComplete2() {
      if (!checkLifecycle(__classPrivateFieldGet(this, _LifecycleWatcher_frame, "f"), __classPrivateFieldGet(this, _LifecycleWatcher_expectedLifecycle, "f"))) {
        return;
      }
      __classPrivateFieldGet(this, _LifecycleWatcher_lifecyclePromise, "f").resolve();
      if (__classPrivateFieldGet(this, _LifecycleWatcher_hasSameDocumentNavigation, "f")) {
        __classPrivateFieldGet(this, _LifecycleWatcher_sameDocumentNavigationPromise, "f").resolve(void 0);
      }
      if (__classPrivateFieldGet(this, _LifecycleWatcher_swapped, "f") || __classPrivateFieldGet(this, _LifecycleWatcher_frame, "f")._loaderId !== __classPrivateFieldGet(this, _LifecycleWatcher_initialLoaderId, "f")) {
        __classPrivateFieldGet(this, _LifecycleWatcher_newDocumentNavigationPromise, "f").resolve(void 0);
      }
      function checkLifecycle(frame, expectedLifecycle) {
        for (const event of expectedLifecycle) {
          if (!frame._lifecycleEvents.has(event)) {
            return false;
          }
        }
        for (const child of frame.childFrames()) {
          if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/WaitTask.js
var require_WaitTask = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/WaitTask.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _WaitTask_world;
    var _WaitTask_polling;
    var _WaitTask_root;
    var _WaitTask_fn;
    var _WaitTask_args;
    var _WaitTask_timeout;
    var _WaitTask_result;
    var _WaitTask_poller;
    var _WaitTask_signal;
    var _TaskManager_tasks;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskManager = exports2.WaitTask = void 0;
    var DeferredPromise_js_1 = require_DeferredPromise();
    var Function_js_1 = require_Function();
    var Errors_js_1 = require_Errors();
    var LazyArg_js_1 = require_LazyArg();
    var WaitTask = class {
      constructor(world, options, fn, ...args) {
        var _a;
        _WaitTask_world.set(this, void 0);
        _WaitTask_polling.set(this, void 0);
        _WaitTask_root.set(this, void 0);
        _WaitTask_fn.set(this, void 0);
        _WaitTask_args.set(this, void 0);
        _WaitTask_timeout.set(this, void 0);
        _WaitTask_result.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _WaitTask_poller.set(this, void 0);
        _WaitTask_signal.set(this, void 0);
        __classPrivateFieldSet(this, _WaitTask_world, world, "f");
        __classPrivateFieldSet(this, _WaitTask_polling, options.polling, "f");
        __classPrivateFieldSet(this, _WaitTask_root, options.root, "f");
        __classPrivateFieldSet(this, _WaitTask_signal, options.signal, "f");
        (_a = __classPrivateFieldGet(this, _WaitTask_signal, "f")) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", () => {
          var _a2;
          void this.terminate((_a2 = __classPrivateFieldGet(this, _WaitTask_signal, "f")) === null || _a2 === void 0 ? void 0 : _a2.reason);
        }, {
          once: true
        });
        switch (typeof fn) {
          case "string":
            __classPrivateFieldSet(this, _WaitTask_fn, `() => {return (${fn});}`, "f");
            break;
          default:
            __classPrivateFieldSet(this, _WaitTask_fn, (0, Function_js_1.stringifyFunction)(fn), "f");
            break;
        }
        __classPrivateFieldSet(this, _WaitTask_args, args, "f");
        __classPrivateFieldGet(this, _WaitTask_world, "f").taskManager.add(this);
        if (options.timeout) {
          __classPrivateFieldSet(this, _WaitTask_timeout, setTimeout(() => {
            void this.terminate(new Errors_js_1.TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
          }, options.timeout), "f");
        }
        void this.rerun();
      }
      get result() {
        return __classPrivateFieldGet(this, _WaitTask_result, "f");
      }
      async rerun() {
        try {
          switch (__classPrivateFieldGet(this, _WaitTask_polling, "f")) {
            case "raf":
              __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ RAFPoller, createFunction }, fn, ...args) => {
                const fun = createFunction(fn);
                return new RAFPoller(() => {
                  return fun(...args);
                });
              }, LazyArg_js_1.LazyArg.create((context) => {
                return context.puppeteerUtil;
              }), __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
              break;
            case "mutation":
              __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ MutationPoller, createFunction }, root, fn, ...args) => {
                const fun = createFunction(fn);
                return new MutationPoller(() => {
                  return fun(...args);
                }, root || document);
              }, LazyArg_js_1.LazyArg.create((context) => {
                return context.puppeteerUtil;
              }), __classPrivateFieldGet(this, _WaitTask_root, "f"), __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
              break;
            default:
              __classPrivateFieldSet(this, _WaitTask_poller, await __classPrivateFieldGet(this, _WaitTask_world, "f").evaluateHandle(({ IntervalPoller, createFunction }, ms, fn, ...args) => {
                const fun = createFunction(fn);
                return new IntervalPoller(() => {
                  return fun(...args);
                }, ms);
              }, LazyArg_js_1.LazyArg.create((context) => {
                return context.puppeteerUtil;
              }), __classPrivateFieldGet(this, _WaitTask_polling, "f"), __classPrivateFieldGet(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet(this, _WaitTask_args, "f")), "f");
              break;
          }
          await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluate((poller) => {
            void poller.start();
          });
          const result = await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluateHandle((poller) => {
            return poller.result();
          });
          __classPrivateFieldGet(this, _WaitTask_result, "f").resolve(result);
          await this.terminate();
        } catch (error) {
          const badError = this.getBadError(error);
          if (badError) {
            await this.terminate(badError);
          }
        }
      }
      async terminate(error) {
        __classPrivateFieldGet(this, _WaitTask_world, "f").taskManager.delete(this);
        if (__classPrivateFieldGet(this, _WaitTask_timeout, "f")) {
          clearTimeout(__classPrivateFieldGet(this, _WaitTask_timeout, "f"));
        }
        if (error && !__classPrivateFieldGet(this, _WaitTask_result, "f").finished()) {
          __classPrivateFieldGet(this, _WaitTask_result, "f").reject(error);
        }
        if (__classPrivateFieldGet(this, _WaitTask_poller, "f")) {
          try {
            await __classPrivateFieldGet(this, _WaitTask_poller, "f").evaluateHandle(async (poller) => {
              await poller.stop();
            });
            if (__classPrivateFieldGet(this, _WaitTask_poller, "f")) {
              await __classPrivateFieldGet(this, _WaitTask_poller, "f").dispose();
              __classPrivateFieldSet(this, _WaitTask_poller, void 0, "f");
            }
          } catch {
          }
        }
      }
      /**
       * Not all errors lead to termination. They usually imply we need to rerun the task.
       */
      getBadError(error) {
        if (error instanceof Error) {
          if (error.message.includes("Execution context is not available in detached frame")) {
            return new Error("Waiting failed: Frame detached");
          }
          if (error.message.includes("Execution context was destroyed")) {
            return;
          }
          if (error.message.includes("Cannot find context with specified id")) {
            return;
          }
        }
        return error;
      }
    };
    exports2.WaitTask = WaitTask;
    _WaitTask_world = /* @__PURE__ */ new WeakMap(), _WaitTask_polling = /* @__PURE__ */ new WeakMap(), _WaitTask_root = /* @__PURE__ */ new WeakMap(), _WaitTask_fn = /* @__PURE__ */ new WeakMap(), _WaitTask_args = /* @__PURE__ */ new WeakMap(), _WaitTask_timeout = /* @__PURE__ */ new WeakMap(), _WaitTask_result = /* @__PURE__ */ new WeakMap(), _WaitTask_poller = /* @__PURE__ */ new WeakMap(), _WaitTask_signal = /* @__PURE__ */ new WeakMap();
    var TaskManager = class {
      constructor() {
        _TaskManager_tasks.set(this, /* @__PURE__ */ new Set());
      }
      add(task) {
        __classPrivateFieldGet(this, _TaskManager_tasks, "f").add(task);
      }
      delete(task) {
        __classPrivateFieldGet(this, _TaskManager_tasks, "f").delete(task);
      }
      terminateAll(error) {
        for (const task of __classPrivateFieldGet(this, _TaskManager_tasks, "f")) {
          void task.terminate(error);
        }
        __classPrivateFieldGet(this, _TaskManager_tasks, "f").clear();
      }
      async rerunAll() {
        await Promise.all([...__classPrivateFieldGet(this, _TaskManager_tasks, "f")].map((task) => {
          return task.rerun();
        }));
      }
    };
    exports2.TaskManager = TaskManager;
    _TaskManager_tasks = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/IsolatedWorld.js
var require_IsolatedWorld = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/IsolatedWorld.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _IsolatedWorld_instances;
    var _IsolatedWorld_frame;
    var _IsolatedWorld_document;
    var _IsolatedWorld_context;
    var _IsolatedWorld_detached;
    var _IsolatedWorld_contextBindings;
    var _IsolatedWorld_bindings;
    var _IsolatedWorld_taskManager;
    var _IsolatedWorld_client_get;
    var _IsolatedWorld_frameManager_get;
    var _IsolatedWorld_timeoutSettings_get;
    var _IsolatedWorld_mutex;
    var _IsolatedWorld_onBindingCalled;
    var _Mutex_locked;
    var _Mutex_acquirers;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsolatedWorld = void 0;
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var LifecycleWatcher_js_1 = require_LifecycleWatcher();
    var util_js_1 = require_util2();
    var WaitTask_js_1 = require_WaitTask();
    var IsolatedWorld = class {
      get taskManager() {
        return __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f");
      }
      get _bindings() {
        return __classPrivateFieldGet(this, _IsolatedWorld_bindings, "f");
      }
      constructor(frame) {
        _IsolatedWorld_instances.add(this);
        _IsolatedWorld_frame.set(this, void 0);
        _IsolatedWorld_document.set(this, void 0);
        _IsolatedWorld_context.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _IsolatedWorld_detached.set(this, false);
        _IsolatedWorld_contextBindings.set(this, /* @__PURE__ */ new Set());
        _IsolatedWorld_bindings.set(this, /* @__PURE__ */ new Map());
        _IsolatedWorld_taskManager.set(this, new WaitTask_js_1.TaskManager());
        _IsolatedWorld_mutex.set(this, new Mutex());
        _IsolatedWorld_onBindingCalled.set(this, async (event) => {
          let payload;
          try {
            payload = JSON.parse(event.payload);
          } catch {
            return;
          }
          const { type, name, seq, args, isTrivial } = payload;
          if (type !== "internal") {
            return;
          }
          if (!__classPrivateFieldGet(this, _IsolatedWorld_contextBindings, "f").has(name)) {
            return;
          }
          const context = await __classPrivateFieldGet(this, _IsolatedWorld_context, "f");
          if (event.executionContextId !== context._contextId) {
            return;
          }
          const binding = this._bindings.get(name);
          await (binding === null || binding === void 0 ? void 0 : binding.run(context, seq, args, isTrivial));
        });
        __classPrivateFieldSet(this, _IsolatedWorld_frame, frame, "f");
        __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).on("Runtime.bindingCalled", __classPrivateFieldGet(this, _IsolatedWorld_onBindingCalled, "f"));
      }
      frame() {
        return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f");
      }
      clearContext() {
        __classPrivateFieldSet(this, _IsolatedWorld_document, void 0, "f");
        __classPrivateFieldSet(this, _IsolatedWorld_context, (0, DeferredPromise_js_1.createDeferredPromise)(), "f");
      }
      setContext(context) {
        __classPrivateFieldGet(this, _IsolatedWorld_contextBindings, "f").clear();
        __classPrivateFieldGet(this, _IsolatedWorld_context, "f").resolve(context);
        void __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f").rerunAll();
      }
      hasContext() {
        return __classPrivateFieldGet(this, _IsolatedWorld_context, "f").resolved();
      }
      _detach() {
        __classPrivateFieldSet(this, _IsolatedWorld_detached, true, "f");
        __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).off("Runtime.bindingCalled", __classPrivateFieldGet(this, _IsolatedWorld_onBindingCalled, "f"));
        __classPrivateFieldGet(this, _IsolatedWorld_taskManager, "f").terminateAll(new Error("waitForFunction failed: frame got detached."));
      }
      executionContext() {
        if (__classPrivateFieldGet(this, _IsolatedWorld_detached, "f")) {
          throw new Error(`Execution context is not available in detached frame "${__classPrivateFieldGet(this, _IsolatedWorld_frame, "f").url()}" (are you trying to evaluate?)`);
        }
        if (__classPrivateFieldGet(this, _IsolatedWorld_context, "f") === null) {
          throw new Error(`Execution content promise is missing`);
        }
        return __classPrivateFieldGet(this, _IsolatedWorld_context, "f");
      }
      async evaluateHandle(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluateHandle(pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluate(pageFunction, ...args);
      }
      async $(selector) {
        const document2 = await this.document();
        return document2.$(selector);
      }
      async $$(selector) {
        const document2 = await this.document();
        return document2.$$(selector);
      }
      async document() {
        if (__classPrivateFieldGet(this, _IsolatedWorld_document, "f")) {
          return __classPrivateFieldGet(this, _IsolatedWorld_document, "f");
        }
        const context = await this.executionContext();
        __classPrivateFieldSet(this, _IsolatedWorld_document, await context.evaluateHandle(() => {
          return document;
        }), "f");
        return __classPrivateFieldGet(this, _IsolatedWorld_document, "f");
      }
      async $x(expression) {
        const document2 = await this.document();
        return document2.$x(expression);
      }
      async $eval(selector, pageFunction, ...args) {
        const document2 = await this.document();
        return document2.$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        const document2 = await this.document();
        return document2.$$eval(selector, pageFunction, ...args);
      }
      async content() {
        return await this.evaluate(() => {
          let retVal = "";
          if (document.doctype) {
            retVal = new XMLSerializer().serializeToString(document.doctype);
          }
          if (document.documentElement) {
            retVal += document.documentElement.outerHTML;
          }
          return retVal;
        });
      }
      async setContent(html, options = {}) {
        const { waitUntil = ["load"], timeout = __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).navigationTimeout() } = options;
        await (0, util_js_1.setPageContent)(this, html);
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(__classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get), __classPrivateFieldGet(this, _IsolatedWorld_frame, "f"), waitUntil, timeout);
        const error = await Promise.race([
          watcher.timeoutOrTerminationPromise(),
          watcher.lifecyclePromise()
        ]);
        watcher.dispose();
        if (error) {
          throw error;
        }
      }
      async click(selector, options = {}) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        await handle.click(options);
        await handle.dispose();
      }
      async focus(selector) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        await handle.focus();
        await handle.dispose();
      }
      async hover(selector) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        await handle.hover();
        await handle.dispose();
      }
      async select(selector, ...values) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        const result = await handle.select(...values);
        await handle.dispose();
        return result;
      }
      async tap(selector) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        await handle.tap();
        await handle.dispose();
      }
      async type(selector, text, options) {
        const handle = await this.$(selector);
        (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
        await handle.type(text, options);
        await handle.dispose();
      }
      async _addBindingToContext(context, name) {
        if (__classPrivateFieldGet(this, _IsolatedWorld_contextBindings, "f").has(name)) {
          return;
        }
        await __classPrivateFieldGet(this, _IsolatedWorld_mutex, "f").acquire();
        try {
          await context._client.send("Runtime.addBinding", {
            name,
            executionContextName: context._contextName
          });
          await context.evaluate(util_js_1.addPageBinding, "internal", name);
          __classPrivateFieldGet(this, _IsolatedWorld_contextBindings, "f").add(name);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.includes("Execution context was destroyed")) {
              return;
            }
            if (error.message.includes("Cannot find context with specified id")) {
              return;
            }
          }
          (0, util_js_1.debugError)(error);
        } finally {
          __classPrivateFieldGet(this, _IsolatedWorld_mutex, "f").release();
        }
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = "raf", timeout = __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).timeout(), root, signal } = options;
        if (typeof polling === "number" && polling < 0) {
          throw new Error("Cannot poll with non-positive interval");
        }
        const waitTask = new WaitTask_js_1.WaitTask(this, {
          polling,
          root,
          timeout,
          signal
        }, pageFunction, ...args);
        return waitTask.result;
      }
      async title() {
        return this.evaluate(() => {
          return document.title;
        });
      }
      async adoptBackendNode(backendNodeId) {
        const executionContext = await this.executionContext();
        const { object } = await __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.resolveNode", {
          backendNodeId,
          executionContextId: executionContext._contextId
        });
        return (0, util_js_1.createJSHandle)(executionContext, object);
      }
      async adoptHandle(handle) {
        const context = await this.executionContext();
        (0, assert_js_1.assert)(handle.executionContext() !== context, "Cannot adopt handle that already belongs to this execution context");
        const nodeInfo = await __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.describeNode", {
          objectId: handle.id
        });
        return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
      }
      async transferHandle(handle) {
        const context = await this.executionContext();
        if (handle.executionContext() === context) {
          return handle;
        }
        const info = await __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.describeNode", {
          objectId: handle.remoteObject().objectId
        });
        const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
        await handle.dispose();
        return newHandle;
      }
    };
    exports2.IsolatedWorld = IsolatedWorld;
    _IsolatedWorld_frame = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_document = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_context = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_detached = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_contextBindings = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_bindings = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_taskManager = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_mutex = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_onBindingCalled = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_instances = /* @__PURE__ */ new WeakSet(), _IsolatedWorld_client_get = function _IsolatedWorld_client_get2() {
      return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f")._client();
    }, _IsolatedWorld_frameManager_get = function _IsolatedWorld_frameManager_get2() {
      return __classPrivateFieldGet(this, _IsolatedWorld_frame, "f")._frameManager;
    }, _IsolatedWorld_timeoutSettings_get = function _IsolatedWorld_timeoutSettings_get2() {
      return __classPrivateFieldGet(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get).timeoutSettings;
    };
    var Mutex = class {
      constructor() {
        _Mutex_locked.set(this, false);
        _Mutex_acquirers.set(this, []);
      }
      // This is FIFO.
      acquire() {
        if (!__classPrivateFieldGet(this, _Mutex_locked, "f")) {
          __classPrivateFieldSet(this, _Mutex_locked, true, "f");
          return Promise.resolve();
        }
        let resolve;
        const promise = new Promise((res) => {
          resolve = res;
        });
        __classPrivateFieldGet(this, _Mutex_acquirers, "f").push(resolve);
        return promise;
      }
      release() {
        const resolve = __classPrivateFieldGet(this, _Mutex_acquirers, "f").shift();
        if (!resolve) {
          __classPrivateFieldSet(this, _Mutex_locked, false, "f");
          return;
        }
        resolve();
      }
    };
    _Mutex_locked = /* @__PURE__ */ new WeakMap(), _Mutex_acquirers = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Frame.js
var require_Frame = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Frame.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Frame_url;
    var _Frame_detached;
    var _Frame_client;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Frame = void 0;
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var GetQueryHandler_js_1 = require_GetQueryHandler();
    var IsolatedWorld_js_1 = require_IsolatedWorld();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var LazyArg_js_1 = require_LazyArg();
    var LifecycleWatcher_js_1 = require_LifecycleWatcher();
    var util_js_1 = require_util2();
    var Frame = class {
      /**
       * @internal
       */
      constructor(frameManager, frameId, parentFrameId, client) {
        _Frame_url.set(this, "");
        _Frame_detached.set(this, false);
        _Frame_client.set(this, void 0);
        this._loaderId = "";
        this._hasStartedLoading = false;
        this._lifecycleEvents = /* @__PURE__ */ new Set();
        this._frameManager = frameManager;
        __classPrivateFieldSet(this, _Frame_url, "", "f");
        this._id = frameId;
        this._parentId = parentFrameId;
        __classPrivateFieldSet(this, _Frame_detached, false, "f");
        this._loaderId = "";
        this.updateClient(client);
      }
      /**
       * @internal
       */
      updateClient(client) {
        __classPrivateFieldSet(this, _Frame_client, client, "f");
        this.worlds = {
          [IsolatedWorlds_js_1.MAIN_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this),
          [IsolatedWorlds_js_1.PUPPETEER_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this)
        };
      }
      /**
       * The page associated with the frame.
       */
      page() {
        return this._frameManager.page();
      }
      /**
       * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,
       * `false`.
       */
      isOOPFrame() {
        return __classPrivateFieldGet(this, _Frame_client, "f") !== this._frameManager.client;
      }
      /**
       * Navigates a frame to the given url.
       *
       * @remarks
       * Navigation to `about:blank` or navigation to the same URL with a different
       * hash will succeed and return `null`.
       *
       * :::warning
       *
       * Headless mode doesn't support navigation to a PDF document. See the {@link
       * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
       * issue}.
       *
       * :::
       *
       * @param url - the URL to navigate the frame to. This should include the
       * scheme, e.g. `https://`.
       * @param options - navigation options. `waitUntil` is useful to define when
       * the navigation should be considered successful - see the docs for
       * {@link PuppeteerLifeCycleEvent} for more details.
       *
       * @returns A promise which resolves to the main resource response. In case of
       * multiple redirects, the navigation will resolve with the response of the
       * last redirect.
       * @throws This method will throw an error if:
       *
       * - there's an SSL error (e.g. in case of self-signed certificates).
       * - target URL is invalid.
       * - the `timeout` is exceeded during navigation.
       * - the remote server does not respond or is unreachable.
       * - the main resource failed to load.
       *
       * This method will not throw an error when any valid HTTP status code is
       * returned by the remote server, including 404 "Not Found" and 500 "Internal
       * Server Error". The status code for such responses can be retrieved by
       * calling {@link HTTPResponse.status}.
       */
      async goto(url, options = {}) {
        const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        let ensureNewDocumentNavigation = false;
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
        let error = await Promise.race([
          navigate(__classPrivateFieldGet(this, _Frame_client, "f"), url, referer, referrerPolicy, this._id),
          watcher.timeoutOrTerminationPromise()
        ]);
        if (!error) {
          error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
          ]);
        }
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
        async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
          try {
            const response = await client.send("Page.navigate", {
              url: url2,
              referrer,
              frameId,
              referrerPolicy: referrerPolicy2
            });
            ensureNewDocumentNavigation = !!response.loaderId;
            if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
              return null;
            }
            return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
          } catch (error2) {
            if ((0, ErrorLike_js_1.isErrorLike)(error2)) {
              return error2;
            }
            throw error2;
          }
        }
      }
      /**
       * Waits for the frame to navigate. It is useful for when you run code which
       * will indirectly cause the frame to navigate.
       *
       * Usage of the
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
       * to change the URL is considered a navigation.
       *
       * @example
       *
       * ```ts
       * const [response] = await Promise.all([
       *   // The navigation promise resolves after navigation has finished
       *   frame.waitForNavigation(),
       *   // Clicking the link will indirectly cause a navigation
       *   frame.click('a.my-link'),
       * ]);
       * ```
       *
       * @param options - options to configure when the navigation is consided
       * finished.
       * @returns a promise that resolves when the frame navigates to a new URL.
       */
      async waitForNavigation(options = {}) {
        const { waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
        const error = await Promise.race([
          watcher.timeoutOrTerminationPromise(),
          watcher.sameDocumentNavigationPromise(),
          watcher.newDocumentNavigationPromise()
        ]);
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
      }
      /**
       * @internal
       */
      _client() {
        return __classPrivateFieldGet(this, _Frame_client, "f");
      }
      /**
       * @internal
       */
      executionContext() {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].executionContext();
      }
      /**
       * Behaves identically to {@link Page.evaluateHandle} except it's run within
       * the context of this frame.
       *
       * @see {@link Page.evaluateHandle} for details.
       */
      async evaluateHandle(pageFunction, ...args) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].evaluateHandle(pageFunction, ...args);
      }
      /**
       * Behaves identically to {@link Page.evaluate} except it's run within the
       * the context of this frame.
       *
       * @see {@link Page.evaluate} for details.
       */
      async evaluate(pageFunction, ...args) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].evaluate(pageFunction, ...args);
      }
      /**
       * Queries the frame for an element matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns A {@link ElementHandle | element handle} to the first element
       * matching the given selector. Otherwise, `null`.
       */
      async $(selector) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].$(selector);
      }
      /**
       * Queries the frame for all elements matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns An array of {@link ElementHandle | element handles} that point to
       * elements matching the given selector.
       */
      async $$(selector) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].$$(selector);
      }
      /**
       * Runs the given function on the first element matching the given selector in
       * the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const searchValue = await frame.$eval('#search', el => el.value);
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * The first element matching the selector will be passed to the function as
       * its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $eval(selector, pageFunction, ...args) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].$eval(selector, pageFunction, ...args);
      }
      /**
       * Runs the given function on an array of elements matching the given selector
       * in the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```js
       * const divsCounts = await frame.$$eval('div', divs => divs.length);
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * An array of elements matching the given selector will be passed to the
       * function as its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $$eval(selector, pageFunction, ...args) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].$$eval(selector, pageFunction, ...args);
      }
      /**
       * @deprecated Use {@link Frame.$$} with the `xpath` prefix.
       *
       * Example: `await frame.$$('xpath/' + xpathExpression)`
       *
       * This method evaluates the given XPath expression and returns the results.
       * If `xpath` starts with `//` instead of `.//`, the dot will be appended
       * automatically.
       * @param expression - the XPath expression to evaluate.
       */
      async $x(expression) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].$x(expression);
      }
      /**
       * Waits for an element matching the given selector to appear in the frame.
       *
       * This method works across navigations.
       *
       * @example
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .mainFrame()
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - The selector to query and wait for.
       * @param options - Options for customizing waiting behavior.
       * @returns An element matching the given selector.
       * @throws Throws if an element matching the given selector doesn't appear.
       */
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
        return await QueryHandler.waitFor(this, updatedSelector, options);
      }
      /**
       * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.
       *
       * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`
       *
       * The method evaluates the XPath expression relative to the Frame.
       * If `xpath` starts with `//` instead of `.//`, the dot will be appended
       * automatically.
       *
       * Wait for the `xpath` to appear in page. If at the moment of calling the
       * method the `xpath` already exists, the method will return immediately. If
       * the xpath doesn't appear after the `timeout` milliseconds of waiting, the
       * function will throw.
       *
       * For a code example, see the example for {@link Frame.waitForSelector}. That
       * function behaves identically other than taking a CSS selector rather than
       * an XPath.
       *
       * @param xpath - the XPath expression to wait for.
       * @param options - options to configure the visibility of the element and how
       * long to wait before timing out.
       */
      async waitForXPath(xpath, options = {}) {
        if (xpath.startsWith("//")) {
          xpath = `.${xpath}`;
        }
        return this.waitForSelector(`xpath/${xpath}`, options);
      }
      /**
       * @example
       * The `waitForFunction` can be used to observe viewport size change:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       * .  const browser = await puppeteer.launch();
       * .  const page = await browser.newPage();
       * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
       * .  page.setViewport({width: 50, height: 50});
       * .  await watchDog;
       * .  await browser.close();
       * })();
       * ```
       *
       * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
       *
       * ```ts
       * const selector = '.foo';
       * await frame.waitForFunction(
       *   selector => !!document.querySelector(selector),
       *   {}, // empty options object
       *   selector
       * );
       * ```
       *
       * @param pageFunction - the function to evaluate in the frame context.
       * @param options - options to configure the polling method and timeout.
       * @param args - arguments to pass to the `pageFunction`.
       * @returns the promise which resolve when the `pageFunction` returns a truthy value.
       */
      waitForFunction(pageFunction, options = {}, ...args) {
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].waitForFunction(pageFunction, options, ...args);
      }
      /**
       * The full HTML contents of the frame, including the DOCTYPE.
       */
      async content() {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].content();
      }
      /**
       * Set the content of the frame.
       *
       * @param html - HTML markup to assign to the page.
       * @param options - Options to configure how long before timing out and at
       * what point to consider the content setting successful.
       */
      async setContent(html, options = {}) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].setContent(html, options);
      }
      /**
       * The frame's `name` attribute as specified in the tag.
       *
       * @remarks
       * If the name is empty, it returns the `id` attribute instead.
       *
       * @remarks
       * This value is calculated once when the frame is created, and will not
       * update if the attribute is changed later.
       */
      name() {
        return this._name || "";
      }
      /**
       * The frame's URL.
       */
      url() {
        return __classPrivateFieldGet(this, _Frame_url, "f");
      }
      /**
       * The parent frame, if any. Detached and main frames return `null`.
       */
      parentFrame() {
        return this._frameManager._frameTree.parentFrame(this._id) || null;
      }
      /**
       * An array of child frames.
       */
      childFrames() {
        return this._frameManager._frameTree.childFrames(this._id);
      }
      /**
       * Is`true` if the frame has been detached. Otherwise, `false`.
       */
      isDetached() {
        return __classPrivateFieldGet(this, _Frame_detached, "f");
      }
      /**
       * Adds a `<script>` tag into the page with the desired url or content.
       *
       * @param options - Options for the script.
       * @returns An {@link ElementHandle | element handle} to the injected
       * `<script>` element.
       */
      async addScriptTag(options) {
        let { content = "", type } = options;
        const { path } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path) {
          const fs = await (0, util_js_1.importFSPromises)();
          content = await fs.readFile(path, "utf8");
          content += `//# sourceURL=${path.replace(/\n/g, "")}`;
        }
        type = type !== null && type !== void 0 ? type : "text/javascript";
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].transferHandle(await this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].evaluateHandle(async ({ createDeferredPromise }, { url, id, type: type2, content: content2 }) => {
          const promise = createDeferredPromise();
          const script = document.createElement("script");
          script.type = type2;
          script.text = content2;
          if (url) {
            script.src = url;
            script.addEventListener("load", () => {
              return promise.resolve();
            }, { once: true });
            script.addEventListener("error", (event) => {
              var _a;
              promise.reject(new Error((_a = event.message) !== null && _a !== void 0 ? _a : "Could not load script"));
            }, { once: true });
          } else {
            promise.resolve();
          }
          if (id) {
            script.id = id;
          }
          document.head.appendChild(script);
          await promise;
          return script;
        }, LazyArg_js_1.LazyArg.create((context) => {
          return context.puppeteerUtil;
        }), { ...options, type, content }));
      }
      async addStyleTag(options) {
        let { content = "" } = options;
        const { path } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path) {
          const fs = await (0, util_js_1.importFSPromises)();
          content = await fs.readFile(path, "utf8");
          content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
          options.content = content;
        }
        return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].transferHandle(await this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].evaluateHandle(async ({ createDeferredPromise }, { url, content: content2 }) => {
          const promise = createDeferredPromise();
          let element;
          if (!url) {
            element = document.createElement("style");
            element.appendChild(document.createTextNode(content2));
          } else {
            const link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = url;
            element = link;
          }
          element.addEventListener("load", () => {
            promise.resolve();
          }, { once: true });
          element.addEventListener("error", (event) => {
            var _a;
            promise.reject(new Error((_a = event.message) !== null && _a !== void 0 ? _a : "Could not load style"));
          }, { once: true });
          document.head.appendChild(element);
          await promise;
          return element;
        }, LazyArg_js_1.LazyArg.create((context) => {
          return context.puppeteerUtil;
        }), options));
      }
      /**
       * Clicks the first element found that matches `selector`.
       *
       * @remarks
       * If `click()` triggers a navigation event and there's a separate
       * `page.waitForNavigation()` promise to be resolved, you may end up with a
       * race condition that yields unexpected results. The correct pattern for
       * click and wait for navigation is the following:
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(waitOptions),
       *   frame.click(selector, clickOptions),
       * ]);
       * ```
       *
       * @param selector - The selector to query for.
       */
      async click(selector, options = {}) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].click(selector, options);
      }
      /**
       * Focuses the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async focus(selector) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].focus(selector);
      }
      /**
       * Hovers the pointer over the center of the first element that matches the
       * `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async hover(selector) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].hover(selector);
      }
      /**
       * Selects a set of value on the first `<select>` element that matches the
       * `selector`.
       *
       * @example
       *
       * ```ts
       * frame.select('select#colors', 'blue'); // single selection
       * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param selector - The selector to query for.
       * @param values - The array of values to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first
       * one is taken into account.
       * @returns the list of values that were successfully selected.
       * @throws Throws if there's no `<select>` matching `selector`.
       */
      select(selector, ...values) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].select(selector, ...values);
      }
      /**
       * Taps the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async tap(selector) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].tap(selector);
      }
      /**
       * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
       * in the text.
       *
       * @remarks
       * To press a special key, like `Control` or `ArrowDown`, use
       * {@link Keyboard.press}.
       *
       * @example
       *
       * ```ts
       * await frame.type('#mytextarea', 'Hello'); // Types instantly
       * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @param selector - the selector for the element to type into. If there are
       * multiple the first will be used.
       * @param text - text to type into the element
       * @param options - takes one option, `delay`, which sets the time to wait
       * between key presses in milliseconds. Defaults to `0`.
       */
      async type(selector, text, options) {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].type(selector, text, options);
      }
      /**
       * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.
       *
       * Causes your script to wait for the given number of milliseconds.
       *
       * @remarks
       * It's generally recommended to not wait for a number of seconds, but instead
       * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
       * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
       *
       * @example
       *
       * Wait for 1 second:
       *
       * ```ts
       * await frame.waitForTimeout(1000);
       * ```
       *
       * @param milliseconds - the number of milliseconds to wait.
       */
      waitForTimeout(milliseconds) {
        return new Promise((resolve) => {
          setTimeout(resolve, milliseconds);
        });
      }
      /**
       * The frame's title.
       */
      async title() {
        return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].title();
      }
      /**
       * @internal
       */
      _deviceRequestPromptManager() {
        if (this.isOOPFrame()) {
          return this._frameManager._deviceRequestPromptManager(__classPrivateFieldGet(this, _Frame_client, "f"));
        }
        const parentFrame = this.parentFrame();
        (0, assert_js_1.assert)(parentFrame !== null);
        return parentFrame._deviceRequestPromptManager();
      }
      /**
       * This method is typically coupled with an action that triggers a device
       * request from an api such as WebBluetooth.
       *
       * :::caution
       *
       * This must be called before the device request is made. It will not return a
       * currently active device prompt.
       *
       * :::
       *
       * @example
       *
       * ```ts
       * const [devicePrompt] = Promise.all([
       *   frame.waitForDevicePrompt(),
       *   frame.click('#connect-bluetooth'),
       * ]);
       * await devicePrompt.select(
       *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
       * );
       * ```
       */
      waitForDevicePrompt(options = {}) {
        return this._deviceRequestPromptManager().waitForDevicePrompt(options);
      }
      /**
       * @internal
       */
      _navigated(framePayload) {
        this._name = framePayload.name;
        __classPrivateFieldSet(this, _Frame_url, `${framePayload.url}${framePayload.urlFragment || ""}`, "f");
      }
      /**
       * @internal
       */
      _navigatedWithinDocument(url) {
        __classPrivateFieldSet(this, _Frame_url, url, "f");
      }
      /**
       * @internal
       */
      _onLifecycleEvent(loaderId, name) {
        if (name === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
      }
      /**
       * @internal
       */
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      /**
       * @internal
       */
      _onLoadingStarted() {
        this._hasStartedLoading = true;
      }
      /**
       * @internal
       */
      _detach() {
        __classPrivateFieldSet(this, _Frame_detached, true, "f");
        this.worlds[IsolatedWorlds_js_1.MAIN_WORLD]._detach();
        this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD]._detach();
      }
    };
    exports2.Frame = Frame;
    _Frame_url = /* @__PURE__ */ new WeakMap(), _Frame_detached = /* @__PURE__ */ new WeakMap(), _Frame_client = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameTree.js
var require_FrameTree = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameTree.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _FrameTree_frames;
    var _FrameTree_parentIds;
    var _FrameTree_childIds;
    var _FrameTree_mainFrame;
    var _FrameTree_waitRequests;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FrameTree = void 0;
    var DeferredPromise_js_1 = require_DeferredPromise();
    var FrameTree = class {
      constructor() {
        _FrameTree_frames.set(this, /* @__PURE__ */ new Map());
        _FrameTree_parentIds.set(this, /* @__PURE__ */ new Map());
        _FrameTree_childIds.set(this, /* @__PURE__ */ new Map());
        _FrameTree_mainFrame.set(this, void 0);
        _FrameTree_waitRequests.set(this, /* @__PURE__ */ new Map());
      }
      getMainFrame() {
        return __classPrivateFieldGet(this, _FrameTree_mainFrame, "f");
      }
      getById(frameId) {
        return __classPrivateFieldGet(this, _FrameTree_frames, "f").get(frameId);
      }
      /**
       * Returns a promise that is resolved once the frame with
       * the given ID is added to the tree.
       */
      waitForFrame(frameId) {
        const frame = this.getById(frameId);
        if (frame) {
          return Promise.resolve(frame);
        }
        const deferred = (0, DeferredPromise_js_1.createDeferredPromise)();
        const callbacks = __classPrivateFieldGet(this, _FrameTree_waitRequests, "f").get(frameId) || /* @__PURE__ */ new Set();
        callbacks.add(deferred);
        return deferred;
      }
      frames() {
        return Array.from(__classPrivateFieldGet(this, _FrameTree_frames, "f").values());
      }
      addFrame(frame) {
        var _a;
        __classPrivateFieldGet(this, _FrameTree_frames, "f").set(frame._id, frame);
        if (frame._parentId) {
          __classPrivateFieldGet(this, _FrameTree_parentIds, "f").set(frame._id, frame._parentId);
          if (!__classPrivateFieldGet(this, _FrameTree_childIds, "f").has(frame._parentId)) {
            __classPrivateFieldGet(this, _FrameTree_childIds, "f").set(frame._parentId, /* @__PURE__ */ new Set());
          }
          __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frame._parentId).add(frame._id);
        } else {
          __classPrivateFieldSet(this, _FrameTree_mainFrame, frame, "f");
        }
        (_a = __classPrivateFieldGet(this, _FrameTree_waitRequests, "f").get(frame._id)) === null || _a === void 0 ? void 0 : _a.forEach((request) => {
          return request.resolve(frame);
        });
      }
      removeFrame(frame) {
        var _a;
        __classPrivateFieldGet(this, _FrameTree_frames, "f").delete(frame._id);
        __classPrivateFieldGet(this, _FrameTree_parentIds, "f").delete(frame._id);
        if (frame._parentId) {
          (_a = __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frame._parentId)) === null || _a === void 0 ? void 0 : _a.delete(frame._id);
        } else {
          __classPrivateFieldSet(this, _FrameTree_mainFrame, void 0, "f");
        }
      }
      childFrames(frameId) {
        const childIds = __classPrivateFieldGet(this, _FrameTree_childIds, "f").get(frameId);
        if (!childIds) {
          return [];
        }
        return Array.from(childIds).map((id) => {
          return this.getById(id);
        }).filter((frame) => {
          return frame !== void 0;
        });
      }
      parentFrame(frameId) {
        const parentId = __classPrivateFieldGet(this, _FrameTree_parentIds, "f").get(frameId);
        return parentId ? this.getById(parentId) : void 0;
      }
    };
    exports2.FrameTree = FrameTree;
    _FrameTree_frames = /* @__PURE__ */ new WeakMap(), _FrameTree_parentIds = /* @__PURE__ */ new WeakMap(), _FrameTree_childIds = /* @__PURE__ */ new WeakMap(), _FrameTree_mainFrame = /* @__PURE__ */ new WeakMap(), _FrameTree_waitRequests = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameManager.js
var require_FrameManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/FrameManager.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _FrameManager_instances;
    var _FrameManager_page;
    var _FrameManager_networkManager;
    var _FrameManager_timeoutSettings;
    var _FrameManager_contextIdToContext;
    var _FrameManager_isolatedWorlds;
    var _FrameManager_client;
    var _FrameManager_frameNavigatedReceived;
    var _FrameManager_deviceRequestPromptManagerMap;
    var _FrameManager_onLifecycleEvent;
    var _FrameManager_onFrameStartedLoading;
    var _FrameManager_onFrameStoppedLoading;
    var _FrameManager_handleFrameTree;
    var _FrameManager_onFrameAttached;
    var _FrameManager_onFrameNavigated;
    var _FrameManager_createIsolatedWorld;
    var _FrameManager_onFrameNavigatedWithinDocument;
    var _FrameManager_onFrameDetached;
    var _FrameManager_onExecutionContextCreated;
    var _FrameManager_onExecutionContextDestroyed;
    var _FrameManager_onExecutionContextsCleared;
    var _FrameManager_removeFramesRecursively;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FrameManager = exports2.FrameManagerEmittedEvents = void 0;
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var Connection_js_1 = require_Connection();
    var DeviceRequestPrompt_js_1 = require_DeviceRequestPrompt();
    var EventEmitter_js_1 = require_EventEmitter();
    var ExecutionContext_js_1 = require_ExecutionContext();
    var Frame_js_1 = require_Frame();
    var FrameTree_js_1 = require_FrameTree();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var NetworkManager_js_1 = require_NetworkManager();
    var util_js_1 = require_util2();
    var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
    exports2.FrameManagerEmittedEvents = {
      FrameAttached: Symbol("FrameManager.FrameAttached"),
      FrameNavigated: Symbol("FrameManager.FrameNavigated"),
      FrameDetached: Symbol("FrameManager.FrameDetached"),
      FrameSwapped: Symbol("FrameManager.FrameSwapped"),
      LifecycleEvent: Symbol("FrameManager.LifecycleEvent"),
      FrameNavigatedWithinDocument: Symbol("FrameManager.FrameNavigatedWithinDocument"),
      ExecutionContextCreated: Symbol("FrameManager.ExecutionContextCreated"),
      ExecutionContextDestroyed: Symbol("FrameManager.ExecutionContextDestroyed")
    };
    var FrameManager = class extends EventEmitter_js_1.EventEmitter {
      get timeoutSettings() {
        return __classPrivateFieldGet(this, _FrameManager_timeoutSettings, "f");
      }
      get networkManager() {
        return __classPrivateFieldGet(this, _FrameManager_networkManager, "f");
      }
      get client() {
        return __classPrivateFieldGet(this, _FrameManager_client, "f");
      }
      constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
        super();
        _FrameManager_instances.add(this);
        _FrameManager_page.set(this, void 0);
        _FrameManager_networkManager.set(this, void 0);
        _FrameManager_timeoutSettings.set(this, void 0);
        _FrameManager_contextIdToContext.set(this, /* @__PURE__ */ new Map());
        _FrameManager_isolatedWorlds.set(this, /* @__PURE__ */ new Set());
        _FrameManager_client.set(this, void 0);
        this._frameTree = new FrameTree_js_1.FrameTree();
        _FrameManager_frameNavigatedReceived.set(this, /* @__PURE__ */ new Set());
        _FrameManager_deviceRequestPromptManagerMap.set(this, /* @__PURE__ */ new WeakMap());
        __classPrivateFieldSet(this, _FrameManager_client, client, "f");
        __classPrivateFieldSet(this, _FrameManager_page, page, "f");
        __classPrivateFieldSet(this, _FrameManager_networkManager, new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this), "f");
        __classPrivateFieldSet(this, _FrameManager_timeoutSettings, timeoutSettings, "f");
        this.setupEventListeners(__classPrivateFieldGet(this, _FrameManager_client, "f"));
      }
      setupEventListeners(session) {
        session.on("Page.frameAttached", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, event.frameId, event.parentFrameId);
        });
        session.on("Page.frameNavigated", (event) => {
          __classPrivateFieldGet(this, _FrameManager_frameNavigatedReceived, "f").add(event.frame.id);
          void __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, event.frame);
        });
        session.on("Page.navigatedWithinDocument", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigatedWithinDocument).call(this, event.frameId, event.url);
        });
        session.on("Page.frameDetached", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameDetached).call(this, event.frameId, event.reason);
        });
        session.on("Page.frameStartedLoading", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameStartedLoading).call(this, event.frameId);
        });
        session.on("Page.frameStoppedLoading", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameStoppedLoading).call(this, event.frameId);
        });
        session.on("Runtime.executionContextCreated", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextCreated).call(this, event.context, session);
        });
        session.on("Runtime.executionContextDestroyed", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextDestroyed).call(this, event.executionContextId, session);
        });
        session.on("Runtime.executionContextsCleared", () => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextsCleared).call(this, session);
        });
        session.on("Page.lifecycleEvent", (event) => {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onLifecycleEvent).call(this, event);
        });
      }
      async initialize(client = __classPrivateFieldGet(this, _FrameManager_client, "f")) {
        try {
          const result = await Promise.all([
            client.send("Page.enable"),
            client.send("Page.getFrameTree")
          ]);
          const { frameTree } = result[1];
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree).call(this, client, frameTree);
          await Promise.all([
            client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
            client.send("Runtime.enable").then(() => {
              return __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
            }),
            // TODO: Network manager is not aware of OOP iframes yet.
            client === __classPrivateFieldGet(this, _FrameManager_client, "f") ? __classPrivateFieldGet(this, _FrameManager_networkManager, "f").initialize() : Promise.resolve()
          ]);
        } catch (error) {
          if ((0, ErrorLike_js_1.isErrorLike)(error) && (0, Connection_js_1.isTargetClosedError)(error)) {
            return;
          }
          throw error;
        }
      }
      executionContextById(contextId, session = __classPrivateFieldGet(this, _FrameManager_client, "f")) {
        const context = this.getExecutionContextById(contextId, session);
        (0, assert_js_1.assert)(context, "INTERNAL ERROR: missing context with id = " + contextId);
        return context;
      }
      getExecutionContextById(contextId, session = __classPrivateFieldGet(this, _FrameManager_client, "f")) {
        return __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").get(`${session.id()}:${contextId}`);
      }
      page() {
        return __classPrivateFieldGet(this, _FrameManager_page, "f");
      }
      mainFrame() {
        const mainFrame = this._frameTree.getMainFrame();
        (0, assert_js_1.assert)(mainFrame, "Requesting main frame too early!");
        return mainFrame;
      }
      frames() {
        return Array.from(this._frameTree.frames());
      }
      frame(frameId) {
        return this._frameTree.getById(frameId) || null;
      }
      onAttachedToTarget(target) {
        if (target._getTargetInfo().type !== "iframe") {
          return;
        }
        const frame = this.frame(target._getTargetInfo().targetId);
        if (frame) {
          frame.updateClient(target._session());
        }
        this.setupEventListeners(target._session());
        void this.initialize(target._session());
      }
      /**
       * @internal
       */
      _deviceRequestPromptManager(client) {
        let manager = __classPrivateFieldGet(this, _FrameManager_deviceRequestPromptManagerMap, "f").get(client);
        if (manager === void 0) {
          manager = new DeviceRequestPrompt_js_1.DeviceRequestPromptManager(client, __classPrivateFieldGet(this, _FrameManager_timeoutSettings, "f"));
          __classPrivateFieldGet(this, _FrameManager_deviceRequestPromptManagerMap, "f").set(client, manager);
        }
        return manager;
      }
    };
    exports2.FrameManager = FrameManager;
    _FrameManager_page = /* @__PURE__ */ new WeakMap(), _FrameManager_networkManager = /* @__PURE__ */ new WeakMap(), _FrameManager_timeoutSettings = /* @__PURE__ */ new WeakMap(), _FrameManager_contextIdToContext = /* @__PURE__ */ new WeakMap(), _FrameManager_isolatedWorlds = /* @__PURE__ */ new WeakMap(), _FrameManager_client = /* @__PURE__ */ new WeakMap(), _FrameManager_frameNavigatedReceived = /* @__PURE__ */ new WeakMap(), _FrameManager_deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap(), _FrameManager_instances = /* @__PURE__ */ new WeakSet(), _FrameManager_onLifecycleEvent = function _FrameManager_onLifecycleEvent2(event) {
      const frame = this.frame(event.frameId);
      if (!frame) {
        return;
      }
      frame._onLifecycleEvent(event.loaderId, event.name);
      this.emit(exports2.FrameManagerEmittedEvents.LifecycleEvent, frame);
    }, _FrameManager_onFrameStartedLoading = function _FrameManager_onFrameStartedLoading2(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStarted();
    }, _FrameManager_onFrameStoppedLoading = function _FrameManager_onFrameStoppedLoading2(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStopped();
      this.emit(exports2.FrameManagerEmittedEvents.LifecycleEvent, frame);
    }, _FrameManager_handleFrameTree = function _FrameManager_handleFrameTree2(session, frameTree) {
      if (frameTree.frame.parentId) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
      }
      if (!__classPrivateFieldGet(this, _FrameManager_frameNavigatedReceived, "f").has(frameTree.frame.id)) {
        void __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, frameTree.frame);
      } else {
        __classPrivateFieldGet(this, _FrameManager_frameNavigatedReceived, "f").delete(frameTree.frame.id);
      }
      if (!frameTree.childFrames) {
        return;
      }
      for (const child of frameTree.childFrames) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree2).call(this, session, child);
      }
    }, _FrameManager_onFrameAttached = function _FrameManager_onFrameAttached2(session, frameId, parentFrameId) {
      let frame = this.frame(frameId);
      if (frame) {
        if (session && frame.isOOPFrame()) {
          frame.updateClient(session);
        }
        return;
      }
      frame = new Frame_js_1.Frame(this, frameId, parentFrameId, session);
      this._frameTree.addFrame(frame);
      this.emit(exports2.FrameManagerEmittedEvents.FrameAttached, frame);
    }, _FrameManager_onFrameNavigated = async function _FrameManager_onFrameNavigated2(framePayload) {
      const frameId = framePayload.id;
      const isMainFrame = !framePayload.parentId;
      let frame = this._frameTree.getById(frameId);
      if (frame) {
        for (const child of frame.childFrames()) {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, child);
        }
      }
      if (isMainFrame) {
        if (frame) {
          this._frameTree.removeFrame(frame);
          frame._id = frameId;
        } else {
          frame = new Frame_js_1.Frame(this, frameId, void 0, __classPrivateFieldGet(this, _FrameManager_client, "f"));
        }
        this._frameTree.addFrame(frame);
      }
      frame = await this._frameTree.waitForFrame(frameId);
      frame._navigated(framePayload);
      this.emit(exports2.FrameManagerEmittedEvents.FrameNavigated, frame);
    }, _FrameManager_createIsolatedWorld = async function _FrameManager_createIsolatedWorld2(session, name) {
      const key = `${session.id()}:${name}`;
      if (__classPrivateFieldGet(this, _FrameManager_isolatedWorlds, "f").has(key)) {
        return;
      }
      await session.send("Page.addScriptToEvaluateOnNewDocument", {
        source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,
        worldName: name
      });
      await Promise.all(this.frames().filter((frame) => {
        return frame._client() === session;
      }).map((frame) => {
        return session.send("Page.createIsolatedWorld", {
          frameId: frame._id,
          worldName: name,
          grantUniveralAccess: true
        }).catch(util_js_1.debugError);
      }));
      __classPrivateFieldGet(this, _FrameManager_isolatedWorlds, "f").add(key);
    }, _FrameManager_onFrameNavigatedWithinDocument = function _FrameManager_onFrameNavigatedWithinDocument2(frameId, url) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._navigatedWithinDocument(url);
      this.emit(exports2.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
      this.emit(exports2.FrameManagerEmittedEvents.FrameNavigated, frame);
    }, _FrameManager_onFrameDetached = function _FrameManager_onFrameDetached2(frameId, reason) {
      const frame = this.frame(frameId);
      if (reason === "remove") {
        if (frame) {
          __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, frame);
        }
      } else if (reason === "swap") {
        this.emit(exports2.FrameManagerEmittedEvents.FrameSwapped, frame);
      }
    }, _FrameManager_onExecutionContextCreated = function _FrameManager_onExecutionContextCreated2(contextPayload, session) {
      const auxData = contextPayload.auxData;
      const frameId = auxData && auxData.frameId;
      const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
      let world;
      if (frame) {
        if (frame._client() !== session) {
          return;
        }
        if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
          world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
        } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].hasContext()) {
          world = frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD];
        }
      }
      const context = new ExecutionContext_js_1.ExecutionContext((frame === null || frame === void 0 ? void 0 : frame._client()) || __classPrivateFieldGet(this, _FrameManager_client, "f"), contextPayload, world);
      if (world) {
        world.setContext(context);
      }
      const key = `${session.id()}:${contextPayload.id}`;
      __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").set(key, context);
    }, _FrameManager_onExecutionContextDestroyed = function _FrameManager_onExecutionContextDestroyed2(executionContextId, session) {
      const key = `${session.id()}:${executionContextId}`;
      const context = __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").get(key);
      if (!context) {
        return;
      }
      __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").delete(key);
      if (context._world) {
        context._world.clearContext();
      }
    }, _FrameManager_onExecutionContextsCleared = function _FrameManager_onExecutionContextsCleared2(session) {
      for (const [key, context] of __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").entries()) {
        if (context._client !== session) {
          continue;
        }
        if (context._world) {
          context._world.clearContext();
        }
        __classPrivateFieldGet(this, _FrameManager_contextIdToContext, "f").delete(key);
      }
    }, _FrameManager_removeFramesRecursively = function _FrameManager_removeFramesRecursively2(frame) {
      for (const child of frame.childFrames()) {
        __classPrivateFieldGet(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively2).call(this, child);
      }
      frame._detach();
      this._frameTree.removeFrame(frame);
      this.emit(exports2.FrameManagerEmittedEvents.FrameDetached, frame);
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/USKeyboardLayout.js
var require_USKeyboardLayout = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/USKeyboardLayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._keyDefinitions = void 0;
    exports2._keyDefinitions = {
      "0": { keyCode: 48, key: "0", code: "Digit0" },
      "1": { keyCode: 49, key: "1", code: "Digit1" },
      "2": { keyCode: 50, key: "2", code: "Digit2" },
      "3": { keyCode: 51, key: "3", code: "Digit3" },
      "4": { keyCode: 52, key: "4", code: "Digit4" },
      "5": { keyCode: 53, key: "5", code: "Digit5" },
      "6": { keyCode: 54, key: "6", code: "Digit6" },
      "7": { keyCode: 55, key: "7", code: "Digit7" },
      "8": { keyCode: 56, key: "8", code: "Digit8" },
      "9": { keyCode: 57, key: "9", code: "Digit9" },
      Power: { key: "Power", code: "Power" },
      Eject: { key: "Eject", code: "Eject" },
      Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
      Help: { keyCode: 6, code: "Help", key: "Help" },
      Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
      Tab: { keyCode: 9, code: "Tab", key: "Tab" },
      Numpad5: {
        keyCode: 12,
        shiftKeyCode: 101,
        key: "Clear",
        code: "Numpad5",
        shiftKey: "5",
        location: 3
      },
      NumpadEnter: {
        keyCode: 13,
        code: "NumpadEnter",
        key: "Enter",
        text: "\r",
        location: 3
      },
      Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
      "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
      "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
      ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
      ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
      ControlLeft: {
        keyCode: 17,
        code: "ControlLeft",
        key: "Control",
        location: 1
      },
      ControlRight: {
        keyCode: 17,
        code: "ControlRight",
        key: "Control",
        location: 2
      },
      AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
      AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
      Pause: { keyCode: 19, code: "Pause", key: "Pause" },
      CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
      Escape: { keyCode: 27, code: "Escape", key: "Escape" },
      Convert: { keyCode: 28, code: "Convert", key: "Convert" },
      NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
      Space: { keyCode: 32, code: "Space", key: " " },
      Numpad9: {
        keyCode: 33,
        shiftKeyCode: 105,
        key: "PageUp",
        code: "Numpad9",
        shiftKey: "9",
        location: 3
      },
      PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
      Numpad3: {
        keyCode: 34,
        shiftKeyCode: 99,
        key: "PageDown",
        code: "Numpad3",
        shiftKey: "3",
        location: 3
      },
      PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
      End: { keyCode: 35, code: "End", key: "End" },
      Numpad1: {
        keyCode: 35,
        shiftKeyCode: 97,
        key: "End",
        code: "Numpad1",
        shiftKey: "1",
        location: 3
      },
      Home: { keyCode: 36, code: "Home", key: "Home" },
      Numpad7: {
        keyCode: 36,
        shiftKeyCode: 103,
        key: "Home",
        code: "Numpad7",
        shiftKey: "7",
        location: 3
      },
      ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
      Numpad4: {
        keyCode: 37,
        shiftKeyCode: 100,
        key: "ArrowLeft",
        code: "Numpad4",
        shiftKey: "4",
        location: 3
      },
      Numpad8: {
        keyCode: 38,
        shiftKeyCode: 104,
        key: "ArrowUp",
        code: "Numpad8",
        shiftKey: "8",
        location: 3
      },
      ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
      ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
      Numpad6: {
        keyCode: 39,
        shiftKeyCode: 102,
        key: "ArrowRight",
        code: "Numpad6",
        shiftKey: "6",
        location: 3
      },
      Numpad2: {
        keyCode: 40,
        shiftKeyCode: 98,
        key: "ArrowDown",
        code: "Numpad2",
        shiftKey: "2",
        location: 3
      },
      ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
      Select: { keyCode: 41, code: "Select", key: "Select" },
      Open: { keyCode: 43, code: "Open", key: "Execute" },
      PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
      Insert: { keyCode: 45, code: "Insert", key: "Insert" },
      Numpad0: {
        keyCode: 45,
        shiftKeyCode: 96,
        key: "Insert",
        code: "Numpad0",
        shiftKey: "0",
        location: 3
      },
      Delete: { keyCode: 46, code: "Delete", key: "Delete" },
      NumpadDecimal: {
        keyCode: 46,
        shiftKeyCode: 110,
        code: "NumpadDecimal",
        key: "\0",
        shiftKey: ".",
        location: 3
      },
      Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
      Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
      Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
      Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
      Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
      Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
      Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
      Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
      Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
      Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
      KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
      KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
      KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
      KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
      KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
      KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
      KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
      KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
      KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
      KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
      KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
      KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
      KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
      KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
      KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
      KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
      KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
      KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
      KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
      KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
      KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
      KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
      KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
      KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
      KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
      KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
      MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
      MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
      ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
      NumpadMultiply: {
        keyCode: 106,
        code: "NumpadMultiply",
        key: "*",
        location: 3
      },
      NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
      NumpadSubtract: {
        keyCode: 109,
        code: "NumpadSubtract",
        key: "-",
        location: 3
      },
      NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
      F1: { keyCode: 112, code: "F1", key: "F1" },
      F2: { keyCode: 113, code: "F2", key: "F2" },
      F3: { keyCode: 114, code: "F3", key: "F3" },
      F4: { keyCode: 115, code: "F4", key: "F4" },
      F5: { keyCode: 116, code: "F5", key: "F5" },
      F6: { keyCode: 117, code: "F6", key: "F6" },
      F7: { keyCode: 118, code: "F7", key: "F7" },
      F8: { keyCode: 119, code: "F8", key: "F8" },
      F9: { keyCode: 120, code: "F9", key: "F9" },
      F10: { keyCode: 121, code: "F10", key: "F10" },
      F11: { keyCode: 122, code: "F11", key: "F11" },
      F12: { keyCode: 123, code: "F12", key: "F12" },
      F13: { keyCode: 124, code: "F13", key: "F13" },
      F14: { keyCode: 125, code: "F14", key: "F14" },
      F15: { keyCode: 126, code: "F15", key: "F15" },
      F16: { keyCode: 127, code: "F16", key: "F16" },
      F17: { keyCode: 128, code: "F17", key: "F17" },
      F18: { keyCode: 129, code: "F18", key: "F18" },
      F19: { keyCode: 130, code: "F19", key: "F19" },
      F20: { keyCode: 131, code: "F20", key: "F20" },
      F21: { keyCode: 132, code: "F21", key: "F21" },
      F22: { keyCode: 133, code: "F22", key: "F22" },
      F23: { keyCode: 134, code: "F23", key: "F23" },
      F24: { keyCode: 135, code: "F24", key: "F24" },
      NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
      ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
      AudioVolumeMute: {
        keyCode: 173,
        code: "AudioVolumeMute",
        key: "AudioVolumeMute"
      },
      AudioVolumeDown: {
        keyCode: 174,
        code: "AudioVolumeDown",
        key: "AudioVolumeDown"
      },
      AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
      MediaTrackNext: {
        keyCode: 176,
        code: "MediaTrackNext",
        key: "MediaTrackNext"
      },
      MediaTrackPrevious: {
        keyCode: 177,
        code: "MediaTrackPrevious",
        key: "MediaTrackPrevious"
      },
      MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
      MediaPlayPause: {
        keyCode: 179,
        code: "MediaPlayPause",
        key: "MediaPlayPause"
      },
      Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
      Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
      NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
      Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
      Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
      Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
      Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
      Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
      BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
      Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
      BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
      Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
      AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
      Props: { keyCode: 247, code: "Props", key: "CrSel" },
      Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
      Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
      Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
      Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
      Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
      Accept: { keyCode: 30, key: "Accept" },
      ModeChange: { keyCode: 31, key: "ModeChange" },
      " ": { keyCode: 32, key: " ", code: "Space" },
      Print: { keyCode: 42, key: "Print" },
      Execute: { keyCode: 43, key: "Execute", code: "Open" },
      "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
      a: { keyCode: 65, key: "a", code: "KeyA" },
      b: { keyCode: 66, key: "b", code: "KeyB" },
      c: { keyCode: 67, key: "c", code: "KeyC" },
      d: { keyCode: 68, key: "d", code: "KeyD" },
      e: { keyCode: 69, key: "e", code: "KeyE" },
      f: { keyCode: 70, key: "f", code: "KeyF" },
      g: { keyCode: 71, key: "g", code: "KeyG" },
      h: { keyCode: 72, key: "h", code: "KeyH" },
      i: { keyCode: 73, key: "i", code: "KeyI" },
      j: { keyCode: 74, key: "j", code: "KeyJ" },
      k: { keyCode: 75, key: "k", code: "KeyK" },
      l: { keyCode: 76, key: "l", code: "KeyL" },
      m: { keyCode: 77, key: "m", code: "KeyM" },
      n: { keyCode: 78, key: "n", code: "KeyN" },
      o: { keyCode: 79, key: "o", code: "KeyO" },
      p: { keyCode: 80, key: "p", code: "KeyP" },
      q: { keyCode: 81, key: "q", code: "KeyQ" },
      r: { keyCode: 82, key: "r", code: "KeyR" },
      s: { keyCode: 83, key: "s", code: "KeyS" },
      t: { keyCode: 84, key: "t", code: "KeyT" },
      u: { keyCode: 85, key: "u", code: "KeyU" },
      v: { keyCode: 86, key: "v", code: "KeyV" },
      w: { keyCode: 87, key: "w", code: "KeyW" },
      x: { keyCode: 88, key: "x", code: "KeyX" },
      y: { keyCode: 89, key: "y", code: "KeyY" },
      z: { keyCode: 90, key: "z", code: "KeyZ" },
      Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
      "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
      "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
      "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
      "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
      ";": { keyCode: 186, key: ";", code: "Semicolon" },
      "=": { keyCode: 187, key: "=", code: "Equal" },
      ",": { keyCode: 188, key: ",", code: "Comma" },
      ".": { keyCode: 190, key: ".", code: "Period" },
      "`": { keyCode: 192, key: "`", code: "Backquote" },
      "[": { keyCode: 219, key: "[", code: "BracketLeft" },
      "\\": { keyCode: 220, key: "\\", code: "Backslash" },
      "]": { keyCode: 221, key: "]", code: "BracketRight" },
      "'": { keyCode: 222, key: "'", code: "Quote" },
      Attn: { keyCode: 246, key: "Attn" },
      CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
      ExSel: { keyCode: 248, key: "ExSel" },
      EraseEof: { keyCode: 249, key: "EraseEof" },
      Play: { keyCode: 250, key: "Play" },
      ZoomOut: { keyCode: 251, key: "ZoomOut" },
      ")": { keyCode: 48, key: ")", code: "Digit0" },
      "!": { keyCode: 49, key: "!", code: "Digit1" },
      "@": { keyCode: 50, key: "@", code: "Digit2" },
      "#": { keyCode: 51, key: "#", code: "Digit3" },
      $: { keyCode: 52, key: "$", code: "Digit4" },
      "%": { keyCode: 53, key: "%", code: "Digit5" },
      "^": { keyCode: 54, key: "^", code: "Digit6" },
      "&": { keyCode: 55, key: "&", code: "Digit7" },
      "(": { keyCode: 57, key: "(", code: "Digit9" },
      A: { keyCode: 65, key: "A", code: "KeyA" },
      B: { keyCode: 66, key: "B", code: "KeyB" },
      C: { keyCode: 67, key: "C", code: "KeyC" },
      D: { keyCode: 68, key: "D", code: "KeyD" },
      E: { keyCode: 69, key: "E", code: "KeyE" },
      F: { keyCode: 70, key: "F", code: "KeyF" },
      G: { keyCode: 71, key: "G", code: "KeyG" },
      H: { keyCode: 72, key: "H", code: "KeyH" },
      I: { keyCode: 73, key: "I", code: "KeyI" },
      J: { keyCode: 74, key: "J", code: "KeyJ" },
      K: { keyCode: 75, key: "K", code: "KeyK" },
      L: { keyCode: 76, key: "L", code: "KeyL" },
      M: { keyCode: 77, key: "M", code: "KeyM" },
      N: { keyCode: 78, key: "N", code: "KeyN" },
      O: { keyCode: 79, key: "O", code: "KeyO" },
      P: { keyCode: 80, key: "P", code: "KeyP" },
      Q: { keyCode: 81, key: "Q", code: "KeyQ" },
      R: { keyCode: 82, key: "R", code: "KeyR" },
      S: { keyCode: 83, key: "S", code: "KeyS" },
      T: { keyCode: 84, key: "T", code: "KeyT" },
      U: { keyCode: 85, key: "U", code: "KeyU" },
      V: { keyCode: 86, key: "V", code: "KeyV" },
      W: { keyCode: 87, key: "W", code: "KeyW" },
      X: { keyCode: 88, key: "X", code: "KeyX" },
      Y: { keyCode: 89, key: "Y", code: "KeyY" },
      Z: { keyCode: 90, key: "Z", code: "KeyZ" },
      ":": { keyCode: 186, key: ":", code: "Semicolon" },
      "<": { keyCode: 188, key: "<", code: "Comma" },
      _: { keyCode: 189, key: "_", code: "Minus" },
      ">": { keyCode: 190, key: ">", code: "Period" },
      "?": { keyCode: 191, key: "?", code: "Slash" },
      "~": { keyCode: 192, key: "~", code: "Backquote" },
      "{": { keyCode: 219, key: "{", code: "BracketLeft" },
      "|": { keyCode: 220, key: "|", code: "Backslash" },
      "}": { keyCode: 221, key: "}", code: "BracketRight" },
      '"': { keyCode: 222, key: '"', code: "Quote" },
      SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
      SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
      Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
      Call: { key: "Call", code: "Call", location: 4 },
      EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
      VolumeDown: {
        keyCode: 182,
        key: "VolumeDown",
        code: "VolumeDown",
        location: 4
      },
      VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Input.js
var require_Input = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Input.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Keyboard_instances;
    var _Keyboard_client;
    var _Keyboard_pressedKeys;
    var _Keyboard_modifierBit;
    var _Keyboard_keyDescriptionForString;
    var _Mouse_instances;
    var _Mouse_client;
    var _Mouse_keyboard;
    var _Mouse__state;
    var _Mouse_state_get;
    var _Mouse_transactions;
    var _Mouse_createTransaction;
    var _Mouse_withTransaction;
    var _Touchscreen_client;
    var _Touchscreen_keyboard;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Touchscreen = exports2.Mouse = exports2.MouseButton = exports2.Keyboard = void 0;
    var assert_js_1 = require_assert();
    var USKeyboardLayout_js_1 = require_USKeyboardLayout();
    var Keyboard = class {
      /**
       * @internal
       */
      constructor(client) {
        _Keyboard_instances.add(this);
        _Keyboard_client.set(this, void 0);
        _Keyboard_pressedKeys.set(this, /* @__PURE__ */ new Set());
        this._modifiers = 0;
        __classPrivateFieldSet(this, _Keyboard_client, client, "f");
      }
      /**
       * Dispatches a `keydown` event.
       *
       * @remarks
       * If `key` is a single character and no modifier keys besides `Shift`
       * are being held down, a `keypress`/`input` event will also generated.
       * The `text` option can be specified to force an input event to be generated.
       * If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`,
       * subsequent key presses will be sent with that modifier active.
       * To release the modifier key, use {@link Keyboard.up}.
       *
       * After the key is pressed once, subsequent calls to
       * {@link Keyboard.down} will have
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat | repeat}
       * set to true. To release the key, use {@link Keyboard.up}.
       *
       * Modifier keys DO influence {@link Keyboard.down}.
       * Holding down `Shift` will type the text in upper case.
       *
       * @param key - Name of key to press, such as `ArrowLeft`.
       * See {@link KeyInput} for a list of all key names.
       *
       * @param options - An object of options. Accepts text which, if specified,
       * generates an input event with this text. Accepts commands which, if specified,
       * is the commands of keyboard shortcuts,
       * see {@link https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h | Chromium Source Code} for valid command names.
       */
      async down(key, options = {
        text: void 0,
        commands: []
      }) {
        const description = __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_keyDescriptionForString).call(this, key);
        const autoRepeat = __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").has(description.code);
        __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").add(description.code);
        this._modifiers |= __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_modifierBit).call(this, description.key);
        const text = options.text === void 0 ? description.text : options.text;
        await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          modifiers: this._modifiers,
          windowsVirtualKeyCode: description.keyCode,
          code: description.code,
          key: description.key,
          text,
          unmodifiedText: text,
          autoRepeat,
          location: description.location,
          isKeypad: description.location === 3,
          commands: options.commands
        });
      }
      /**
       * Dispatches a `keyup` event.
       *
       * @param key - Name of key to release, such as `ArrowLeft`.
       * See {@link KeyInput | KeyInput}
       * for a list of all key names.
       */
      async up(key) {
        const description = __classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_keyDescriptionForString).call(this, key);
        this._modifiers &= ~__classPrivateFieldGet(this, _Keyboard_instances, "m", _Keyboard_modifierBit).call(this, description.key);
        __classPrivateFieldGet(this, _Keyboard_pressedKeys, "f").delete(description.code);
        await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: this._modifiers,
          key: description.key,
          windowsVirtualKeyCode: description.keyCode,
          code: description.code,
          location: description.location
        });
      }
      /**
       * Dispatches a `keypress` and `input` event.
       * This does not send a `keydown` or `keyup` event.
       *
       * @remarks
       * Modifier keys DO NOT effect {@link Keyboard.sendCharacter | Keyboard.sendCharacter}.
       * Holding down `Shift` will not type the text in upper case.
       *
       * @example
       *
       * ```ts
       * page.keyboard.sendCharacter('');
       * ```
       *
       * @param char - Character to send into the page.
       */
      async sendCharacter(char) {
        await __classPrivateFieldGet(this, _Keyboard_client, "f").send("Input.insertText", { text: char });
      }
      charIsKey(char) {
        return !!USKeyboardLayout_js_1._keyDefinitions[char];
      }
      /**
       * Sends a `keydown`, `keypress`/`input`,
       * and `keyup` event for each character in the text.
       *
       * @remarks
       * To press a special key, like `Control` or `ArrowDown`,
       * use {@link Keyboard.press}.
       *
       * Modifier keys DO NOT effect `keyboard.type`.
       * Holding down `Shift` will not type the text in upper case.
       *
       * @example
       *
       * ```ts
       * await page.keyboard.type('Hello'); // Types instantly
       * await page.keyboard.type('World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @param text - A text to type into a focused element.
       * @param options - An object of options. Accepts delay which,
       * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
       * Defaults to 0.
       */
      async type(text, options = {}) {
        const delay = options.delay || void 0;
        for (const char of text) {
          if (this.charIsKey(char)) {
            await this.press(char, { delay });
          } else {
            if (delay) {
              await new Promise((f) => {
                return setTimeout(f, delay);
              });
            }
            await this.sendCharacter(char);
          }
        }
      }
      /**
       * Shortcut for {@link Keyboard.down}
       * and {@link Keyboard.up}.
       *
       * @remarks
       * If `key` is a single character and no modifier keys besides `Shift`
       * are being held down, a `keypress`/`input` event will also generated.
       * The `text` option can be specified to force an input event to be generated.
       *
       * Modifier keys DO effect {@link Keyboard.press}.
       * Holding down `Shift` will type the text in upper case.
       *
       * @param key - Name of key to press, such as `ArrowLeft`.
       * See {@link KeyInput} for a list of all key names.
       *
       * @param options - An object of options. Accepts text which, if specified,
       * generates an input event with this text. Accepts delay which,
       * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
       * Defaults to 0. Accepts commands which, if specified,
       * is the commands of keyboard shortcuts,
       * see {@link https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h | Chromium Source Code} for valid command names.
       */
      async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay) {
          await new Promise((f) => {
            return setTimeout(f, options.delay);
          });
        }
        await this.up(key);
      }
    };
    exports2.Keyboard = Keyboard;
    _Keyboard_client = /* @__PURE__ */ new WeakMap(), _Keyboard_pressedKeys = /* @__PURE__ */ new WeakMap(), _Keyboard_instances = /* @__PURE__ */ new WeakSet(), _Keyboard_modifierBit = function _Keyboard_modifierBit2(key) {
      if (key === "Alt") {
        return 1;
      }
      if (key === "Control") {
        return 2;
      }
      if (key === "Meta") {
        return 4;
      }
      if (key === "Shift") {
        return 8;
      }
      return 0;
    }, _Keyboard_keyDescriptionForString = function _Keyboard_keyDescriptionForString2(keyString) {
      const shift = this._modifiers & 8;
      const description = {
        key: "",
        keyCode: 0,
        code: "",
        text: "",
        location: 0
      };
      const definition = USKeyboardLayout_js_1._keyDefinitions[keyString];
      (0, assert_js_1.assert)(definition, `Unknown key: "${keyString}"`);
      if (definition.key) {
        description.key = definition.key;
      }
      if (shift && definition.shiftKey) {
        description.key = definition.shiftKey;
      }
      if (definition.keyCode) {
        description.keyCode = definition.keyCode;
      }
      if (shift && definition.shiftKeyCode) {
        description.keyCode = definition.shiftKeyCode;
      }
      if (definition.code) {
        description.code = definition.code;
      }
      if (definition.location) {
        description.location = definition.location;
      }
      if (description.key.length === 1) {
        description.text = description.key;
      }
      if (definition.text) {
        description.text = definition.text;
      }
      if (shift && definition.shiftText) {
        description.text = definition.shiftText;
      }
      if (this._modifiers & ~8) {
        description.text = "";
      }
      return description;
    };
    exports2.MouseButton = Object.freeze({
      Left: "left",
      Right: "right",
      Middle: "middle",
      Back: "back",
      Forward: "forward"
    });
    var getFlag = (button) => {
      switch (button) {
        case exports2.MouseButton.Left:
          return 1;
        case exports2.MouseButton.Right:
          return 2;
        case exports2.MouseButton.Middle:
          return 4;
        case exports2.MouseButton.Back:
          return 8;
        case exports2.MouseButton.Forward:
          return 16;
      }
    };
    var getButtonFromPressedButtons = (buttons) => {
      if (buttons & 1) {
        return exports2.MouseButton.Left;
      } else if (buttons & 2) {
        return exports2.MouseButton.Right;
      } else if (buttons & 4) {
        return exports2.MouseButton.Middle;
      } else if (buttons & 8) {
        return exports2.MouseButton.Back;
      } else if (buttons & 16) {
        return exports2.MouseButton.Forward;
      }
      return "none";
    };
    var Mouse = class {
      /**
       * @internal
       */
      constructor(client, keyboard) {
        _Mouse_instances.add(this);
        _Mouse_client.set(this, void 0);
        _Mouse_keyboard.set(this, void 0);
        _Mouse__state.set(this, {
          position: { x: 0, y: 0 },
          buttons: 0
        });
        _Mouse_transactions.set(this, []);
        __classPrivateFieldSet(this, _Mouse_client, client, "f");
        __classPrivateFieldSet(this, _Mouse_keyboard, keyboard, "f");
      }
      /**
       * Moves the mouse to the given coordinate.
       *
       * @param x - Horizontal position of the mouse.
       * @param y - Vertical position of the mouse.
       * @param options - Options to configure behavior.
       */
      async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const from = __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get).position;
        const to = { x, y };
        for (let i = 1; i <= steps; i++) {
          await __classPrivateFieldGet(this, _Mouse_instances, "m", _Mouse_withTransaction).call(this, (updateState) => {
            updateState({
              position: {
                x: from.x + (to.x - from.x) * (i / steps),
                y: from.y + (to.y - from.y) * (i / steps)
              }
            });
            const { buttons, position } = __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get);
            return __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
              buttons,
              button: getButtonFromPressedButtons(buttons),
              ...position
            });
          });
        }
      }
      /**
       * Presses the mouse.
       *
       * @param options - Options to configure behavior.
       */
      async down(options = {}) {
        const { button = exports2.MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
          throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (__classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get).buttons & flag) {
          throw new Error(`'${button}' is already pressed.`);
        }
        await __classPrivateFieldGet(this, _Mouse_instances, "m", _Mouse_withTransaction).call(this, (updateState) => {
          updateState({
            buttons: __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get).buttons | flag
          });
          const { buttons, position } = __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get);
          return __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
            clickCount,
            buttons,
            button,
            ...position
          });
        });
      }
      /**
       * Releases the mouse.
       *
       * @param options - Options to configure behavior.
       */
      async up(options = {}) {
        const { button = exports2.MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
          throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (!(__classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get).buttons & flag)) {
          throw new Error(`'${button}' is not pressed.`);
        }
        await __classPrivateFieldGet(this, _Mouse_instances, "m", _Mouse_withTransaction).call(this, (updateState) => {
          updateState({
            buttons: __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get).buttons & ~flag
          });
          const { buttons, position } = __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get);
          return __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
            clickCount,
            buttons,
            button,
            ...position
          });
        });
      }
      /**
       * Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.
       *
       * @param x - Horizontal position of the mouse.
       * @param y - Vertical position of the mouse.
       * @param options - Options to configure behavior.
       */
      async click(x, y, options = {}) {
        const { delay, count = 1, clickCount = count } = options;
        if (count < 1) {
          throw new Error("Click must occur a positive number of times.");
        }
        const actions = [this.move(x, y)];
        if (clickCount === count) {
          for (let i = 1; i < count; ++i) {
            actions.push(this.down({ ...options, clickCount: i }), this.up({ ...options, clickCount: i }));
          }
        }
        actions.push(this.down({ ...options, clickCount }));
        if (typeof delay === "number") {
          await Promise.all(actions);
          actions.length = 0;
          await new Promise((resolve) => {
            setTimeout(resolve, delay);
          });
        }
        actions.push(this.up({ ...options, clickCount }));
        await Promise.all(actions);
      }
      /**
       * Dispatches a `mousewheel` event.
       * @param options - Optional: `MouseWheelOptions`.
       *
       * @example
       * An example of zooming into an element:
       *
       * ```ts
       * await page.goto(
       *   'https://mdn.mozillademos.org/en-US/docs/Web/API/Element/wheel_event$samples/Scaling_an_element_via_the_wheel?revision=1587366'
       * );
       *
       * const elem = await page.$('div');
       * const boundingBox = await elem.boundingBox();
       * await page.mouse.move(
       *   boundingBox.x + boundingBox.width / 2,
       *   boundingBox.y + boundingBox.height / 2
       * );
       *
       * await page.mouse.wheel({deltaY: -100});
       * ```
       */
      async wheel(options = {}) {
        const { deltaX = 0, deltaY = 0 } = options;
        const { position, buttons } = __classPrivateFieldGet(this, _Mouse_instances, "a", _Mouse_state_get);
        await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchMouseEvent", {
          type: "mouseWheel",
          pointerType: "mouse",
          modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
          deltaY,
          deltaX,
          buttons,
          ...position
        });
      }
      /**
       * Dispatches a `drag` event.
       * @param start - starting point for drag
       * @param target - point to drag to
       */
      async drag(start, target) {
        const promise = new Promise((resolve) => {
          __classPrivateFieldGet(this, _Mouse_client, "f").once("Input.dragIntercepted", (event) => {
            return resolve(event.data);
          });
        });
        await this.move(start.x, start.y);
        await this.down();
        await this.move(target.x, target.y);
        return promise;
      }
      /**
       * Dispatches a `dragenter` event.
       * @param target - point for emitting `dragenter` event
       * @param data - drag data containing items and operations mask
       */
      async dragEnter(target, data) {
        await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
          type: "dragEnter",
          x: target.x,
          y: target.y,
          modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
          data
        });
      }
      /**
       * Dispatches a `dragover` event.
       * @param target - point for emitting `dragover` event
       * @param data - drag data containing items and operations mask
       */
      async dragOver(target, data) {
        await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
          type: "dragOver",
          x: target.x,
          y: target.y,
          modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
          data
        });
      }
      /**
       * Performs a dragenter, dragover, and drop in sequence.
       * @param target - point to drop on
       * @param data - drag data containing items and operations mask
       */
      async drop(target, data) {
        await __classPrivateFieldGet(this, _Mouse_client, "f").send("Input.dispatchDragEvent", {
          type: "drop",
          x: target.x,
          y: target.y,
          modifiers: __classPrivateFieldGet(this, _Mouse_keyboard, "f")._modifiers,
          data
        });
      }
      /**
       * Performs a drag, dragenter, dragover, and drop in sequence.
       * @param start - point to drag from
       * @param target - point to drop on
       * @param options - An object of options. Accepts delay which,
       * if specified, is the time to wait between `dragover` and `drop` in milliseconds.
       * Defaults to 0.
       */
      async dragAndDrop(start, target, options = {}) {
        const { delay = null } = options;
        const data = await this.drag(start, target);
        await this.dragEnter(target, data);
        await this.dragOver(target, data);
        if (delay) {
          await new Promise((resolve) => {
            return setTimeout(resolve, delay);
          });
        }
        await this.drop(target, data);
        await this.up();
      }
    };
    exports2.Mouse = Mouse;
    _Mouse_client = /* @__PURE__ */ new WeakMap(), _Mouse_keyboard = /* @__PURE__ */ new WeakMap(), _Mouse__state = /* @__PURE__ */ new WeakMap(), _Mouse_transactions = /* @__PURE__ */ new WeakMap(), _Mouse_instances = /* @__PURE__ */ new WeakSet(), _Mouse_state_get = function _Mouse_state_get2() {
      return Object.assign({ ...__classPrivateFieldGet(this, _Mouse__state, "f") }, ...__classPrivateFieldGet(this, _Mouse_transactions, "f"));
    }, _Mouse_createTransaction = function _Mouse_createTransaction2() {
      const transaction = {};
      __classPrivateFieldGet(this, _Mouse_transactions, "f").push(transaction);
      const popTransaction = () => {
        __classPrivateFieldGet(this, _Mouse_transactions, "f").splice(__classPrivateFieldGet(this, _Mouse_transactions, "f").indexOf(transaction), 1);
      };
      return {
        update: (updates) => {
          Object.assign(transaction, updates);
        },
        commit: () => {
          __classPrivateFieldSet(this, _Mouse__state, { ...__classPrivateFieldGet(this, _Mouse__state, "f"), ...transaction }, "f");
          popTransaction();
        },
        rollback: popTransaction
      };
    }, _Mouse_withTransaction = /**
     * This is a shortcut for a typical update, commit/rollback lifecycle based on
     * the error of the action.
     */
    async function _Mouse_withTransaction2(action) {
      const { update, commit, rollback } = __classPrivateFieldGet(this, _Mouse_instances, "m", _Mouse_createTransaction).call(this);
      try {
        await action(update);
        commit();
      } catch (error) {
        rollback();
        throw error;
      }
    };
    var Touchscreen = class {
      /**
       * @internal
       */
      constructor(client, keyboard) {
        _Touchscreen_client.set(this, void 0);
        _Touchscreen_keyboard.set(this, void 0);
        __classPrivateFieldSet(this, _Touchscreen_client, client, "f");
        __classPrivateFieldSet(this, _Touchscreen_keyboard, keyboard, "f");
      }
      /**
       * Dispatches a `touchstart` and `touchend` event.
       * @param x - Horizontal position of the tap.
       * @param y - Vertical position of the tap.
       */
      async tap(x, y) {
        await this.touchStart(x, y);
        await this.touchEnd();
      }
      /**
       * Dispatches a `touchstart` event.
       * @param x - Horizontal position of the tap.
       * @param y - Vertical position of the tap.
       */
      async touchStart(x, y) {
        const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
        await __classPrivateFieldGet(this, _Touchscreen_client, "f").send("Input.dispatchTouchEvent", {
          type: "touchStart",
          touchPoints,
          modifiers: __classPrivateFieldGet(this, _Touchscreen_keyboard, "f")._modifiers
        });
      }
      /**
       * Dispatches a `touchMove` event.
       * @param x - Horizontal position of the move.
       * @param y - Vertical position of the move.
       */
      async touchMove(x, y) {
        const movePoints = [{ x: Math.round(x), y: Math.round(y) }];
        await __classPrivateFieldGet(this, _Touchscreen_client, "f").send("Input.dispatchTouchEvent", {
          type: "touchMove",
          touchPoints: movePoints,
          modifiers: __classPrivateFieldGet(this, _Touchscreen_keyboard, "f")._modifiers
        });
      }
      /**
       * Dispatches a `touchend` event.
       */
      async touchEnd() {
        await __classPrivateFieldGet(this, _Touchscreen_client, "f").send("Input.dispatchTouchEvent", {
          type: "touchEnd",
          touchPoints: [],
          modifiers: __classPrivateFieldGet(this, _Touchscreen_keyboard, "f")._modifiers
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
    _Touchscreen_client = /* @__PURE__ */ new WeakMap(), _Touchscreen_keyboard = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TimeoutSettings.js
var require_TimeoutSettings = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/TimeoutSettings.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TimeoutSettings_defaultTimeout;
    var _TimeoutSettings_defaultNavigationTimeout;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutSettings = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    var TimeoutSettings = class {
      constructor() {
        _TimeoutSettings_defaultTimeout.set(this, void 0);
        _TimeoutSettings_defaultNavigationTimeout.set(this, void 0);
        __classPrivateFieldSet(this, _TimeoutSettings_defaultTimeout, null, "f");
        __classPrivateFieldSet(this, _TimeoutSettings_defaultNavigationTimeout, null, "f");
      }
      setDefaultTimeout(timeout) {
        __classPrivateFieldSet(this, _TimeoutSettings_defaultTimeout, timeout, "f");
      }
      setDefaultNavigationTimeout(timeout) {
        __classPrivateFieldSet(this, _TimeoutSettings_defaultNavigationTimeout, timeout, "f");
      }
      navigationTimeout() {
        if (__classPrivateFieldGet(this, _TimeoutSettings_defaultNavigationTimeout, "f") !== null) {
          return __classPrivateFieldGet(this, _TimeoutSettings_defaultNavigationTimeout, "f");
        }
        if (__classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
          return __classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f");
        }
        return DEFAULT_TIMEOUT;
      }
      timeout() {
        if (__classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
          return __classPrivateFieldGet(this, _TimeoutSettings_defaultTimeout, "f");
        }
        return DEFAULT_TIMEOUT;
      }
    };
    exports2.TimeoutSettings = TimeoutSettings;
    _TimeoutSettings_defaultTimeout = /* @__PURE__ */ new WeakMap(), _TimeoutSettings_defaultNavigationTimeout = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Tracing.js
var require_Tracing = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Tracing.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Tracing_client;
    var _Tracing_recording;
    var _Tracing_path;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tracing = void 0;
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var util_js_1 = require_util2();
    var Tracing = class {
      /**
       * @internal
       */
      constructor(client) {
        _Tracing_client.set(this, void 0);
        _Tracing_recording.set(this, false);
        _Tracing_path.set(this, void 0);
        __classPrivateFieldSet(this, _Tracing_client, client, "f");
      }
      /**
       * Starts a trace for the current page.
       * @remarks
       * Only one trace can be active at a time per browser.
       *
       * @param options - Optional `TracingOptions`.
       */
      async start(options = {}) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _Tracing_recording, "f"), "Cannot start recording trace while already recording trace.");
        const defaultCategories = [
          "-*",
          "devtools.timeline",
          "v8.execute",
          "disabled-by-default-devtools.timeline",
          "disabled-by-default-devtools.timeline.frame",
          "toplevel",
          "blink.console",
          "blink.user_timing",
          "latencyInfo",
          "disabled-by-default-devtools.timeline.stack",
          "disabled-by-default-v8.cpu_profiler"
        ];
        const { path, screenshots = false, categories = defaultCategories } = options;
        if (screenshots) {
          categories.push("disabled-by-default-devtools.screenshot");
        }
        const excludedCategories = categories.filter((cat) => {
          return cat.startsWith("-");
        }).map((cat) => {
          return cat.slice(1);
        });
        const includedCategories = categories.filter((cat) => {
          return !cat.startsWith("-");
        });
        __classPrivateFieldSet(this, _Tracing_path, path, "f");
        __classPrivateFieldSet(this, _Tracing_recording, true, "f");
        await __classPrivateFieldGet(this, _Tracing_client, "f").send("Tracing.start", {
          transferMode: "ReturnAsStream",
          traceConfig: {
            excludedCategories,
            includedCategories
          }
        });
      }
      /**
       * Stops a trace started with the `start` method.
       * @returns Promise which resolves to buffer with trace data.
       */
      async stop() {
        let resolve;
        let reject;
        const contentPromise = new Promise((x, y) => {
          resolve = x;
          reject = y;
        });
        __classPrivateFieldGet(this, _Tracing_client, "f").once("Tracing.tracingComplete", async (event) => {
          try {
            const readable = await (0, util_js_1.getReadableFromProtocolStream)(__classPrivateFieldGet(this, _Tracing_client, "f"), event.stream);
            const buffer = await (0, util_js_1.getReadableAsBuffer)(readable, __classPrivateFieldGet(this, _Tracing_path, "f"));
            resolve(buffer !== null && buffer !== void 0 ? buffer : void 0);
          } catch (error) {
            if ((0, ErrorLike_js_1.isErrorLike)(error)) {
              reject(error);
            } else {
              reject(new Error(`Unknown error: ${error}`));
            }
          }
        });
        await __classPrivateFieldGet(this, _Tracing_client, "f").send("Tracing.end");
        __classPrivateFieldSet(this, _Tracing_recording, false, "f");
        return contentPromise;
      }
    };
    exports2.Tracing = Tracing;
    _Tracing_client = /* @__PURE__ */ new WeakMap(), _Tracing_recording = /* @__PURE__ */ new WeakMap(), _Tracing_path = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/WebWorker.js
var require_WebWorker = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/WebWorker.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _WebWorker_executionContext;
    var _WebWorker_client;
    var _WebWorker_url;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebWorker = void 0;
    var DeferredPromise_js_1 = require_DeferredPromise();
    var EventEmitter_js_1 = require_EventEmitter();
    var ExecutionContext_js_1 = require_ExecutionContext();
    var JSHandle_js_1 = require_JSHandle2();
    var util_js_1 = require_util2();
    var WebWorker = class extends EventEmitter_js_1.EventEmitter {
      /**
       * @internal
       */
      constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        _WebWorker_executionContext.set(this, (0, DeferredPromise_js_1.createDeferredPromise)());
        _WebWorker_client.set(this, void 0);
        _WebWorker_url.set(this, void 0);
        __classPrivateFieldSet(this, _WebWorker_client, client, "f");
        __classPrivateFieldSet(this, _WebWorker_url, url, "f");
        __classPrivateFieldGet(this, _WebWorker_client, "f").once("Runtime.executionContextCreated", async (event) => {
          const context = new ExecutionContext_js_1.ExecutionContext(client, event.context);
          __classPrivateFieldGet(this, _WebWorker_executionContext, "f").resolve(context);
        });
        __classPrivateFieldGet(this, _WebWorker_client, "f").on("Runtime.consoleAPICalled", async (event) => {
          const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
          return consoleAPICalled(event.type, event.args.map((object) => {
            return new JSHandle_js_1.CDPJSHandle(context, object);
          }), event.stackTrace);
        });
        __classPrivateFieldGet(this, _WebWorker_client, "f").on("Runtime.exceptionThrown", (exception) => {
          return exceptionThrown(exception.exceptionDetails);
        });
        __classPrivateFieldGet(this, _WebWorker_client, "f").send("Runtime.enable").catch(util_js_1.debugError);
      }
      /**
       * @internal
       */
      async executionContext() {
        return __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
      }
      /**
       * The URL of this web worker.
       */
      url() {
        return __classPrivateFieldGet(this, _WebWorker_url, "f");
      }
      /**
       * The CDP session client the WebWorker belongs to.
       */
      get client() {
        return __classPrivateFieldGet(this, _WebWorker_client, "f");
      }
      /**
       * If the function passed to the `worker.evaluate` returns a Promise, then
       * `worker.evaluate` would wait for the promise to resolve and return its
       * value. If the function passed to the `worker.evaluate` returns a
       * non-serializable value, then `worker.evaluate` resolves to `undefined`.
       * DevTools Protocol also supports transferring some additional values that
       * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and
       * bigint literals.
       * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.
       *
       * @param pageFunction - Function to be evaluated in the worker context.
       * @param args - Arguments to pass to `pageFunction`.
       * @returns Promise which resolves to the return value of `pageFunction`.
       */
      async evaluate(pageFunction, ...args) {
        const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
        return context.evaluate(pageFunction, ...args);
      }
      /**
       * The only difference between `worker.evaluate` and `worker.evaluateHandle`
       * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the
       * function passed to the `worker.evaluateHandle` returns a `Promise`, then
       * `worker.evaluateHandle` would wait for the promise to resolve and return
       * its value. Shortcut for
       * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`
       *
       * @param pageFunction - Function to be evaluated in the page context.
       * @param args - Arguments to pass to `pageFunction`.
       * @returns Promise which resolves to the return value of `pageFunction`.
       */
      async evaluateHandle(pageFunction, ...args) {
        const context = await __classPrivateFieldGet(this, _WebWorker_executionContext, "f");
        return context.evaluateHandle(pageFunction, ...args);
      }
    };
    exports2.WebWorker = WebWorker;
    _WebWorker_executionContext = /* @__PURE__ */ new WeakMap(), _WebWorker_client = /* @__PURE__ */ new WeakMap(), _WebWorker_url = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Page.js
var require_Page2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Page.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _CDPPage_instances;
    var _CDPPage_closed;
    var _CDPPage_client;
    var _CDPPage_target;
    var _CDPPage_keyboard;
    var _CDPPage_mouse;
    var _CDPPage_timeoutSettings;
    var _CDPPage_touchscreen;
    var _CDPPage_accessibility;
    var _CDPPage_frameManager;
    var _CDPPage_emulationManager;
    var _CDPPage_tracing;
    var _CDPPage_bindings;
    var _CDPPage_coverage;
    var _CDPPage_javascriptEnabled;
    var _CDPPage_viewport;
    var _CDPPage_screenshotTaskQueue;
    var _CDPPage_workers;
    var _CDPPage_fileChooserPromises;
    var _CDPPage_disconnectPromise;
    var _CDPPage_userDragInterceptionEnabled;
    var _CDPPage_onDetachedFromTarget;
    var _CDPPage_onAttachedToTarget;
    var _CDPPage_initialize;
    var _CDPPage_onFileChooser;
    var _CDPPage_onTargetCrashed;
    var _CDPPage_onLogEntryAdded;
    var _CDPPage_emitMetrics;
    var _CDPPage_buildMetricsObject;
    var _CDPPage_handleException;
    var _CDPPage_onConsoleAPI;
    var _CDPPage_onBindingCalled;
    var _CDPPage_addConsoleMessage;
    var _CDPPage_onDialog;
    var _CDPPage_resetDefaultBackgroundColor;
    var _CDPPage_setTransparentBackgroundColor;
    var _CDPPage_sessionClosePromise;
    var _CDPPage_go;
    var _CDPPage_screenshotTask;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CDPPage = void 0;
    var Page_js_1 = require_Page();
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var ErrorLike_js_1 = require_ErrorLike();
    var Accessibility_js_1 = require_Accessibility();
    var Binding_js_1 = require_Binding();
    var Connection_js_1 = require_Connection();
    var ConsoleMessage_js_1 = require_ConsoleMessage();
    var Coverage_js_1 = require_Coverage();
    var Dialog_js_1 = require_Dialog();
    var EmulationManager_js_1 = require_EmulationManager();
    var FileChooser_js_1 = require_FileChooser();
    var FrameManager_js_1 = require_FrameManager();
    var Input_js_1 = require_Input();
    var IsolatedWorlds_js_1 = require_IsolatedWorlds();
    var NetworkManager_js_1 = require_NetworkManager();
    var TimeoutSettings_js_1 = require_TimeoutSettings();
    var Tracing_js_1 = require_Tracing();
    var util_js_1 = require_util2();
    var WebWorker_js_1 = require_WebWorker();
    var CDPPage = class extends Page_js_1.Page {
      /**
       * @internal
       */
      static async _create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        const page = new CDPPage(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
        await __classPrivateFieldGet(page, _CDPPage_instances, "m", _CDPPage_initialize).call(page);
        if (defaultViewport) {
          try {
            await page.setViewport(defaultViewport);
          } catch (err) {
            if ((0, ErrorLike_js_1.isErrorLike)(err) && (0, Connection_js_1.isTargetClosedError)(err)) {
              (0, util_js_1.debugError)(err);
            } else {
              throw err;
            }
          }
        }
        return page;
      }
      /**
       * @internal
       */
      constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
        super();
        _CDPPage_instances.add(this);
        _CDPPage_closed.set(this, false);
        _CDPPage_client.set(this, void 0);
        _CDPPage_target.set(this, void 0);
        _CDPPage_keyboard.set(this, void 0);
        _CDPPage_mouse.set(this, void 0);
        _CDPPage_timeoutSettings.set(this, new TimeoutSettings_js_1.TimeoutSettings());
        _CDPPage_touchscreen.set(this, void 0);
        _CDPPage_accessibility.set(this, void 0);
        _CDPPage_frameManager.set(this, void 0);
        _CDPPage_emulationManager.set(this, void 0);
        _CDPPage_tracing.set(this, void 0);
        _CDPPage_bindings.set(this, /* @__PURE__ */ new Map());
        _CDPPage_coverage.set(this, void 0);
        _CDPPage_javascriptEnabled.set(this, true);
        _CDPPage_viewport.set(this, void 0);
        _CDPPage_screenshotTaskQueue.set(this, void 0);
        _CDPPage_workers.set(this, /* @__PURE__ */ new Map());
        _CDPPage_fileChooserPromises.set(this, /* @__PURE__ */ new Set());
        _CDPPage_disconnectPromise.set(this, void 0);
        _CDPPage_userDragInterceptionEnabled.set(this, false);
        _CDPPage_onDetachedFromTarget.set(this, (target2) => {
          var _a;
          const sessionId = (_a = target2._session()) === null || _a === void 0 ? void 0 : _a.id();
          const worker = __classPrivateFieldGet(this, _CDPPage_workers, "f").get(sessionId);
          if (!worker) {
            return;
          }
          __classPrivateFieldGet(this, _CDPPage_workers, "f").delete(sessionId);
          this.emit("workerdestroyed", worker);
        });
        _CDPPage_onAttachedToTarget.set(this, (createdTarget) => {
          __classPrivateFieldGet(this, _CDPPage_frameManager, "f").onAttachedToTarget(createdTarget);
          if (createdTarget._getTargetInfo().type === "worker") {
            const session = createdTarget._session();
            (0, assert_js_1.assert)(session);
            const worker = new WebWorker_js_1.WebWorker(session, createdTarget.url(), __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_addConsoleMessage).bind(this), __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_handleException).bind(this));
            __classPrivateFieldGet(this, _CDPPage_workers, "f").set(session.id(), worker);
            this.emit("workercreated", worker);
          }
          if (createdTarget._session()) {
            __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().addTargetInterceptor(createdTarget._session(), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
          }
        });
        __classPrivateFieldSet(this, _CDPPage_client, client, "f");
        __classPrivateFieldSet(this, _CDPPage_target, target, "f");
        __classPrivateFieldSet(this, _CDPPage_keyboard, new Input_js_1.Keyboard(client), "f");
        __classPrivateFieldSet(this, _CDPPage_mouse, new Input_js_1.Mouse(client, __classPrivateFieldGet(this, _CDPPage_keyboard, "f")), "f");
        __classPrivateFieldSet(this, _CDPPage_touchscreen, new Input_js_1.Touchscreen(client, __classPrivateFieldGet(this, _CDPPage_keyboard, "f")), "f");
        __classPrivateFieldSet(this, _CDPPage_accessibility, new Accessibility_js_1.Accessibility(client), "f");
        __classPrivateFieldSet(this, _CDPPage_frameManager, new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f")), "f");
        __classPrivateFieldSet(this, _CDPPage_emulationManager, new EmulationManager_js_1.EmulationManager(client), "f");
        __classPrivateFieldSet(this, _CDPPage_tracing, new Tracing_js_1.Tracing(client), "f");
        __classPrivateFieldSet(this, _CDPPage_coverage, new Coverage_js_1.Coverage(client), "f");
        __classPrivateFieldSet(this, _CDPPage_screenshotTaskQueue, screenshotTaskQueue, "f");
        __classPrivateFieldSet(this, _CDPPage_viewport, null, "f");
        __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().addTargetInterceptor(__classPrivateFieldGet(this, _CDPPage_client, "f"), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
        __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().on("targetGone", __classPrivateFieldGet(this, _CDPPage_onDetachedFromTarget, "f"));
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, (event) => {
          return this.emit("frameattached", event);
        });
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, (event) => {
          return this.emit("framedetached", event);
        });
        __classPrivateFieldGet(this, _CDPPage_frameManager, "f").on(FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, (event) => {
          return this.emit("framenavigated", event);
        });
        const networkManager = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager;
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (event) => {
          return this.emit("request", event);
        });
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestServedFromCache, (event) => {
          return this.emit("requestservedfromcache", event);
        });
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, (event) => {
          return this.emit("response", event);
        });
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, (event) => {
          return this.emit("requestfailed", event);
        });
        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, (event) => {
          return this.emit("requestfinished", event);
        });
        client.on("Page.domContentEventFired", () => {
          return this.emit(
            "domcontentloaded"
            /* PageEmittedEvents.DOMContentLoaded */
          );
        });
        client.on("Page.loadEventFired", () => {
          return this.emit(
            "load"
            /* PageEmittedEvents.Load */
          );
        });
        client.on("Runtime.consoleAPICalled", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onConsoleAPI).call(this, event);
        });
        client.on("Runtime.bindingCalled", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onBindingCalled).call(this, event);
        });
        client.on("Page.javascriptDialogOpening", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onDialog).call(this, event);
        });
        client.on("Runtime.exceptionThrown", (exception) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_handleException).call(this, exception.exceptionDetails);
        });
        client.on("Inspector.targetCrashed", () => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onTargetCrashed).call(this);
        });
        client.on("Performance.metrics", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_emitMetrics).call(this, event);
        });
        client.on("Log.entryAdded", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onLogEntryAdded).call(this, event);
        });
        client.on("Page.fileChooserOpened", (event) => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_onFileChooser).call(this, event);
        });
        void __classPrivateFieldGet(this, _CDPPage_target, "f")._isClosedPromise.then(() => {
          __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().removeTargetInterceptor(__classPrivateFieldGet(this, _CDPPage_client, "f"), __classPrivateFieldGet(this, _CDPPage_onAttachedToTarget, "f"));
          __classPrivateFieldGet(this, _CDPPage_target, "f")._targetManager().off("targetGone", __classPrivateFieldGet(this, _CDPPage_onDetachedFromTarget, "f"));
          this.emit(
            "close"
            /* PageEmittedEvents.Close */
          );
          __classPrivateFieldSet(this, _CDPPage_closed, true, "f");
        });
      }
      /**
       * @internal
       */
      _client() {
        return __classPrivateFieldGet(this, _CDPPage_client, "f");
      }
      isDragInterceptionEnabled() {
        return __classPrivateFieldGet(this, _CDPPage_userDragInterceptionEnabled, "f");
      }
      isJavaScriptEnabled() {
        return __classPrivateFieldGet(this, _CDPPage_javascriptEnabled, "f");
      }
      waitForFileChooser(options = {}) {
        const needsEnable = __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").size === 0;
        const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
        const promise = (0, DeferredPromise_js_1.createDeferredPromise)({
          message: `Waiting for \`FileChooser\` failed: ${timeout}ms exceeded`,
          timeout
        });
        __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").add(promise);
        let enablePromise;
        if (needsEnable) {
          enablePromise = __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.setInterceptFileChooserDialog", {
            enabled: true
          });
        }
        return Promise.all([promise, enablePromise]).then(([result]) => {
          return result;
        }).catch((error) => {
          __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").delete(promise);
          throw error;
        });
      }
      async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180) {
          throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        }
        if (latitude < -90 || latitude > 90) {
          throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        }
        if (accuracy < 0) {
          throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        }
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setGeolocationOverride", {
          longitude,
          latitude,
          accuracy
        });
      }
      target() {
        return __classPrivateFieldGet(this, _CDPPage_target, "f");
      }
      browser() {
        return __classPrivateFieldGet(this, _CDPPage_target, "f").browser();
      }
      browserContext() {
        return __classPrivateFieldGet(this, _CDPPage_target, "f").browserContext();
      }
      mainFrame() {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame();
      }
      get keyboard() {
        return __classPrivateFieldGet(this, _CDPPage_keyboard, "f");
      }
      get touchscreen() {
        return __classPrivateFieldGet(this, _CDPPage_touchscreen, "f");
      }
      get coverage() {
        return __classPrivateFieldGet(this, _CDPPage_coverage, "f");
      }
      get tracing() {
        return __classPrivateFieldGet(this, _CDPPage_tracing, "f");
      }
      get accessibility() {
        return __classPrivateFieldGet(this, _CDPPage_accessibility, "f");
      }
      frames() {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").frames();
      }
      workers() {
        return Array.from(__classPrivateFieldGet(this, _CDPPage_workers, "f").values());
      }
      async setRequestInterception(value) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setRequestInterception(value);
      }
      async setDragInterception(enabled) {
        __classPrivateFieldSet(this, _CDPPage_userDragInterceptionEnabled, enabled, "f");
        return __classPrivateFieldGet(this, _CDPPage_client, "f").send("Input.setInterceptDrags", { enabled });
      }
      setOfflineMode(enabled) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setOfflineMode(enabled);
      }
      emulateNetworkConditions(networkConditions) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.emulateNetworkConditions(networkConditions);
      }
      setDefaultNavigationTimeout(timeout) {
        __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").setDefaultTimeout(timeout);
      }
      getDefaultTimeout() {
        return __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout();
      }
      async $(selector) {
        return this.mainFrame().$(selector);
      }
      async $$(selector) {
        return this.mainFrame().$$(selector);
      }
      async evaluateHandle(pageFunction, ...args) {
        const context = await this.mainFrame().executionContext();
        return context.evaluateHandle(pageFunction, ...args);
      }
      async queryObjects(prototypeHandle) {
        const context = await this.mainFrame().executionContext();
        (0, assert_js_1.assert)(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
        (0, assert_js_1.assert)(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
        const response = await context._client.send("Runtime.queryObjects", {
          prototypeObjectId: prototypeHandle.id
        });
        return (0, util_js_1.createJSHandle)(context, response.objects);
      }
      async $eval(selector, pageFunction, ...args) {
        return this.mainFrame().$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        return this.mainFrame().$$eval(selector, pageFunction, ...args);
      }
      async $x(expression) {
        return this.mainFrame().$x(expression);
      }
      async cookies(...urls) {
        const originalCookies = (await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.getCookies", {
          urls: urls.length ? urls : [this.url()]
        })).cookies;
        const unsupportedCookieAttributes = ["priority"];
        const filterUnsupportedAttributes = (cookie) => {
          for (const attr of unsupportedCookieAttributes) {
            delete cookie[attr];
          }
          return cookie;
        };
        return originalCookies.map(filterUnsupportedAttributes);
      }
      async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
          const item = Object.assign({}, cookie);
          if (!cookie.url && pageURL.startsWith("http")) {
            item.url = pageURL;
          }
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.deleteCookies", item);
        }
      }
      async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith("http");
        const items = cookies.map((cookie) => {
          const item = Object.assign({}, cookie);
          if (!item.url && startsWithHTTP) {
            item.url = pageURL;
          }
          (0, assert_js_1.assert)(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
          (0, assert_js_1.assert)(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
          return item;
        });
        await this.deleteCookie(...items);
        if (items.length) {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Network.setCookies", { cookies: items });
        }
      }
      async addScriptTag(options) {
        return this.mainFrame().addScriptTag(options);
      }
      async addStyleTag(options) {
        return this.mainFrame().addStyleTag(options);
      }
      async exposeFunction(name, pptrFunction) {
        if (__classPrivateFieldGet(this, _CDPPage_bindings, "f").has(name)) {
          throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        }
        let binding;
        switch (typeof pptrFunction) {
          case "function":
            binding = new Binding_js_1.Binding(name, pptrFunction);
            break;
          default:
            binding = new Binding_js_1.Binding(name, pptrFunction.default);
            break;
        }
        __classPrivateFieldGet(this, _CDPPage_bindings, "f").set(name, binding);
        const expression = (0, util_js_1.pageBindingInitString)("exposedFun", name);
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Runtime.addBinding", { name });
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.addScriptToEvaluateOnNewDocument", {
          source: expression
        });
        await Promise.all(this.frames().map((frame) => {
          return frame.evaluate(expression).catch(util_js_1.debugError);
        }));
      }
      async authenticate(credentials) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.authenticate(credentials);
      }
      async setExtraHTTPHeaders(headers) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setExtraHTTPHeaders(headers);
      }
      async setUserAgent(userAgent, userAgentMetadata) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setUserAgent(userAgent, userAgentMetadata);
      }
      async metrics() {
        const response = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Performance.getMetrics");
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_buildMetricsObject).call(this, response.metrics);
      }
      url() {
        return this.mainFrame().url();
      }
      async content() {
        return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().content();
      }
      async setContent(html, options = {}) {
        await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().setContent(html, options);
      }
      async goto(url, options = {}) {
        return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().goto(url, options);
      }
      async reload(options) {
        const result = await Promise.all([
          this.waitForNavigation(options),
          __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.reload")
        ]);
        return result[0];
      }
      async waitForNavigation(options = {}) {
        return await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().waitForNavigation(options);
      }
      async waitForRequest(urlOrPredicate, options = {}) {
        const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
        return (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, async (request) => {
          if ((0, util_js_1.isString)(urlOrPredicate)) {
            return urlOrPredicate === request.url();
          }
          if (typeof urlOrPredicate === "function") {
            return !!await urlOrPredicate(request);
          }
          return false;
        }, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this));
      }
      async waitForResponse(urlOrPredicate, options = {}) {
        const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
        return (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async (response) => {
          if ((0, util_js_1.isString)(urlOrPredicate)) {
            return urlOrPredicate === response.url();
          }
          if (typeof urlOrPredicate === "function") {
            return !!await urlOrPredicate(response);
          }
          return false;
        }, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this));
      }
      async waitForNetworkIdle(options = {}) {
        const { idleTime = 500, timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
        const networkManager = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager;
        const idlePromise = (0, DeferredPromise_js_1.createDeferredPromise)();
        let abortRejectCallback;
        const abortPromise = new Promise((_, reject) => {
          abortRejectCallback = reject;
        });
        let idleTimer;
        const cleanup = () => {
          idleTimer && clearTimeout(idleTimer);
          abortRejectCallback(new Error("abort"));
        };
        const evaluate = () => {
          idleTimer && clearTimeout(idleTimer);
          if (networkManager.numRequestsInProgress() === 0) {
            idleTimer = setTimeout(idlePromise.resolve, idleTime);
          }
        };
        evaluate();
        const eventHandler = () => {
          evaluate();
          return false;
        };
        const listenToEvent = (event) => {
          return (0, util_js_1.waitForEvent)(networkManager, event, eventHandler, timeout, abortPromise);
        };
        const eventPromises = [
          listenToEvent(NetworkManager_js_1.NetworkManagerEmittedEvents.Request),
          listenToEvent(NetworkManager_js_1.NetworkManagerEmittedEvents.Response),
          listenToEvent(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed)
        ];
        await Promise.race([
          idlePromise,
          ...eventPromises,
          __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)
        ]).then((r) => {
          cleanup();
          return r;
        }, (error) => {
          cleanup();
          throw error;
        });
      }
      async waitForFrame(urlOrPredicate, options = {}) {
        const { timeout = __classPrivateFieldGet(this, _CDPPage_timeoutSettings, "f").timeout() } = options;
        let predicate;
        if ((0, util_js_1.isString)(urlOrPredicate)) {
          predicate = (frame) => {
            return Promise.resolve(urlOrPredicate === frame.url());
          };
        } else {
          predicate = (frame) => {
            const value = urlOrPredicate(frame);
            if (typeof value === "boolean") {
              return Promise.resolve(value);
            }
            return value;
          };
        }
        const eventRace = Promise.race([
          (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, predicate, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)),
          (0, util_js_1.waitForEvent)(__classPrivateFieldGet(this, _CDPPage_frameManager, "f"), FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, predicate, timeout, __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_sessionClosePromise).call(this)),
          ...this.frames().map(async (frame) => {
            if (await predicate(frame)) {
              return frame;
            }
            return await eventRace;
          })
        ]);
        return eventRace;
      }
      async goBack(options = {}) {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_go).call(this, -1, options);
      }
      async goForward(options = {}) {
        return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_go).call(this, 1, options);
      }
      async bringToFront() {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.bringToFront");
      }
      async setJavaScriptEnabled(enabled) {
        if (__classPrivateFieldGet(this, _CDPPage_javascriptEnabled, "f") === enabled) {
          return;
        }
        __classPrivateFieldSet(this, _CDPPage_javascriptEnabled, enabled, "f");
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setScriptExecutionDisabled", {
          value: !enabled
        });
      }
      async setBypassCSP(enabled) {
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.setBypassCSP", { enabled });
      }
      async emulateMediaType(type) {
        (0, assert_js_1.assert)(type === "screen" || type === "print" || (type !== null && type !== void 0 ? type : void 0) === void 0, "Unsupported media type: " + type);
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {
          media: type || ""
        });
      }
      async emulateCPUThrottling(factor) {
        (0, assert_js_1.assert)(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setCPUThrottlingRate", {
          rate: factor !== null ? factor : 1
        });
      }
      async emulateMediaFeatures(features) {
        if (!features) {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {});
        }
        if (Array.isArray(features)) {
          for (const mediaFeature of features) {
            const name = mediaFeature.name;
            (0, assert_js_1.assert)(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
          }
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedMedia", {
            features
          });
        }
      }
      async emulateTimezone(timezoneId) {
        try {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setTimezoneOverride", {
            timezoneId: timezoneId || ""
          });
        } catch (error) {
          if ((0, ErrorLike_js_1.isErrorLike)(error) && error.message.includes("Invalid timezone")) {
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
          }
          throw error;
        }
      }
      async emulateIdleState(overrides) {
        if (overrides) {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setIdleOverride", {
            isUserActive: overrides.isUserActive,
            isScreenUnlocked: overrides.isScreenUnlocked
          });
        } else {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.clearIdleOverride");
        }
      }
      async emulateVisionDeficiency(type) {
        const visionDeficiencies = /* @__PURE__ */ new Set([
          "none",
          "achromatopsia",
          "blurredVision",
          "deuteranopia",
          "protanopia",
          "tritanopia"
        ]);
        try {
          (0, assert_js_1.assert)(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setEmulatedVisionDeficiency", {
            type: type || "none"
          });
        } catch (error) {
          throw error;
        }
      }
      async setViewport(viewport) {
        const needsReload = await __classPrivateFieldGet(this, _CDPPage_emulationManager, "f").emulateViewport(viewport);
        __classPrivateFieldSet(this, _CDPPage_viewport, viewport, "f");
        if (needsReload) {
          await this.reload();
        }
      }
      viewport() {
        return __classPrivateFieldGet(this, _CDPPage_viewport, "f");
      }
      async evaluate(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _CDPPage_frameManager, "f").mainFrame().evaluate(pageFunction, ...args);
      }
      async evaluateOnNewDocument(pageFunction, ...args) {
        const source = (0, util_js_1.evaluationString)(pageFunction, ...args);
        await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.addScriptToEvaluateOnNewDocument", {
          source
        });
      }
      async setCacheEnabled(enabled = true) {
        await __classPrivateFieldGet(this, _CDPPage_frameManager, "f").networkManager.setCacheEnabled(enabled);
      }
      async screenshot(options = {}) {
        let screenshotType = "png";
        if (options.type) {
          screenshotType = options.type;
        } else if (options.path) {
          const filePath = options.path;
          const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
          switch (extension) {
            case "png":
              screenshotType = "png";
              break;
            case "jpeg":
            case "jpg":
              screenshotType = "jpeg";
              break;
            case "webp":
              screenshotType = "webp";
              break;
            default:
              throw new Error(`Unsupported screenshot type for extension \`.${extension}\``);
          }
        }
        if (options.quality) {
          (0, assert_js_1.assert)(screenshotType === "jpeg" || screenshotType === "webp", "options.quality is unsupported for the " + screenshotType + " screenshots");
          (0, assert_js_1.assert)(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
          (0, assert_js_1.assert)(Number.isInteger(options.quality), "Expected options.quality to be an integer");
          (0, assert_js_1.assert)(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
        }
        (0, assert_js_1.assert)(!options.clip || !options.fullPage, "options.clip and options.fullPage are exclusive");
        if (options.clip) {
          (0, assert_js_1.assert)(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
          (0, assert_js_1.assert)(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
          (0, assert_js_1.assert)(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
          (0, assert_js_1.assert)(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
          (0, assert_js_1.assert)(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
          (0, assert_js_1.assert)(options.clip.height !== 0, "Expected options.clip.height not to be 0.");
        }
        return __classPrivateFieldGet(this, _CDPPage_screenshotTaskQueue, "f").postTask(() => {
          return __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_screenshotTask).call(this, screenshotType, options);
        });
      }
      async createPDFStream(options = {}) {
        const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, timeout } = this._getPDFOptions(options);
        if (omitBackground) {
          await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_setTransparentBackgroundColor).call(this);
        }
        const printCommandPromise = __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.printToPDF", {
          transferMode: "ReturnAsStream",
          landscape,
          displayHeaderFooter,
          headerTemplate,
          footerTemplate,
          printBackground,
          scale,
          paperWidth,
          paperHeight,
          marginTop: margin.top,
          marginBottom: margin.bottom,
          marginLeft: margin.left,
          marginRight: margin.right,
          pageRanges,
          preferCSSPageSize
        });
        const result = await (0, util_js_1.waitWithTimeout)(printCommandPromise, "Page.printToPDF", timeout);
        if (omitBackground) {
          await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_resetDefaultBackgroundColor).call(this);
        }
        (0, assert_js_1.assert)(result.stream, "`stream` is missing from `Page.printToPDF");
        return (0, util_js_1.getReadableFromProtocolStream)(__classPrivateFieldGet(this, _CDPPage_client, "f"), result.stream);
      }
      async pdf(options = {}) {
        const { path = void 0 } = options;
        const readable = await this.createPDFStream(options);
        const buffer = await (0, util_js_1.getReadableAsBuffer)(readable, path);
        (0, assert_js_1.assert)(buffer, "Could not create buffer");
        return buffer;
      }
      async title() {
        return this.mainFrame().title();
      }
      async close(options = { runBeforeUnload: void 0 }) {
        const connection = __classPrivateFieldGet(this, _CDPPage_client, "f").connection();
        (0, assert_js_1.assert)(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.close");
        } else {
          await connection.send("Target.closeTarget", {
            targetId: __classPrivateFieldGet(this, _CDPPage_target, "f")._targetId
          });
          await __classPrivateFieldGet(this, _CDPPage_target, "f")._isClosedPromise;
        }
      }
      isClosed() {
        return __classPrivateFieldGet(this, _CDPPage_closed, "f");
      }
      get mouse() {
        return __classPrivateFieldGet(this, _CDPPage_mouse, "f");
      }
      click(selector, options = {}) {
        return this.mainFrame().click(selector, options);
      }
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      waitForTimeout(milliseconds) {
        return this.mainFrame().waitForTimeout(milliseconds);
      }
      async waitForSelector(selector, options = {}) {
        return await this.mainFrame().waitForSelector(selector, options);
      }
      waitForXPath(xpath, options = {}) {
        return this.mainFrame().waitForXPath(xpath, options);
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
      /**
       * This method is typically coupled with an action that triggers a device
       * request from an api such as WebBluetooth.
       *
       * :::caution
       *
       * This must be called before the device request is made. It will not return a
       * currently active device prompt.
       *
       * :::
       *
       * @example
       *
       * ```ts
       * const [devicePrompt] = Promise.all([
       *   page.waitForDevicePrompt(),
       *   page.click('#connect-bluetooth'),
       * ]);
       * await devicePrompt.select(
       *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
       * );
       * ```
       */
      waitForDevicePrompt(options = {}) {
        return this.mainFrame().waitForDevicePrompt(options);
      }
    };
    exports2.CDPPage = CDPPage;
    _CDPPage_closed = /* @__PURE__ */ new WeakMap(), _CDPPage_client = /* @__PURE__ */ new WeakMap(), _CDPPage_target = /* @__PURE__ */ new WeakMap(), _CDPPage_keyboard = /* @__PURE__ */ new WeakMap(), _CDPPage_mouse = /* @__PURE__ */ new WeakMap(), _CDPPage_timeoutSettings = /* @__PURE__ */ new WeakMap(), _CDPPage_touchscreen = /* @__PURE__ */ new WeakMap(), _CDPPage_accessibility = /* @__PURE__ */ new WeakMap(), _CDPPage_frameManager = /* @__PURE__ */ new WeakMap(), _CDPPage_emulationManager = /* @__PURE__ */ new WeakMap(), _CDPPage_tracing = /* @__PURE__ */ new WeakMap(), _CDPPage_bindings = /* @__PURE__ */ new WeakMap(), _CDPPage_coverage = /* @__PURE__ */ new WeakMap(), _CDPPage_javascriptEnabled = /* @__PURE__ */ new WeakMap(), _CDPPage_viewport = /* @__PURE__ */ new WeakMap(), _CDPPage_screenshotTaskQueue = /* @__PURE__ */ new WeakMap(), _CDPPage_workers = /* @__PURE__ */ new WeakMap(), _CDPPage_fileChooserPromises = /* @__PURE__ */ new WeakMap(), _CDPPage_disconnectPromise = /* @__PURE__ */ new WeakMap(), _CDPPage_userDragInterceptionEnabled = /* @__PURE__ */ new WeakMap(), _CDPPage_onDetachedFromTarget = /* @__PURE__ */ new WeakMap(), _CDPPage_onAttachedToTarget = /* @__PURE__ */ new WeakMap(), _CDPPage_instances = /* @__PURE__ */ new WeakSet(), _CDPPage_initialize = async function _CDPPage_initialize2() {
      try {
        await Promise.all([
          __classPrivateFieldGet(this, _CDPPage_frameManager, "f").initialize(),
          __classPrivateFieldGet(this, _CDPPage_client, "f").send("Performance.enable"),
          __classPrivateFieldGet(this, _CDPPage_client, "f").send("Log.enable")
        ]);
      } catch (err) {
        if ((0, ErrorLike_js_1.isErrorLike)(err) && (0, Connection_js_1.isTargetClosedError)(err)) {
          (0, util_js_1.debugError)(err);
        } else {
          throw err;
        }
      }
    }, _CDPPage_onFileChooser = async function _CDPPage_onFileChooser2(event) {
      if (!__classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").size) {
        return;
      }
      const frame = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").frame(event.frameId);
      (0, assert_js_1.assert)(frame, "This should never happen.");
      const handle = await frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD].adoptBackendNode(event.backendNodeId);
      const fileChooser = new FileChooser_js_1.FileChooser(handle, event);
      for (const promise of __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f")) {
        promise.resolve(fileChooser);
      }
      __classPrivateFieldGet(this, _CDPPage_fileChooserPromises, "f").clear();
    }, _CDPPage_onTargetCrashed = function _CDPPage_onTargetCrashed2() {
      this.emit("error", new Error("Page crashed!"));
    }, _CDPPage_onLogEntryAdded = function _CDPPage_onLogEntryAdded2(event) {
      const { level, text, args, source, url, lineNumber } = event.entry;
      if (args) {
        args.map((arg) => {
          return (0, util_js_1.releaseObject)(__classPrivateFieldGet(this, _CDPPage_client, "f"), arg);
        });
      }
      if (source !== "worker") {
        this.emit("console", new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{ url, lineNumber }]));
      }
    }, _CDPPage_emitMetrics = function _CDPPage_emitMetrics2(event) {
      this.emit("metrics", {
        title: event.title,
        metrics: __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_buildMetricsObject).call(this, event.metrics)
      });
    }, _CDPPage_buildMetricsObject = function _CDPPage_buildMetricsObject2(metrics) {
      const result = {};
      for (const metric of metrics || []) {
        if (supportedMetrics.has(metric.name)) {
          result[metric.name] = metric.value;
        }
      }
      return result;
    }, _CDPPage_handleException = function _CDPPage_handleException2(exceptionDetails) {
      const message = (0, util_js_1.getExceptionMessage)(exceptionDetails);
      const err = new Error(message);
      err.stack = "";
      this.emit("pageerror", err);
    }, _CDPPage_onConsoleAPI = async function _CDPPage_onConsoleAPI2(event) {
      if (event.executionContextId === 0) {
        return;
      }
      const context = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").getExecutionContextById(event.executionContextId, __classPrivateFieldGet(this, _CDPPage_client, "f"));
      if (!context) {
        (0, util_js_1.debugError)(new Error(`ExecutionContext not found for a console message: ${JSON.stringify(event)}`));
        return;
      }
      const values = event.args.map((arg) => {
        return (0, util_js_1.createJSHandle)(context, arg);
      });
      __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_addConsoleMessage).call(this, event.type, values, event.stackTrace);
    }, _CDPPage_onBindingCalled = async function _CDPPage_onBindingCalled2(event) {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name, seq, args, isTrivial } = payload;
      if (type !== "exposedFun") {
        return;
      }
      const context = __classPrivateFieldGet(this, _CDPPage_frameManager, "f").executionContextById(event.executionContextId, __classPrivateFieldGet(this, _CDPPage_client, "f"));
      if (!context) {
        return;
      }
      const binding = __classPrivateFieldGet(this, _CDPPage_bindings, "f").get(name);
      await (binding === null || binding === void 0 ? void 0 : binding.run(context, seq, args, isTrivial));
    }, _CDPPage_addConsoleMessage = function _CDPPage_addConsoleMessage2(eventType, args, stackTrace) {
      if (!this.listenerCount(
        "console"
        /* PageEmittedEvents.Console */
      )) {
        args.forEach((arg) => {
          return arg.dispose();
        });
        return;
      }
      const textTokens = [];
      for (const arg of args) {
        const remoteObject = arg.remoteObject();
        if (remoteObject.objectId) {
          textTokens.push(arg.toString());
        } else {
          textTokens.push((0, util_js_1.valueFromRemoteObject)(remoteObject));
        }
      }
      const stackTraceLocations = [];
      if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
          stackTraceLocations.push({
            url: callFrame.url,
            lineNumber: callFrame.lineNumber,
            columnNumber: callFrame.columnNumber
          });
        }
      }
      const message = new ConsoleMessage_js_1.ConsoleMessage(eventType, textTokens.join(" "), args, stackTraceLocations);
      this.emit("console", message);
    }, _CDPPage_onDialog = function _CDPPage_onDialog2(event) {
      let dialogType = null;
      const validDialogTypes = /* @__PURE__ */ new Set([
        "alert",
        "confirm",
        "prompt",
        "beforeunload"
      ]);
      if (validDialogTypes.has(event.type)) {
        dialogType = event.type;
      }
      (0, assert_js_1.assert)(dialogType, "Unknown javascript dialog type: " + event.type);
      const dialog = new Dialog_js_1.Dialog(__classPrivateFieldGet(this, _CDPPage_client, "f"), dialogType, event.message, event.defaultPrompt);
      this.emit("dialog", dialog);
    }, _CDPPage_resetDefaultBackgroundColor = /**
     * Resets default white background
     */
    async function _CDPPage_resetDefaultBackgroundColor2() {
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDefaultBackgroundColorOverride");
    }, _CDPPage_setTransparentBackgroundColor = /**
     * Hides default white background
     */
    async function _CDPPage_setTransparentBackgroundColor2() {
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDefaultBackgroundColorOverride", {
        color: { r: 0, g: 0, b: 0, a: 0 }
      });
    }, _CDPPage_sessionClosePromise = function _CDPPage_sessionClosePromise2() {
      if (!__classPrivateFieldGet(this, _CDPPage_disconnectPromise, "f")) {
        __classPrivateFieldSet(this, _CDPPage_disconnectPromise, new Promise((fulfill) => {
          return __classPrivateFieldGet(this, _CDPPage_client, "f").once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => {
            return fulfill(new Error("Target closed"));
          });
        }), "f");
      }
      return __classPrivateFieldGet(this, _CDPPage_disconnectPromise, "f");
    }, _CDPPage_go = async function _CDPPage_go2(delta, options) {
      const history = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.getNavigationHistory");
      const entry = history.entries[history.currentIndex + delta];
      if (!entry) {
        return null;
      }
      const result = await Promise.all([
        this.waitForNavigation(options),
        __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.navigateToHistoryEntry", { entryId: entry.id })
      ]);
      return result[0];
    }, _CDPPage_screenshotTask = async function _CDPPage_screenshotTask2(format, options = {}) {
      var _a, _b;
      await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Target.activateTarget", {
        targetId: __classPrivateFieldGet(this, _CDPPage_target, "f")._targetId
      });
      let clip = options.clip ? processClip(options.clip) : void 0;
      let captureBeyondViewport = (_a = options.captureBeyondViewport) !== null && _a !== void 0 ? _a : true;
      const fromSurface = options.fromSurface;
      if (options.fullPage) {
        clip = void 0;
        if (!captureBeyondViewport) {
          const metrics = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.getLayoutMetrics");
          const { width, height } = metrics.cssContentSize || metrics.contentSize;
          const { isMobile = false, deviceScaleFactor = 1, isLandscape = false } = __classPrivateFieldGet(this, _CDPPage_viewport, "f") || {};
          const screenOrientation = isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
          await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Emulation.setDeviceMetricsOverride", {
            mobile: isMobile,
            width,
            height,
            deviceScaleFactor,
            screenOrientation
          });
        }
      } else if (!clip) {
        captureBeyondViewport = false;
      }
      const shouldSetDefaultBackground = options.omitBackground && (format === "png" || format === "webp");
      if (shouldSetDefaultBackground) {
        await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_setTransparentBackgroundColor).call(this);
      }
      const result = await __classPrivateFieldGet(this, _CDPPage_client, "f").send("Page.captureScreenshot", {
        format,
        quality: options.quality,
        clip: clip && {
          ...clip,
          scale: (_b = clip.scale) !== null && _b !== void 0 ? _b : 1
        },
        captureBeyondViewport,
        fromSurface
      });
      if (shouldSetDefaultBackground) {
        await __classPrivateFieldGet(this, _CDPPage_instances, "m", _CDPPage_resetDefaultBackgroundColor).call(this);
      }
      if (options.fullPage && __classPrivateFieldGet(this, _CDPPage_viewport, "f")) {
        await this.setViewport(__classPrivateFieldGet(this, _CDPPage_viewport, "f"));
      }
      if (options.encoding === "base64") {
        return result.data;
      }
      const buffer = Buffer.from(result.data, "base64");
      await this._maybeWriteBufferToFile(options.path, buffer);
      return buffer;
      function processClip(clip2) {
        const x = Math.round(clip2.x);
        const y = Math.round(clip2.y);
        const width = Math.round(clip2.width + clip2.x - x);
        const height = Math.round(clip2.height + clip2.y - y);
        return { x, y, width, height, scale: clip2.scale };
      }
    };
    var supportedMetrics = /* @__PURE__ */ new Set([
      "Timestamp",
      "Documents",
      "Frames",
      "JSEventListeners",
      "Nodes",
      "LayoutCount",
      "RecalcStyleCount",
      "LayoutDuration",
      "RecalcStyleDuration",
      "ScriptDuration",
      "TaskDuration",
      "JSHeapUsedSize",
      "JSHeapTotalSize"
    ]);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Target.js
var require_Target = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Target.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Target_browserContext;
    var _Target_session;
    var _Target_targetInfo;
    var _Target_sessionFactory;
    var _Target_ignoreHTTPSErrors;
    var _Target_defaultViewport;
    var _Target_pagePromise;
    var _Target_workerPromise;
    var _Target_screenshotTaskQueue;
    var _Target_targetManager;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Target = void 0;
    var Page_js_1 = require_Page2();
    var WebWorker_js_1 = require_WebWorker();
    var Target = class {
      /**
       * @internal
       */
      constructor(targetInfo, session, browserContext, targetManager, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue, isPageTargetCallback) {
        _Target_browserContext.set(this, void 0);
        _Target_session.set(this, void 0);
        _Target_targetInfo.set(this, void 0);
        _Target_sessionFactory.set(this, void 0);
        _Target_ignoreHTTPSErrors.set(this, void 0);
        _Target_defaultViewport.set(this, void 0);
        _Target_pagePromise.set(this, void 0);
        _Target_workerPromise.set(this, void 0);
        _Target_screenshotTaskQueue.set(this, void 0);
        _Target_targetManager.set(this, void 0);
        __classPrivateFieldSet(this, _Target_session, session, "f");
        __classPrivateFieldSet(this, _Target_targetManager, targetManager, "f");
        __classPrivateFieldSet(this, _Target_targetInfo, targetInfo, "f");
        __classPrivateFieldSet(this, _Target_browserContext, browserContext, "f");
        this._targetId = targetInfo.targetId;
        __classPrivateFieldSet(this, _Target_sessionFactory, sessionFactory, "f");
        __classPrivateFieldSet(this, _Target_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
        __classPrivateFieldSet(this, _Target_defaultViewport, defaultViewport !== null && defaultViewport !== void 0 ? defaultViewport : void 0, "f");
        __classPrivateFieldSet(this, _Target_screenshotTaskQueue, screenshotTaskQueue, "f");
        this._isPageTargetCallback = isPageTargetCallback;
        this._initializedPromise = new Promise((fulfill) => {
          return this._initializedCallback = fulfill;
        }).then(async (success) => {
          if (!success) {
            return false;
          }
          const opener = this.opener();
          if (!opener || !__classPrivateFieldGet(opener, _Target_pagePromise, "f") || this.type() !== "page") {
            return true;
          }
          const openerPage = await __classPrivateFieldGet(opener, _Target_pagePromise, "f");
          if (!openerPage.listenerCount(
            "popup"
            /* PageEmittedEvents.Popup */
          )) {
            return true;
          }
          const popupPage = await this.page();
          openerPage.emit("popup", popupPage);
          return true;
        });
        this._isClosedPromise = new Promise((fulfill) => {
          return this._closedCallback = fulfill;
        });
        this._isInitialized = !this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) || __classPrivateFieldGet(this, _Target_targetInfo, "f").url !== "";
        if (this._isInitialized) {
          this._initializedCallback(true);
        }
      }
      /**
       * @internal
       */
      _session() {
        return __classPrivateFieldGet(this, _Target_session, "f");
      }
      /**
       * Creates a Chrome Devtools Protocol session attached to the target.
       */
      createCDPSession() {
        return __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, false);
      }
      /**
       * @internal
       */
      _targetManager() {
        return __classPrivateFieldGet(this, _Target_targetManager, "f");
      }
      /**
       * @internal
       */
      _getTargetInfo() {
        return __classPrivateFieldGet(this, _Target_targetInfo, "f");
      }
      /**
       * If the target is not of type `"page"` or `"background_page"`, returns `null`.
       */
      async page() {
        var _a;
        if (this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) && !__classPrivateFieldGet(this, _Target_pagePromise, "f")) {
          __classPrivateFieldSet(this, _Target_pagePromise, (__classPrivateFieldGet(this, _Target_session, "f") ? Promise.resolve(__classPrivateFieldGet(this, _Target_session, "f")) : __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, true)).then((client) => {
            var _a2;
            return Page_js_1.CDPPage._create(client, this, __classPrivateFieldGet(this, _Target_ignoreHTTPSErrors, "f"), (_a2 = __classPrivateFieldGet(this, _Target_defaultViewport, "f")) !== null && _a2 !== void 0 ? _a2 : null, __classPrivateFieldGet(this, _Target_screenshotTaskQueue, "f"));
          }), "f");
        }
        return (_a = await __classPrivateFieldGet(this, _Target_pagePromise, "f")) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
       */
      async worker() {
        if (__classPrivateFieldGet(this, _Target_targetInfo, "f").type !== "service_worker" && __classPrivateFieldGet(this, _Target_targetInfo, "f").type !== "shared_worker") {
          return null;
        }
        if (!__classPrivateFieldGet(this, _Target_workerPromise, "f")) {
          __classPrivateFieldSet(this, _Target_workerPromise, (__classPrivateFieldGet(this, _Target_session, "f") ? Promise.resolve(__classPrivateFieldGet(this, _Target_session, "f")) : __classPrivateFieldGet(this, _Target_sessionFactory, "f").call(this, false)).then((client) => {
            return new WebWorker_js_1.WebWorker(
              client,
              __classPrivateFieldGet(this, _Target_targetInfo, "f").url,
              () => {
              },
              () => {
              }
              /* exceptionThrown */
            );
          }), "f");
        }
        return __classPrivateFieldGet(this, _Target_workerPromise, "f");
      }
      url() {
        return __classPrivateFieldGet(this, _Target_targetInfo, "f").url;
      }
      /**
       * Identifies what kind of target this is.
       *
       * @remarks
       *
       * See {@link https://developer.chrome.com/extensions/background_pages | docs} for more info about background pages.
       */
      type() {
        const type = __classPrivateFieldGet(this, _Target_targetInfo, "f").type;
        if (type === "page" || type === "background_page" || type === "service_worker" || type === "shared_worker" || type === "browser" || type === "webview") {
          return type;
        }
        return "other";
      }
      /**
       * Get the browser the target belongs to.
       */
      browser() {
        return __classPrivateFieldGet(this, _Target_browserContext, "f").browser();
      }
      /**
       * Get the browser context the target belongs to.
       */
      browserContext() {
        return __classPrivateFieldGet(this, _Target_browserContext, "f");
      }
      /**
       * Get the target that opened this target. Top-level targets return `null`.
       */
      opener() {
        const { openerId } = __classPrivateFieldGet(this, _Target_targetInfo, "f");
        if (!openerId) {
          return;
        }
        return this.browser()._targets.get(openerId);
      }
      /**
       * @internal
       */
      _targetInfoChanged(targetInfo) {
        __classPrivateFieldSet(this, _Target_targetInfo, targetInfo, "f");
        if (!this._isInitialized && (!this._isPageTargetCallback(__classPrivateFieldGet(this, _Target_targetInfo, "f")) || __classPrivateFieldGet(this, _Target_targetInfo, "f").url !== "")) {
          this._isInitialized = true;
          this._initializedCallback(true);
          return;
        }
      }
    };
    exports2.Target = Target;
    _Target_browserContext = /* @__PURE__ */ new WeakMap(), _Target_session = /* @__PURE__ */ new WeakMap(), _Target_targetInfo = /* @__PURE__ */ new WeakMap(), _Target_sessionFactory = /* @__PURE__ */ new WeakMap(), _Target_ignoreHTTPSErrors = /* @__PURE__ */ new WeakMap(), _Target_defaultViewport = /* @__PURE__ */ new WeakMap(), _Target_pagePromise = /* @__PURE__ */ new WeakMap(), _Target_workerPromise = /* @__PURE__ */ new WeakMap(), _Target_screenshotTaskQueue = /* @__PURE__ */ new WeakMap(), _Target_targetManager = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TaskQueue.js
var require_TaskQueue = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/TaskQueue.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TaskQueue_chain;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskQueue = void 0;
    var TaskQueue = class {
      constructor() {
        _TaskQueue_chain.set(this, void 0);
        __classPrivateFieldSet(this, _TaskQueue_chain, Promise.resolve(), "f");
      }
      postTask(task) {
        const result = __classPrivateFieldGet(this, _TaskQueue_chain, "f").then(task);
        __classPrivateFieldSet(this, _TaskQueue_chain, result.then(() => {
          return void 0;
        }, () => {
          return void 0;
        }), "f");
        return result;
      }
    };
    exports2.TaskQueue = TaskQueue;
    _TaskQueue_chain = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Browser.js
var require_Browser2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Browser.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _CDPBrowser_instances;
    var _CDPBrowser_ignoreHTTPSErrors;
    var _CDPBrowser_defaultViewport;
    var _CDPBrowser_process;
    var _CDPBrowser_connection;
    var _CDPBrowser_closeCallback;
    var _CDPBrowser_targetFilterCallback;
    var _CDPBrowser_isPageTargetCallback;
    var _CDPBrowser_defaultContext;
    var _CDPBrowser_contexts;
    var _CDPBrowser_screenshotTaskQueue;
    var _CDPBrowser_targetManager;
    var _CDPBrowser_emitDisconnected;
    var _CDPBrowser_setIsPageTargetCallback;
    var _CDPBrowser_createTarget;
    var _CDPBrowser_onAttachedToTarget;
    var _CDPBrowser_onDetachedFromTarget;
    var _CDPBrowser_onTargetChanged;
    var _CDPBrowser_onTargetDiscovered;
    var _CDPBrowser_getVersion;
    var _CDPBrowserContext_connection;
    var _CDPBrowserContext_browser;
    var _CDPBrowserContext_id;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CDPBrowserContext = exports2.CDPBrowser = void 0;
    var Browser_js_1 = require_Browser();
    var BrowserContext_js_1 = require_BrowserContext();
    var assert_js_1 = require_assert();
    var DeferredPromise_js_1 = require_DeferredPromise();
    var ChromeTargetManager_js_1 = require_ChromeTargetManager();
    var Connection_js_1 = require_Connection();
    var FirefoxTargetManager_js_1 = require_FirefoxTargetManager();
    var Target_js_1 = require_Target();
    var TaskQueue_js_1 = require_TaskQueue();
    var util_js_1 = require_util2();
    var CDPBrowser = class extends Browser_js_1.Browser {
      /**
       * @internal
       */
      static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback) {
        const browser = new CDPBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback);
        await browser._attach();
        return browser;
      }
      /**
       * @internal
       */
      get _targets() {
        return __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets();
      }
      /**
       * @internal
       */
      constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback) {
        super();
        _CDPBrowser_instances.add(this);
        _CDPBrowser_ignoreHTTPSErrors.set(this, void 0);
        _CDPBrowser_defaultViewport.set(this, void 0);
        _CDPBrowser_process.set(this, void 0);
        _CDPBrowser_connection.set(this, void 0);
        _CDPBrowser_closeCallback.set(this, void 0);
        _CDPBrowser_targetFilterCallback.set(this, void 0);
        _CDPBrowser_isPageTargetCallback.set(this, void 0);
        _CDPBrowser_defaultContext.set(this, void 0);
        _CDPBrowser_contexts.set(this, void 0);
        _CDPBrowser_screenshotTaskQueue.set(this, void 0);
        _CDPBrowser_targetManager.set(this, void 0);
        _CDPBrowser_emitDisconnected.set(this, () => {
          this.emit(
            "disconnected"
            /* BrowserEmittedEvents.Disconnected */
          );
        });
        _CDPBrowser_createTarget.set(this, (targetInfo, session) => {
          var _a;
          const { browserContextId } = targetInfo;
          const context = browserContextId && __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").has(browserContextId) ? __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").get(browserContextId) : __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f");
          if (!context) {
            throw new Error("Missing browser context");
          }
          return new Target_js_1.Target(targetInfo, session, context, __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f"), (isAutoAttachEmulated) => {
            return __classPrivateFieldGet(this, _CDPBrowser_connection, "f")._createSession(targetInfo, isAutoAttachEmulated);
          }, __classPrivateFieldGet(this, _CDPBrowser_ignoreHTTPSErrors, "f"), (_a = __classPrivateFieldGet(this, _CDPBrowser_defaultViewport, "f")) !== null && _a !== void 0 ? _a : null, __classPrivateFieldGet(this, _CDPBrowser_screenshotTaskQueue, "f"), __classPrivateFieldGet(this, _CDPBrowser_isPageTargetCallback, "f"));
        });
        _CDPBrowser_onAttachedToTarget.set(this, async (target) => {
          if (await target._initializedPromise) {
            this.emit("targetcreated", target);
            target.browserContext().emit("targetcreated", target);
          }
        });
        _CDPBrowser_onDetachedFromTarget.set(this, async (target) => {
          target._initializedCallback(false);
          target._closedCallback();
          if (await target._initializedPromise) {
            this.emit("targetdestroyed", target);
            target.browserContext().emit("targetdestroyed", target);
          }
        });
        _CDPBrowser_onTargetChanged.set(this, ({ target, targetInfo }) => {
          const previousURL = target.url();
          const wasInitialized = target._isInitialized;
          target._targetInfoChanged(targetInfo);
          if (wasInitialized && previousURL !== target.url()) {
            this.emit("targetchanged", target);
            target.browserContext().emit("targetchanged", target);
          }
        });
        _CDPBrowser_onTargetDiscovered.set(this, (targetInfo) => {
          this.emit("targetdiscovered", targetInfo);
        });
        product = product || "chrome";
        __classPrivateFieldSet(this, _CDPBrowser_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
        __classPrivateFieldSet(this, _CDPBrowser_defaultViewport, defaultViewport, "f");
        __classPrivateFieldSet(this, _CDPBrowser_process, process2, "f");
        __classPrivateFieldSet(this, _CDPBrowser_screenshotTaskQueue, new TaskQueue_js_1.TaskQueue(), "f");
        __classPrivateFieldSet(this, _CDPBrowser_connection, connection, "f");
        __classPrivateFieldSet(this, _CDPBrowser_closeCallback, closeCallback || function() {
        }, "f");
        __classPrivateFieldSet(this, _CDPBrowser_targetFilterCallback, targetFilterCallback || (() => {
          return true;
        }), "f");
        __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_setIsPageTargetCallback).call(this, isPageTargetCallback);
        if (product === "firefox") {
          __classPrivateFieldSet(this, _CDPBrowser_targetManager, new FirefoxTargetManager_js_1.FirefoxTargetManager(connection, __classPrivateFieldGet(this, _CDPBrowser_createTarget, "f"), __classPrivateFieldGet(this, _CDPBrowser_targetFilterCallback, "f")), "f");
        } else {
          __classPrivateFieldSet(this, _CDPBrowser_targetManager, new ChromeTargetManager_js_1.ChromeTargetManager(connection, __classPrivateFieldGet(this, _CDPBrowser_createTarget, "f"), __classPrivateFieldGet(this, _CDPBrowser_targetFilterCallback, "f")), "f");
        }
        __classPrivateFieldSet(this, _CDPBrowser_defaultContext, new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this), "f");
        __classPrivateFieldSet(this, _CDPBrowser_contexts, /* @__PURE__ */ new Map(), "f");
        for (const contextId of contextIds) {
          __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").set(contextId, new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this, contextId));
        }
      }
      /**
       * @internal
       */
      async _attach() {
        __classPrivateFieldGet(this, _CDPBrowser_connection, "f").on(Connection_js_1.ConnectionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _CDPBrowser_emitDisconnected, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetAvailable", __classPrivateFieldGet(this, _CDPBrowser_onAttachedToTarget, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetGone", __classPrivateFieldGet(this, _CDPBrowser_onDetachedFromTarget, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetChanged", __classPrivateFieldGet(this, _CDPBrowser_onTargetChanged, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").on("targetDiscovered", __classPrivateFieldGet(this, _CDPBrowser_onTargetDiscovered, "f"));
        await __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").initialize();
      }
      /**
       * @internal
       */
      _detach() {
        __classPrivateFieldGet(this, _CDPBrowser_connection, "f").off(Connection_js_1.ConnectionEmittedEvents.Disconnected, __classPrivateFieldGet(this, _CDPBrowser_emitDisconnected, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetAvailable", __classPrivateFieldGet(this, _CDPBrowser_onAttachedToTarget, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetGone", __classPrivateFieldGet(this, _CDPBrowser_onDetachedFromTarget, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetChanged", __classPrivateFieldGet(this, _CDPBrowser_onTargetChanged, "f"));
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").off("targetDiscovered", __classPrivateFieldGet(this, _CDPBrowser_onTargetDiscovered, "f"));
      }
      /**
       * The spawned browser process. Returns `null` if the browser instance was created with
       * {@link Puppeteer.connect}.
       */
      process() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _CDPBrowser_process, "f")) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * @internal
       */
      _targetManager() {
        return __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f");
      }
      /**
       * @internal
       */
      _getIsPageTargetCallback() {
        return __classPrivateFieldGet(this, _CDPBrowser_isPageTargetCallback, "f");
      }
      /**
       * Creates a new incognito browser context. This won't share cookies/cache with other
       * browser contexts.
       *
       * @example
       *
       * ```ts
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   // Create a new incognito browser context.
       *   const context = await browser.createIncognitoBrowserContext();
       *   // Create a new page in a pristine context.
       *   const page = await context.newPage();
       *   // Do stuff
       *   await page.goto('https://example.com');
       * })();
       * ```
       */
      async createIncognitoBrowserContext(options = {}) {
        const { proxyServer, proxyBypassList } = options;
        const { browserContextId } = await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.createBrowserContext", {
          proxyServer,
          proxyBypassList: proxyBypassList && proxyBypassList.join(",")
        });
        const context = new CDPBrowserContext(__classPrivateFieldGet(this, _CDPBrowser_connection, "f"), this, browserContextId);
        __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").set(browserContextId, context);
        return context;
      }
      /**
       * Returns an array of all open browser contexts. In a newly created browser, this will
       * return a single instance of {@link BrowserContext}.
       */
      browserContexts() {
        return [__classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f"), ...Array.from(__classPrivateFieldGet(this, _CDPBrowser_contexts, "f").values())];
      }
      /**
       * Returns the default browser context. The default browser context cannot be closed.
       */
      defaultBrowserContext() {
        return __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f");
      }
      /**
       * @internal
       */
      async _disposeContext(contextId) {
        if (!contextId) {
          return;
        }
        await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.disposeBrowserContext", {
          browserContextId: contextId
        });
        __classPrivateFieldGet(this, _CDPBrowser_contexts, "f").delete(contextId);
      }
      /**
       * The browser websocket endpoint which can be used as an argument to
       * {@link Puppeteer.connect}.
       *
       * @returns The Browser websocket url.
       *
       * @remarks
       *
       * The format is `ws://${host}:${port}/devtools/browser/<id>`.
       *
       * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
       * Learn more about the
       * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
       * the {@link
       * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
       * | browser endpoint}.
       */
      wsEndpoint() {
        return __classPrivateFieldGet(this, _CDPBrowser_connection, "f").url();
      }
      /**
       * Promise which resolves to a new {@link Page} object. The Page is created in
       * a default browser context.
       */
      async newPage() {
        return __classPrivateFieldGet(this, _CDPBrowser_defaultContext, "f").newPage();
      }
      /**
       * @internal
       */
      async _createPageInContext(contextId) {
        const { targetId } = await __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Target.createTarget", {
          url: "about:blank",
          browserContextId: contextId || void 0
        });
        const target = __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets().get(targetId);
        if (!target) {
          throw new Error(`Missing target for page (id = ${targetId})`);
        }
        const initialized = await target._initializedPromise;
        if (!initialized) {
          throw new Error(`Failed to create target for page (id = ${targetId})`);
        }
        const page = await target.page();
        if (!page) {
          throw new Error(`Failed to create a page for context (id = ${contextId})`);
        }
        return page;
      }
      /**
       * All active targets inside the Browser. In case of multiple browser contexts, returns
       * an array with all the targets in all browser contexts.
       */
      targets() {
        return Array.from(__classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").getAvailableTargets().values()).filter((target) => {
          return target._isInitialized;
        });
      }
      /**
       * The target associated with the browser.
       */
      target() {
        const browserTarget = this.targets().find((target) => {
          return target.type() === "browser";
        });
        if (!browserTarget) {
          throw new Error("Browser target is not found");
        }
        return browserTarget;
      }
      /**
       * Searches for a target in all browser contexts.
       *
       * @param predicate - A function to be run for every target.
       * @returns The first target found that matches the `predicate` function.
       *
       * @example
       *
       * An example of finding a target for a page opened via `window.open`:
       *
       * ```ts
       * await page.evaluate(() => window.open('https://www.example.com/'));
       * const newWindowTarget = await browser.waitForTarget(
       *   target => target.url() === 'https://www.example.com/'
       * );
       * ```
       */
      async waitForTarget(predicate, options = {}) {
        const { timeout = 3e4 } = options;
        const targetPromise = (0, DeferredPromise_js_1.createDeferredPromise)();
        this.on("targetcreated", check);
        this.on("targetchanged", check);
        try {
          this.targets().forEach(check);
          if (!timeout) {
            return await targetPromise;
          }
          return await (0, util_js_1.waitWithTimeout)(targetPromise, "target", timeout);
        } finally {
          this.off("targetcreated", check);
          this.off("targetchanged", check);
        }
        async function check(target) {
          if (await predicate(target) && !targetPromise.resolved()) {
            targetPromise.resolve(target);
          }
        }
      }
      /**
       * An array of all open pages inside the Browser.
       *
       * @remarks
       *
       * In case of multiple browser contexts, returns an array with all the pages in all
       * browser contexts. Non-visible pages, such as `"background_page"`, will not be listed
       * here. You can find them using {@link Target.page}.
       */
      async pages() {
        const contextPages = await Promise.all(this.browserContexts().map((context) => {
          return context.pages();
        }));
        return contextPages.reduce((acc, x) => {
          return acc.concat(x);
        }, []);
      }
      async version() {
        const version = await __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_getVersion).call(this);
        return version.product;
      }
      /**
       * The browser's original user agent. Pages can override the browser user agent with
       * {@link Page.setUserAgent}.
       */
      async userAgent() {
        const version = await __classPrivateFieldGet(this, _CDPBrowser_instances, "m", _CDPBrowser_getVersion).call(this);
        return version.userAgent;
      }
      async close() {
        await __classPrivateFieldGet(this, _CDPBrowser_closeCallback, "f").call(null);
        this.disconnect();
      }
      disconnect() {
        __classPrivateFieldGet(this, _CDPBrowser_targetManager, "f").dispose();
        __classPrivateFieldGet(this, _CDPBrowser_connection, "f").dispose();
        this._detach();
      }
      /**
       * Indicates that the browser is connected.
       */
      isConnected() {
        return !__classPrivateFieldGet(this, _CDPBrowser_connection, "f")._closed;
      }
    };
    exports2.CDPBrowser = CDPBrowser;
    _CDPBrowser_ignoreHTTPSErrors = /* @__PURE__ */ new WeakMap(), _CDPBrowser_defaultViewport = /* @__PURE__ */ new WeakMap(), _CDPBrowser_process = /* @__PURE__ */ new WeakMap(), _CDPBrowser_connection = /* @__PURE__ */ new WeakMap(), _CDPBrowser_closeCallback = /* @__PURE__ */ new WeakMap(), _CDPBrowser_targetFilterCallback = /* @__PURE__ */ new WeakMap(), _CDPBrowser_isPageTargetCallback = /* @__PURE__ */ new WeakMap(), _CDPBrowser_defaultContext = /* @__PURE__ */ new WeakMap(), _CDPBrowser_contexts = /* @__PURE__ */ new WeakMap(), _CDPBrowser_screenshotTaskQueue = /* @__PURE__ */ new WeakMap(), _CDPBrowser_targetManager = /* @__PURE__ */ new WeakMap(), _CDPBrowser_emitDisconnected = /* @__PURE__ */ new WeakMap(), _CDPBrowser_createTarget = /* @__PURE__ */ new WeakMap(), _CDPBrowser_onAttachedToTarget = /* @__PURE__ */ new WeakMap(), _CDPBrowser_onDetachedFromTarget = /* @__PURE__ */ new WeakMap(), _CDPBrowser_onTargetChanged = /* @__PURE__ */ new WeakMap(), _CDPBrowser_onTargetDiscovered = /* @__PURE__ */ new WeakMap(), _CDPBrowser_instances = /* @__PURE__ */ new WeakSet(), _CDPBrowser_setIsPageTargetCallback = function _CDPBrowser_setIsPageTargetCallback2(isPageTargetCallback) {
      __classPrivateFieldSet(this, _CDPBrowser_isPageTargetCallback, isPageTargetCallback || ((target) => {
        return target.type === "page" || target.type === "background_page" || target.type === "webview";
      }), "f");
    }, _CDPBrowser_getVersion = function _CDPBrowser_getVersion2() {
      return __classPrivateFieldGet(this, _CDPBrowser_connection, "f").send("Browser.getVersion");
    };
    var CDPBrowserContext = class extends BrowserContext_js_1.BrowserContext {
      /**
       * @internal
       */
      constructor(connection, browser, contextId) {
        super();
        _CDPBrowserContext_connection.set(this, void 0);
        _CDPBrowserContext_browser.set(this, void 0);
        _CDPBrowserContext_id.set(this, void 0);
        __classPrivateFieldSet(this, _CDPBrowserContext_connection, connection, "f");
        __classPrivateFieldSet(this, _CDPBrowserContext_browser, browser, "f");
        __classPrivateFieldSet(this, _CDPBrowserContext_id, contextId, "f");
      }
      get id() {
        return __classPrivateFieldGet(this, _CDPBrowserContext_id, "f");
      }
      /**
       * An array of all active targets inside the browser context.
       */
      targets() {
        return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f").targets().filter((target) => {
          return target.browserContext() === this;
        });
      }
      /**
       * This searches for a target in this specific browser context.
       *
       * @example
       * An example of finding a target for a page opened via `window.open`:
       *
       * ```ts
       * await page.evaluate(() => window.open('https://www.example.com/'));
       * const newWindowTarget = await browserContext.waitForTarget(
       *   target => target.url() === 'https://www.example.com/'
       * );
       * ```
       *
       * @param predicate - A function to be run for every target
       * @param options - An object of options. Accepts a timeout,
       * which is the maximum wait time in milliseconds.
       * Pass `0` to disable the timeout. Defaults to 30 seconds.
       * @returns Promise which resolves to the first target found
       * that matches the `predicate` function.
       */
      waitForTarget(predicate, options = {}) {
        return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f").waitForTarget((target) => {
          return target.browserContext() === this && predicate(target);
        }, options);
      }
      /**
       * An array of all pages inside the browser context.
       *
       * @returns Promise which resolves to an array of all open pages.
       * Non visible pages, such as `"background_page"`, will not be listed here.
       * You can find them using {@link Target.page | the target page}.
       */
      async pages() {
        const pages = await Promise.all(this.targets().filter((target) => {
          var _a;
          return target.type() === "page" || target.type() === "other" && ((_a = __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._getIsPageTargetCallback()) === null || _a === void 0 ? void 0 : _a(target._getTargetInfo()));
        }).map((target) => {
          return target.page();
        }));
        return pages.filter((page) => {
          return !!page;
        });
      }
      /**
       * Returns whether BrowserContext is incognito.
       * The default browser context is the only non-incognito browser context.
       *
       * @remarks
       * The default browser context cannot be closed.
       */
      isIncognito() {
        return !!__classPrivateFieldGet(this, _CDPBrowserContext_id, "f");
      }
      /**
       * @example
       *
       * ```ts
       * const context = browser.defaultBrowserContext();
       * await context.overridePermissions('https://html5demos.com', [
       *   'geolocation',
       * ]);
       * ```
       *
       * @param origin - The origin to grant permissions to, e.g. "https://example.com".
       * @param permissions - An array of permissions to grant.
       * All permissions that are not listed here will be automatically denied.
       */
      async overridePermissions(origin, permissions) {
        const protocolPermissions = permissions.map((permission) => {
          const protocolPermission = Browser_js_1.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
          if (!protocolPermission) {
            throw new Error("Unknown permission: " + permission);
          }
          return protocolPermission;
        });
        await __classPrivateFieldGet(this, _CDPBrowserContext_connection, "f").send("Browser.grantPermissions", {
          origin,
          browserContextId: __classPrivateFieldGet(this, _CDPBrowserContext_id, "f") || void 0,
          permissions: protocolPermissions
        });
      }
      /**
       * Clears all permission overrides for the browser context.
       *
       * @example
       *
       * ```ts
       * const context = browser.defaultBrowserContext();
       * context.overridePermissions('https://example.com', ['clipboard-read']);
       * // do stuff ..
       * context.clearPermissionOverrides();
       * ```
       */
      async clearPermissionOverrides() {
        await __classPrivateFieldGet(this, _CDPBrowserContext_connection, "f").send("Browser.resetPermissions", {
          browserContextId: __classPrivateFieldGet(this, _CDPBrowserContext_id, "f") || void 0
        });
      }
      /**
       * Creates a new page in the browser context.
       */
      newPage() {
        return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._createPageInContext(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"));
      }
      /**
       * The browser this browser context belongs to.
       */
      browser() {
        return __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f");
      }
      /**
       * Closes the browser context. All the targets that belong to the browser context
       * will be closed.
       *
       * @remarks
       * Only incognito browser contexts can be closed.
       */
      async close() {
        (0, assert_js_1.assert)(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"), "Non-incognito profiles cannot be closed!");
        await __classPrivateFieldGet(this, _CDPBrowserContext_browser, "f")._disposeContext(__classPrivateFieldGet(this, _CDPBrowserContext_id, "f"));
      }
    };
    exports2.CDPBrowserContext = CDPBrowserContext;
    _CDPBrowserContext_connection = /* @__PURE__ */ new WeakMap(), _CDPBrowserContext_browser = /* @__PURE__ */ new WeakMap(), _CDPBrowserContext_id = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch(url, opts) {
      if (!fetch.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch.Promise;
      return new fetch.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch.Promise = global.Promise;
    module2.exports = exports2 = fetch;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports2, module2) {
    var nodeFetch = require_lib2();
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    fetch.ponyfill = true;
    module2.exports = exports2 = fetch;
    exports2.fetch = fetch;
    exports2.Headers = nodeFetch.Headers;
    exports2.Request = nodeFetch.Request;
    exports2.Response = nodeFetch.Response;
    exports2.default = fetch;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/fetch.js
var require_fetch = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/fetch.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFetch = void 0;
    var getFetch = async () => {
      return globalThis.fetch || (await Promise.resolve().then(() => __importStar(require_node_ponyfill()))).fetch;
    };
    exports2.getFetch = getFetch;
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants2();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants2();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants2();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants2();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/generated/version.js
var require_version = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/generated/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.packageVersion = void 0;
    exports2.packageVersion = "20.1.0";
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/NodeWebSocketTransport.js
var require_NodeWebSocketTransport = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/NodeWebSocketTransport.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _NodeWebSocketTransport_ws;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeWebSocketTransport = void 0;
    var ws_1 = __importDefault(require_ws());
    var version_js_1 = require_version();
    var NodeWebSocketTransport = class {
      static create(url, headers) {
        return new Promise((resolve, reject) => {
          const ws = new ws_1.default(url, [], {
            followRedirects: true,
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
            headers: {
              "User-Agent": `Puppeteer ${version_js_1.packageVersion}`,
              ...headers
            }
          });
          ws.addEventListener("open", () => {
            return resolve(new NodeWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      constructor(ws) {
        _NodeWebSocketTransport_ws.set(this, void 0);
        __classPrivateFieldSet(this, _NodeWebSocketTransport_ws, ws, "f");
        __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").addEventListener("error", () => {
        });
      }
      send(message) {
        __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").send(message);
      }
      close() {
        __classPrivateFieldGet(this, _NodeWebSocketTransport_ws, "f").close();
      }
    };
    exports2.NodeWebSocketTransport = NodeWebSocketTransport;
    _NodeWebSocketTransport_ws = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserWebSocketTransport.js
var require_BrowserWebSocketTransport = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserWebSocketTransport.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _BrowserWebSocketTransport_ws;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserWebSocketTransport = void 0;
    var BrowserWebSocketTransport = class {
      static create(url) {
        return new Promise((resolve, reject) => {
          const ws = new WebSocket(url);
          ws.addEventListener("open", () => {
            return resolve(new BrowserWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      constructor(ws) {
        _BrowserWebSocketTransport_ws.set(this, void 0);
        __classPrivateFieldSet(this, _BrowserWebSocketTransport_ws, ws, "f");
        __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").addEventListener("error", () => {
        });
      }
      send(message) {
        __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").send(message);
      }
      close() {
        __classPrivateFieldGet(this, _BrowserWebSocketTransport_ws, "f").close();
      }
    };
    exports2.BrowserWebSocketTransport = BrowserWebSocketTransport;
    _BrowserWebSocketTransport_ws = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserConnector.js
var require_BrowserConnector = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/BrowserConnector.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._connectToCDPBrowser = void 0;
    var environment_js_1 = require_environment();
    var assert_js_1 = require_assert();
    var ErrorLike_js_1 = require_ErrorLike();
    var Browser_js_1 = require_Browser2();
    var Connection_js_1 = require_Connection();
    var fetch_js_1 = require_fetch();
    var util_js_1 = require_util2();
    var getWebSocketTransportClass = async () => {
      return environment_js_1.isNode ? (await Promise.resolve().then(() => __importStar(require_NodeWebSocketTransport()))).NodeWebSocketTransport : (await Promise.resolve().then(() => __importStar(require_BrowserWebSocketTransport()))).BrowserWebSocketTransport;
    };
    async function _connectToCDPBrowser(options) {
      const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, headers = {}, slowMo = 0, targetFilter, _isPageTarget: isPageTarget, protocolTimeout } = options;
      (0, assert_js_1.assert)(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
      let connection;
      if (transport) {
        connection = new Connection_js_1.Connection("", transport, slowMo, protocolTimeout);
      } else if (browserWSEndpoint) {
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
        connection = new Connection_js_1.Connection(browserWSEndpoint, connectionTransport, slowMo, protocolTimeout);
      } else if (browserURL) {
        const connectionURL = await getWSEndpoint(browserURL);
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(connectionURL);
        connection = new Connection_js_1.Connection(connectionURL, connectionTransport, slowMo, protocolTimeout);
      }
      const version = await connection.send("Browser.getVersion");
      const product = version.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
      const { browserContextIds } = await connection.send("Target.getBrowserContexts");
      const browser = await Browser_js_1.CDPBrowser._create(product || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
        return connection.send("Browser.close").catch(util_js_1.debugError);
      }, targetFilter, isPageTarget);
      return browser;
    }
    exports2._connectToCDPBrowser = _connectToCDPBrowser;
    async function getWSEndpoint(browserURL) {
      const endpointURL = new URL("/json/version", browserURL);
      const fetch = await (0, fetch_js_1.getFetch)();
      try {
        const result = await fetch(endpointURL.toString(), {
          method: "GET"
        });
        if (!result.ok) {
          throw new Error(`HTTP ${result.statusText}`);
        }
        const data = await result.json();
        return data.webSocketDebuggerUrl;
      } catch (error) {
        if ((0, ErrorLike_js_1.isErrorLike)(error)) {
          error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
        }
        throw error;
      }
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Configuration.js
var require_Configuration = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/ConnectionTransport.js
var require_ConnectionTransport = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/ConnectionTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Device.js
var require_Device = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Device.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.devices = exports2.KnownDevices = void 0;
    var knownDevices = [
      {
        name: "Blackberry PlayBook",
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        viewport: {
          width: 600,
          height: 1024,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Blackberry PlayBook landscape",
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        viewport: {
          width: 1024,
          height: 600,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "BlackBerry Z30",
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "BlackBerry Z30 landscape",
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy Note 3",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy Note 3 landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy Note II",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy Note II landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy S III",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy S III landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy S5",
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy S5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy S8",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 740,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy S8 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        viewport: {
          width: 740,
          height: 360,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy S9+",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        viewport: {
          width: 320,
          height: 658,
          deviceScaleFactor: 4.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy S9+ landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        viewport: {
          width: 658,
          height: 320,
          deviceScaleFactor: 4.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Galaxy Tab S4",
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        viewport: {
          width: 712,
          height: 1138,
          deviceScaleFactor: 2.25,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Galaxy Tab S4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        viewport: {
          width: 1138,
          height: 712,
          deviceScaleFactor: 2.25,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 768,
          height: 1024,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 1024,
          height: 768,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad (gen 6)",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad (gen 6) landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad (gen 7)",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 810,
          height: 1080,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad (gen 7) landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1080,
          height: 810,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad Mini",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 768,
          height: 1024,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad Mini landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 1024,
          height: 768,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad Pro",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 1024,
          height: 1366,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad Pro landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
          width: 1366,
          height: 1024,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPad Pro 11",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 834,
          height: 1194,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPad Pro 11 landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1194,
          height: 834,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 4",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        viewport: {
          width: 320,
          height: 480,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 4 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        viewport: {
          width: 480,
          height: 320,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 5",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 5 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 6",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 6 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 6 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 6 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 7",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 7 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 7 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 7 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 8",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 8 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 8 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 8 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone SE",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone SE landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone X",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 812,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone X landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 812,
          height: 375,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone XR",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone XR landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 11",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 828,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 11 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 828,
          height: 414,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 11 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 375,
          height: 812,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 11 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 812,
          height: 375,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 11 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 11 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 12",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 390,
          height: 844,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 12 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 844,
          height: 390,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 12 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 390,
          height: 844,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 12 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 844,
          height: 390,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 12 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 428,
          height: 926,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 12 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 926,
          height: 428,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 12 Mini",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 375,
          height: 812,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 12 Mini landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 812,
          height: 375,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 13",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 390,
          height: 844,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 13 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 844,
          height: 390,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 13 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 390,
          height: 844,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 13 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 844,
          height: 390,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 13 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 428,
          height: 926,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 13 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 926,
          height: 428,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "iPhone 13 Mini",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 375,
          height: 812,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "iPhone 13 Mini landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 812,
          height: 375,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "JioPhone 2",
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        viewport: {
          width: 240,
          height: 320,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "JioPhone 2 landscape",
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        viewport: {
          width: 320,
          height: 240,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Kindle Fire HDX",
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 800,
          height: 1280,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Kindle Fire HDX landscape",
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 1280,
          height: 800,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "LG Optimus L70",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640,
          deviceScaleFactor: 1.25,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "LG Optimus L70 landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384,
          deviceScaleFactor: 1.25,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Microsoft Lumia 550",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Microsoft Lumia 950",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 4,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Microsoft Lumia 950 landscape",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 4,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 10",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
          width: 800,
          height: 1280,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 10 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
          width: 1280,
          height: 800,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 4",
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 5",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 5X",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732,
          deviceScaleFactor: 2.625,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 5X landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412,
          deviceScaleFactor: 2.625,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 6",
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 6 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 6P",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 6P landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nexus 7",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
          width: 600,
          height: 960,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nexus 7 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
          width: 960,
          height: 600,
          deviceScaleFactor: 2,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nokia Lumia 520",
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 320,
          height: 533,
          deviceScaleFactor: 1.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nokia Lumia 520 landscape",
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 533,
          height: 320,
          deviceScaleFactor: 1.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Nokia N9",
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 480,
          height: 854,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Nokia N9 landscape",
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 854,
          height: 480,
          deviceScaleFactor: 1,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 2",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 731,
          deviceScaleFactor: 2.625,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 2 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 731,
          height: 411,
          deviceScaleFactor: 2.625,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 2 XL",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 823,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 2 XL landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
          width: 823,
          height: 411,
          deviceScaleFactor: 3.5,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 3",
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 786,
          deviceScaleFactor: 2.75,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 3 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        viewport: {
          width: 786,
          height: 393,
          deviceScaleFactor: 2.75,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 4",
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 4a (5G)",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 4a (5G) landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Pixel 5",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 851,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Pixel 5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 851,
          height: 393,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      },
      {
        name: "Moto G4",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: false
        }
      },
      {
        name: "Moto G4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360,
          deviceScaleFactor: 3,
          isMobile: true,
          hasTouch: true,
          isLandscape: true
        }
      }
    ];
    var knownDevicesByName = {};
    for (const device of knownDevices) {
      knownDevicesByName[device.name] = device;
    }
    exports2.KnownDevices = Object.freeze(knownDevicesByName);
    exports2.devices = exports2.KnownDevices;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PredefinedNetworkConditions.js
var require_PredefinedNetworkConditions = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/PredefinedNetworkConditions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.networkConditions = exports2.PredefinedNetworkConditions = void 0;
    exports2.PredefinedNetworkConditions = Object.freeze({
      "Slow 3G": {
        download: 500 * 1e3 / 8 * 0.8,
        upload: 500 * 1e3 / 8 * 0.8,
        latency: 400 * 5
      },
      "Fast 3G": {
        download: 1.6 * 1e3 * 1e3 / 8 * 0.9,
        upload: 750 * 1e3 / 8 * 0.9,
        latency: 150 * 3.75
      }
    });
    exports2.networkConditions = exports2.PredefinedNetworkConditions;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Product.js
var require_Product = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Product.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/Puppeteer.js
var require_Puppeteer = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/Puppeteer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Puppeteer = void 0;
    var BrowserConnector_js_1 = require_BrowserConnector();
    var CustomQueryHandler_js_1 = require_CustomQueryHandler();
    var Puppeteer = class {
      /**
       * Registers a {@link CustomQueryHandler | custom query handler}.
       *
       * @remarks
       * After registration, the handler can be used everywhere where a selector is
       * expected by prepending the selection string with `<name>/`. The name is only
       * allowed to consist of lower- and upper case latin letters.
       *
       * @example
       *
       * ```
       * puppeteer.registerCustomQueryHandler('text', {  });
       * const aHandle = await page.$('text/');
       * ```
       *
       * @param name - The name that the custom query handler will be registered
       * under.
       * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
       * to register.
       *
       * @public
       */
      static registerCustomQueryHandler(name, queryHandler) {
        return this.customQueryHandlers.register(name, queryHandler);
      }
      /**
       * Unregisters a custom query handler for a given name.
       */
      static unregisterCustomQueryHandler(name) {
        return this.customQueryHandlers.unregister(name);
      }
      /**
       * Gets the names of all custom query handlers.
       */
      static customQueryHandlerNames() {
        return this.customQueryHandlers.names();
      }
      /**
       * Unregisters all custom query handlers.
       */
      static clearCustomQueryHandlers() {
        return this.customQueryHandlers.clear();
      }
      /**
       * @internal
       */
      constructor(settings) {
        this._changedProduct = false;
        this._isPuppeteerCore = settings.isPuppeteerCore;
        this.connect = this.connect.bind(this);
      }
      /**
       * This method attaches Puppeteer to an existing browser instance.
       *
       * @remarks
       *
       * @param options - Set of configurable options to set on the browser.
       * @returns Promise which resolves to browser instance.
       */
      connect(options) {
        return (0, BrowserConnector_js_1._connectToCDPBrowser)(options);
      }
    };
    exports2.Puppeteer = Puppeteer;
    Puppeteer.customQueryHandlers = CustomQueryHandler_js_1.customQueryHandlers;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/PuppeteerViewport.js
var require_PuppeteerViewport = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/PuppeteerViewport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/TargetManager.js
var require_TargetManager = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/TargetManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/types.js
var require_types = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/common.js
var require_common2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/common.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Accessibility(), exports2);
    __exportStar(require_AriaQueryHandler(), exports2);
    __exportStar(require_Browser2(), exports2);
    __exportStar(require_BrowserConnector(), exports2);
    __exportStar(require_BrowserWebSocketTransport(), exports2);
    __exportStar(require_ChromeTargetManager(), exports2);
    __exportStar(require_Configuration(), exports2);
    __exportStar(require_Connection(), exports2);
    __exportStar(require_ConnectionTransport(), exports2);
    __exportStar(require_ConsoleMessage(), exports2);
    __exportStar(require_Coverage(), exports2);
    __exportStar(require_CustomQueryHandler(), exports2);
    __exportStar(require_Debug(), exports2);
    __exportStar(require_Device(), exports2);
    __exportStar(require_DeviceRequestPrompt(), exports2);
    __exportStar(require_Dialog(), exports2);
    __exportStar(require_ElementHandle2(), exports2);
    __exportStar(require_EmulationManager(), exports2);
    __exportStar(require_Errors(), exports2);
    __exportStar(require_EventEmitter(), exports2);
    __exportStar(require_ExecutionContext(), exports2);
    __exportStar(require_fetch(), exports2);
    __exportStar(require_FileChooser(), exports2);
    __exportStar(require_FirefoxTargetManager(), exports2);
    __exportStar(require_Frame(), exports2);
    __exportStar(require_FrameManager(), exports2);
    __exportStar(require_FrameTree(), exports2);
    __exportStar(require_Input(), exports2);
    __exportStar(require_IsolatedWorld(), exports2);
    __exportStar(require_IsolatedWorlds(), exports2);
    __exportStar(require_JSHandle2(), exports2);
    __exportStar(require_LazyArg(), exports2);
    __exportStar(require_LifecycleWatcher(), exports2);
    __exportStar(require_NetworkEventManager(), exports2);
    __exportStar(require_NetworkManager(), exports2);
    __exportStar(require_NodeWebSocketTransport(), exports2);
    __exportStar(require_Page2(), exports2);
    __exportStar(require_PDFOptions(), exports2);
    __exportStar(require_PredefinedNetworkConditions(), exports2);
    __exportStar(require_Product(), exports2);
    __exportStar(require_Puppeteer(), exports2);
    __exportStar(require_PuppeteerViewport(), exports2);
    __exportStar(require_SecurityDetails(), exports2);
    __exportStar(require_Target(), exports2);
    __exportStar(require_TargetManager(), exports2);
    __exportStar(require_TaskQueue(), exports2);
    __exportStar(require_TimeoutSettings(), exports2);
    __exportStar(require_Tracing(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_USKeyboardLayout(), exports2);
    __exportStar(require_util2(), exports2);
    __exportStar(require_WaitTask(), exports2);
    __exportStar(require_WebWorker(), exports2);
    __exportStar(require_QueryHandler(), exports2);
  }
});

// node_modules/https-proxy-agent/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/https-proxy-agent/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/https-proxy-agent/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/https-proxy-agent/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/https-proxy-agent/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/https-proxy-agent/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/https-proxy-agent/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/https-proxy-agent/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/https-proxy-agent/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/https-proxy-agent/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/agent-base/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/agent-base/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/agent-base/node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "node_modules/agent-base/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms3();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/agent-base/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/agent-base/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/agent-base/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/agent-base/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/agent-base/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/agent-base/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src4 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src3());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src2());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src2());
    var agent_base_1 = require_src4();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/httpUtil.js
var require_httpUtil = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/httpUtil.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.downloadFile = exports2.httpRequest = exports2.headHttpRequest = void 0;
    var fs_1 = require("fs");
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var url_1 = require("url");
    var https_proxy_agent_1 = __importDefault(require_dist());
    var proxy_from_env_1 = require_proxy_from_env();
    function headHttpRequest(url) {
      return new Promise((resolve) => {
        const request = httpRequest(url, "HEAD", (response) => {
          resolve(response.statusCode === 200);
        }, false);
        request.on("error", () => {
          resolve(false);
        });
      });
    }
    exports2.headHttpRequest = headHttpRequest;
    function httpRequest(url, method, response, keepAlive = true) {
      var _a;
      var _b;
      const options = {
        protocol: url.protocol,
        hostname: url.hostname,
        port: url.port,
        path: url.pathname + url.search,
        method,
        headers: keepAlive ? { Connection: "keep-alive" } : void 0
      };
      const proxyURL = (0, proxy_from_env_1.getProxyForUrl)(url.toString());
      if (proxyURL) {
        const proxy = new url_1.URL(proxyURL);
        if (proxy.protocol === "http:") {
          options.path = url.href;
          options.hostname = proxy.hostname;
          options.protocol = proxy.protocol;
          options.port = proxy.port;
          (_a = options.headers) !== null && _a !== void 0 ? _a : options.headers = {};
          (_b = options.headers)["Host"] || (_b["Host"] = url.host);
        } else {
          options.agent = (0, https_proxy_agent_1.default)({
            host: proxy.host,
            path: proxy.pathname,
            port: proxy.port,
            secureProxy: proxy.protocol === "https:",
            headers: options.headers
          });
        }
      }
      const requestCallback = (res) => {
        if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
          httpRequest(new url_1.URL(res.headers.location), method, response);
        } else {
          response(res);
        }
      };
      const request = options.protocol === "https:" ? https.request(options, requestCallback) : http.request(options, requestCallback);
      request.end();
      return request;
    }
    exports2.httpRequest = httpRequest;
    function downloadFile(url, destinationPath, progressCallback) {
      return new Promise((resolve, reject) => {
        let downloadedBytes = 0;
        let totalBytes = 0;
        function onData(chunk) {
          downloadedBytes += chunk.length;
          progressCallback(downloadedBytes, totalBytes);
        }
        const request = httpRequest(url, "GET", (response) => {
          if (response.statusCode !== 200) {
            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
            response.resume();
            reject(error);
            return;
          }
          const file = (0, fs_1.createWriteStream)(destinationPath);
          file.on("finish", () => {
            return resolve();
          });
          file.on("error", (error) => {
            return reject(error);
          });
          response.pipe(file);
          totalBytes = parseInt(response.headers["content-length"], 10);
          if (progressCallback) {
            response.on("data", onData);
          }
        });
        request.on("error", (error) => {
          return reject(error);
        });
      });
    }
    exports2.downloadFile = downloadFile;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/firefox.js
var require_firefox = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/firefox.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProfile = exports2.resolveBuildId = exports2.relativeExecutablePath = exports2.resolveDownloadPath = exports2.resolveDownloadUrl = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var httpUtil_js_1 = require_httpUtil();
    var types_js_1 = require_types2();
    function archive(platform, buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return `firefox-${buildId}.en-US.${platform}-x86_64.tar.bz2`;
        case types_js_1.BrowserPlatform.MAC_ARM:
        case types_js_1.BrowserPlatform.MAC:
          return `firefox-${buildId}.en-US.mac.dmg`;
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return `firefox-${buildId}.en-US.${platform}.zip`;
      }
    }
    function resolveDownloadUrl(platform, buildId, baseUrl = "https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central") {
      return `${baseUrl}/${resolveDownloadPath(platform, buildId).join("/")}`;
    }
    exports2.resolveDownloadUrl = resolveDownloadUrl;
    function resolveDownloadPath(platform, buildId) {
      return [archive(platform, buildId)];
    }
    exports2.resolveDownloadPath = resolveDownloadPath;
    function relativeExecutablePath(platform, _buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.MAC_ARM:
        case types_js_1.BrowserPlatform.MAC:
          return path_1.default.join("Firefox Nightly.app", "Contents", "MacOS", "firefox");
        case types_js_1.BrowserPlatform.LINUX:
          return path_1.default.join("firefox", "firefox");
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return path_1.default.join("firefox", "firefox.exe");
      }
    }
    exports2.relativeExecutablePath = relativeExecutablePath;
    async function resolveBuildId(channel = "FIREFOX_NIGHTLY") {
      return new Promise((resolve, reject) => {
        const request = (0, httpUtil_js_1.httpRequest)(new URL("https://product-details.mozilla.org/1.0/firefox_versions.json"), "GET", (response) => {
          let data = "";
          if (response.statusCode && response.statusCode >= 400) {
            return reject(new Error(`Got status code ${response.statusCode}`));
          }
          response.on("data", (chunk) => {
            data += chunk;
          });
          response.on("end", () => {
            try {
              const versions = JSON.parse(data);
              return resolve(versions[channel]);
            } catch {
              return reject(new Error("Firefox version not found"));
            }
          });
        }, false);
        request.on("error", (err) => {
          reject(err);
        });
      });
    }
    exports2.resolveBuildId = resolveBuildId;
    async function createProfile(options) {
      if (!fs_1.default.existsSync(options.path)) {
        await fs_1.default.promises.mkdir(options.path, {
          recursive: true
        });
      }
      await writePreferences({
        preferences: {
          ...defaultProfilePreferences(options.preferences),
          ...options.preferences
        },
        path: options.path
      });
    }
    exports2.createProfile = createProfile;
    function defaultProfilePreferences(extraPrefs) {
      const server = "dummy.test";
      const defaultPrefs = {
        // Make sure Shield doesn't hit the network.
        "app.normandy.api_url": "",
        // Disable Firefox old build background check
        "app.update.checkInstallTime": false,
        // Disable automatically upgrading Firefox
        "app.update.disabledForTesting": true,
        // Increase the APZ content response timeout to 1 minute
        "apz.content_response_timeout": 6e4,
        // Prevent various error message on the console
        // jest-puppeteer asserts that no error message is emitted by the console
        "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cm,-fp",
        // Enable the dump function: which sends messages to the system
        // console
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
        "browser.dom.window.dump.enabled": true,
        // Disable topstories
        "browser.newtabpage.activity-stream.feeds.system.topstories": false,
        // Always display a blank page
        "browser.newtabpage.enabled": false,
        // Background thumbnails in particular cause grief: and disabling
        // thumbnails in general cannot hurt
        "browser.pagethumbnails.capturing_disabled": true,
        // Disable safebrowsing components.
        "browser.safebrowsing.blockedURIs.enabled": false,
        "browser.safebrowsing.downloads.enabled": false,
        "browser.safebrowsing.malware.enabled": false,
        "browser.safebrowsing.passwords.enabled": false,
        "browser.safebrowsing.phishing.enabled": false,
        // Disable updates to search engines.
        "browser.search.update": false,
        // Do not restore the last open set of tabs if the browser has crashed
        "browser.sessionstore.resume_from_crash": false,
        // Skip check for default browser on startup
        "browser.shell.checkDefaultBrowser": false,
        // Disable newtabpage
        "browser.startup.homepage": "about:blank",
        // Do not redirect user when a milstone upgrade of Firefox is detected
        "browser.startup.homepage_override.mstone": "ignore",
        // Start with a blank page about:blank
        "browser.startup.page": 0,
        // Do not allow background tabs to be zombified on Android: otherwise for
        // tests that open additional tabs: the test harness tab itself might get
        // unloaded
        "browser.tabs.disableBackgroundZombification": false,
        // Do not warn when closing all other open tabs
        "browser.tabs.warnOnCloseOtherTabs": false,
        // Do not warn when multiple tabs will be opened
        "browser.tabs.warnOnOpen": false,
        // Disable the UI tour.
        "browser.uitour.enabled": false,
        // Turn off search suggestions in the location bar so as not to trigger
        // network connections.
        "browser.urlbar.suggest.searches": false,
        // Disable first run splash page on Windows 10
        "browser.usedOnWindows10.introURL": "",
        // Do not warn on quitting Firefox
        "browser.warnOnQuit": false,
        // Defensively disable data reporting systems
        "datareporting.healthreport.documentServerURI": `http://${server}/dummy/healthreport/`,
        "datareporting.healthreport.logging.consoleEnabled": false,
        "datareporting.healthreport.service.enabled": false,
        "datareporting.healthreport.service.firstRun": false,
        "datareporting.healthreport.uploadEnabled": false,
        // Do not show datareporting policy notifications which can interfere with tests
        "datareporting.policy.dataSubmissionEnabled": false,
        "datareporting.policy.dataSubmissionPolicyBypassNotification": true,
        // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
        // This doesn't affect Puppeteer but spams console (Bug 1424372)
        "devtools.jsonview.enabled": false,
        // Disable popup-blocker
        "dom.disable_open_during_load": false,
        // Enable the support for File object creation in the content process
        // Required for |Page.setFileInputFiles| protocol method.
        "dom.file.createInChild": true,
        // Disable the ProcessHangMonitor
        "dom.ipc.reportProcessHangs": false,
        // Disable slow script dialogues
        "dom.max_chrome_script_run_time": 0,
        "dom.max_script_run_time": 0,
        // Only load extensions from the application and user profile
        // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
        "extensions.autoDisableScopes": 0,
        "extensions.enabledScopes": 5,
        // Disable metadata caching for installed add-ons by default
        "extensions.getAddons.cache.enabled": false,
        // Disable installing any distribution extensions or add-ons.
        "extensions.installDistroAddons": false,
        // Disabled screenshots extension
        "extensions.screenshots.disabled": true,
        // Turn off extension updates so they do not bother tests
        "extensions.update.enabled": false,
        // Turn off extension updates so they do not bother tests
        "extensions.update.notifyUser": false,
        // Make sure opening about:addons will not hit the network
        "extensions.webservice.discoverURL": `http://${server}/dummy/discoveryURL`,
        // Temporarily force disable BFCache in parent (https://bit.ly/bug-1732263)
        "fission.bfcacheInParent": false,
        // Force all web content to use a single content process
        "fission.webContentIsolationStrategy": 0,
        // Allow the application to have focus even it runs in the background
        "focusmanager.testmode": true,
        // Disable useragent updates
        "general.useragent.updates.enabled": false,
        // Always use network provider for geolocation tests so we bypass the
        // macOS dialog raised by the corelocation provider
        "geo.provider.testing": true,
        // Do not scan Wifi
        "geo.wifi.scan": false,
        // No hang monitor
        "hangmonitor.timeout": 0,
        // Show chrome errors and warnings in the error console
        "javascript.options.showInConsole": true,
        // Disable download and usage of OpenH264: and Widevine plugins
        "media.gmp-manager.updateEnabled": false,
        // Prevent various error message on the console
        // jest-puppeteer asserts that no error message is emitted by the console
        "network.cookie.cookieBehavior": 0,
        // Disable experimental feature that is only available in Nightly
        "network.cookie.sameSite.laxByDefault": false,
        // Do not prompt for temporary redirects
        "network.http.prompt-temp-redirect": false,
        // Disable speculative connections so they are not reported as leaking
        // when they are hanging around
        "network.http.speculative-parallel-limit": 0,
        // Do not automatically switch between offline and online
        "network.manage-offline-status": false,
        // Make sure SNTP requests do not hit the network
        "network.sntp.pools": server,
        // Disable Flash.
        "plugin.state.flash": 0,
        "privacy.trackingprotection.enabled": false,
        // Can be removed once Firefox 89 is no longer supported
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1710839
        "remote.enabled": true,
        // Don't do network connections for mitm priming
        "security.certerrors.mitm.priming.enabled": false,
        // Local documents have access to all other local documents,
        // including directory listings
        "security.fileuri.strict_origin_policy": false,
        // Do not wait for the notification button security delay
        "security.notification_enable_delay": 0,
        // Ensure blocklist updates do not hit the network
        "services.settings.server": `http://${server}/dummy/blocklist/`,
        // Do not automatically fill sign-in forms with known usernames and
        // passwords
        "signon.autofillForms": false,
        // Disable password capture, so that tests that include forms are not
        // influenced by the presence of the persistent doorhanger notification
        "signon.rememberSignons": false,
        // Disable first-run welcome page
        "startup.homepage_welcome_url": "about:blank",
        // Disable first-run welcome page
        "startup.homepage_welcome_url.additional": "",
        // Disable browser animations (tabs, fullscreen, sliding alerts)
        "toolkit.cosmeticAnimations.enabled": false,
        // Prevent starting into safe mode after application crashes
        "toolkit.startup.max_resumed_crashes": -1
      };
      return Object.assign(defaultPrefs, extraPrefs);
    }
    async function writePreferences(options) {
      const lines = Object.entries(options.preferences).map(([key, value]) => {
        return `user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`;
      });
      await fs_1.default.promises.writeFile(path_1.default.join(options.path, "user.js"), lines.join("\n"));
      const prefsPath = path_1.default.join(options.path, "prefs.js");
      if (fs_1.default.existsSync(prefsPath)) {
        const prefsBackupPath = path_1.default.join(options.path, "prefs.js.puppeteer");
        await fs_1.default.promises.copyFile(prefsPath, prefsBackupPath);
      }
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/types.js
var require_types2 = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/types.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChromeReleaseChannel = exports2.BrowserTag = exports2.downloadUrls = exports2.BrowserPlatform = exports2.Browser = void 0;
    var chrome = __importStar(require_chrome());
    var firefox = __importStar(require_firefox());
    var Browser;
    (function(Browser2) {
      Browser2["CHROME"] = "chrome";
      Browser2["CHROMIUM"] = "chromium";
      Browser2["FIREFOX"] = "firefox";
      Browser2["CHROMEDRIVER"] = "chromedriver";
    })(Browser = exports2.Browser || (exports2.Browser = {}));
    var BrowserPlatform;
    (function(BrowserPlatform2) {
      BrowserPlatform2["LINUX"] = "linux";
      BrowserPlatform2["MAC"] = "mac";
      BrowserPlatform2["MAC_ARM"] = "mac_arm";
      BrowserPlatform2["WIN32"] = "win32";
      BrowserPlatform2["WIN64"] = "win64";
    })(BrowserPlatform = exports2.BrowserPlatform || (exports2.BrowserPlatform = {}));
    exports2.downloadUrls = {
      [Browser.CHROME]: chrome.resolveDownloadUrl,
      [Browser.CHROMIUM]: chrome.resolveDownloadUrl,
      [Browser.FIREFOX]: firefox.resolveDownloadUrl
    };
    var BrowserTag;
    (function(BrowserTag2) {
      BrowserTag2["LATEST"] = "latest";
    })(BrowserTag = exports2.BrowserTag || (exports2.BrowserTag = {}));
    var ChromeReleaseChannel;
    (function(ChromeReleaseChannel2) {
      ChromeReleaseChannel2["STABLE"] = "stable";
      ChromeReleaseChannel2["DEV"] = "dev";
      ChromeReleaseChannel2["CANARY"] = "canary";
      ChromeReleaseChannel2["BETA"] = "beta";
    })(ChromeReleaseChannel = exports2.ChromeReleaseChannel || (exports2.ChromeReleaseChannel = {}));
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/chrome.js
var require_chrome = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/chrome.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSystemExecutablePath = exports2.resolveBuildId = exports2.relativeExecutablePath = exports2.resolveDownloadPath = exports2.resolveDownloadUrl = void 0;
    var path_1 = __importDefault(require("path"));
    var httpUtil_js_1 = require_httpUtil();
    var types_js_1 = require_types2();
    function folder(platform) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return "linux64";
        case types_js_1.BrowserPlatform.MAC_ARM:
          return "mac-arm64";
        case types_js_1.BrowserPlatform.MAC:
          return "mac-x64";
        case types_js_1.BrowserPlatform.WIN32:
          return "win32";
        case types_js_1.BrowserPlatform.WIN64:
          return "win64";
      }
    }
    function chromiumDashPlatform(platform) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return "linux";
        case types_js_1.BrowserPlatform.MAC_ARM:
          return "mac";
        case types_js_1.BrowserPlatform.MAC:
          return "mac";
        case types_js_1.BrowserPlatform.WIN32:
          return "win";
        case types_js_1.BrowserPlatform.WIN64:
          return "win64";
      }
    }
    function resolveDownloadUrl(platform, buildId, baseUrl = "https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing") {
      return `${baseUrl}/${resolveDownloadPath(platform, buildId).join("/")}`;
    }
    exports2.resolveDownloadUrl = resolveDownloadUrl;
    function resolveDownloadPath(platform, buildId) {
      return [buildId, folder(platform), `chrome-${folder(platform)}.zip`];
    }
    exports2.resolveDownloadPath = resolveDownloadPath;
    function relativeExecutablePath(platform, _buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.MAC:
        case types_js_1.BrowserPlatform.MAC_ARM:
          return path_1.default.join("chrome-" + folder(platform), "Google Chrome for Testing.app", "Contents", "MacOS", "Google Chrome for Testing");
        case types_js_1.BrowserPlatform.LINUX:
          return path_1.default.join("chrome-linux64", "chrome");
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return path_1.default.join("chrome-" + folder(platform), "chrome.exe");
      }
    }
    exports2.relativeExecutablePath = relativeExecutablePath;
    async function resolveBuildId(platform, channel = "beta") {
      return new Promise((resolve, reject) => {
        const request = (0, httpUtil_js_1.httpRequest)(new URL(`https://chromiumdash.appspot.com/fetch_releases?platform=${chromiumDashPlatform(platform)}&channel=${channel}`), "GET", (response) => {
          let data = "";
          if (response.statusCode && response.statusCode >= 400) {
            return reject(new Error(`Got status code ${response.statusCode}`));
          }
          response.on("data", (chunk) => {
            data += chunk;
          });
          response.on("end", () => {
            try {
              const response2 = JSON.parse(String(data));
              return resolve(response2[0].version);
            } catch {
              return reject(new Error("Chrome version not found"));
            }
          });
        }, false);
        request.on("error", (err) => {
          reject(err);
        });
      });
    }
    exports2.resolveBuildId = resolveBuildId;
    function resolveSystemExecutablePath(platform, channel) {
      switch (platform) {
        case types_js_1.BrowserPlatform.WIN64:
        case types_js_1.BrowserPlatform.WIN32:
          switch (channel) {
            case types_js_1.ChromeReleaseChannel.STABLE:
              return `${process.env["PROGRAMFILES"]}\\Google\\Chrome\\Application\\chrome.exe`;
            case types_js_1.ChromeReleaseChannel.BETA:
              return `${process.env["PROGRAMFILES"]}\\Google\\Chrome Beta\\Application\\chrome.exe`;
            case types_js_1.ChromeReleaseChannel.CANARY:
              return `${process.env["PROGRAMFILES"]}\\Google\\Chrome SxS\\Application\\chrome.exe`;
            case types_js_1.ChromeReleaseChannel.DEV:
              return `${process.env["PROGRAMFILES"]}\\Google\\Chrome Dev\\Application\\chrome.exe`;
          }
        case types_js_1.BrowserPlatform.MAC_ARM:
        case types_js_1.BrowserPlatform.MAC:
          switch (channel) {
            case types_js_1.ChromeReleaseChannel.STABLE:
              return "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
            case types_js_1.ChromeReleaseChannel.BETA:
              return "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta";
            case types_js_1.ChromeReleaseChannel.CANARY:
              return "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary";
            case types_js_1.ChromeReleaseChannel.DEV:
              return "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev";
          }
        case types_js_1.BrowserPlatform.LINUX:
          switch (channel) {
            case types_js_1.ChromeReleaseChannel.STABLE:
              return "/opt/google/chrome/chrome";
            case types_js_1.ChromeReleaseChannel.BETA:
              return "/opt/google/chrome-beta/chrome";
            case types_js_1.ChromeReleaseChannel.DEV:
              return "/opt/google/chrome-unstable/chrome";
          }
      }
      throw new Error(`Unable to detect browser executable path for '${channel}' on ${platform}.`);
    }
    exports2.resolveSystemExecutablePath = resolveSystemExecutablePath;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/chromedriver.js
var require_chromedriver = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/chromedriver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveBuildId = exports2.relativeExecutablePath = exports2.resolveDownloadPath = exports2.resolveDownloadUrl = void 0;
    var httpUtil_js_1 = require_httpUtil();
    var types_js_1 = require_types2();
    function archive(platform) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return "chromedriver_linux64";
        case types_js_1.BrowserPlatform.MAC_ARM:
          return "chromedriver_mac_arm64";
        case types_js_1.BrowserPlatform.MAC:
          return "chromedriver_mac64";
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return "chromedriver_win32";
      }
    }
    function resolveDownloadUrl(platform, buildId, baseUrl = "https://chromedriver.storage.googleapis.com") {
      return `${baseUrl}/${resolveDownloadPath(platform, buildId).join("/")}`;
    }
    exports2.resolveDownloadUrl = resolveDownloadUrl;
    function resolveDownloadPath(platform, buildId) {
      return [buildId, `${archive(platform)}.zip`];
    }
    exports2.resolveDownloadPath = resolveDownloadPath;
    function relativeExecutablePath(platform, _buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.MAC:
        case types_js_1.BrowserPlatform.MAC_ARM:
        case types_js_1.BrowserPlatform.LINUX:
          return "chromedriver";
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return "chromedriver.exe";
      }
    }
    exports2.relativeExecutablePath = relativeExecutablePath;
    async function resolveBuildId(_channel = "latest") {
      return new Promise((resolve, reject) => {
        const request = (0, httpUtil_js_1.httpRequest)(new URL(`https://chromedriver.storage.googleapis.com/LATEST_RELEASE`), "GET", (response) => {
          let data = "";
          if (response.statusCode && response.statusCode >= 400) {
            return reject(new Error(`Got status code ${response.statusCode}`));
          }
          response.on("data", (chunk) => {
            data += chunk;
          });
          response.on("end", () => {
            try {
              return resolve(String(data));
            } catch {
              return reject(new Error("Chrome version not found"));
            }
          });
        }, false);
        request.on("error", (err) => {
          reject(err);
        });
      });
    }
    exports2.resolveBuildId = resolveBuildId;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/chromium.js
var require_chromium = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/chromium.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveBuildId = exports2.relativeExecutablePath = exports2.resolveDownloadPath = exports2.resolveDownloadUrl = exports2.resolveSystemExecutablePath = void 0;
    var path_1 = __importDefault(require("path"));
    var httpUtil_js_1 = require_httpUtil();
    var types_js_1 = require_types2();
    var chrome_js_1 = require_chrome();
    Object.defineProperty(exports2, "resolveSystemExecutablePath", { enumerable: true, get: function() {
      return chrome_js_1.resolveSystemExecutablePath;
    } });
    function archive(platform, buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return "chrome-linux";
        case types_js_1.BrowserPlatform.MAC_ARM:
        case types_js_1.BrowserPlatform.MAC:
          return "chrome-mac";
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return parseInt(buildId, 10) > 591479 ? "chrome-win" : "chrome-win32";
      }
    }
    function folder(platform) {
      switch (platform) {
        case types_js_1.BrowserPlatform.LINUX:
          return "Linux_x64";
        case types_js_1.BrowserPlatform.MAC_ARM:
          return "Mac_Arm";
        case types_js_1.BrowserPlatform.MAC:
          return "Mac";
        case types_js_1.BrowserPlatform.WIN32:
          return "Win";
        case types_js_1.BrowserPlatform.WIN64:
          return "Win_x64";
      }
    }
    function resolveDownloadUrl(platform, buildId, baseUrl = "https://storage.googleapis.com/chromium-browser-snapshots") {
      return `${baseUrl}/${resolveDownloadPath(platform, buildId).join("/")}`;
    }
    exports2.resolveDownloadUrl = resolveDownloadUrl;
    function resolveDownloadPath(platform, buildId) {
      return [folder(platform), buildId, `${archive(platform, buildId)}.zip`];
    }
    exports2.resolveDownloadPath = resolveDownloadPath;
    function relativeExecutablePath(platform, _buildId) {
      switch (platform) {
        case types_js_1.BrowserPlatform.MAC:
        case types_js_1.BrowserPlatform.MAC_ARM:
          return path_1.default.join("chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium");
        case types_js_1.BrowserPlatform.LINUX:
          return path_1.default.join("chrome-linux", "chrome");
        case types_js_1.BrowserPlatform.WIN32:
        case types_js_1.BrowserPlatform.WIN64:
          return path_1.default.join("chrome-win", "chrome.exe");
      }
    }
    exports2.relativeExecutablePath = relativeExecutablePath;
    async function resolveBuildId(platform, _channel = "latest") {
      return new Promise((resolve, reject) => {
        const request = (0, httpUtil_js_1.httpRequest)(new URL(`https://storage.googleapis.com/chromium-browser-snapshots/${folder(platform)}/LAST_CHANGE`), "GET", (response) => {
          let data = "";
          if (response.statusCode && response.statusCode >= 400) {
            return reject(new Error(`Got status code ${response.statusCode}`));
          }
          response.on("data", (chunk) => {
            data += chunk;
          });
          response.on("end", () => {
            try {
              return resolve(String(data));
            } catch {
              return reject(new Error("Chrome version not found"));
            }
          });
        }, false);
        request.on("error", (err) => {
          reject(err);
        });
      });
    }
    exports2.resolveBuildId = resolveBuildId;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/browser-data/browser-data.js
var require_browser_data = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/browser-data/browser-data.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSystemExecutablePath = exports2.createProfile = exports2.resolveBuildId = exports2.ChromeReleaseChannel = exports2.BrowserPlatform = exports2.Browser = exports2.executablePathByBrowser = exports2.downloadPaths = exports2.downloadUrls = void 0;
    var chrome = __importStar(require_chrome());
    var chromedriver = __importStar(require_chromedriver());
    var chromium = __importStar(require_chromium());
    var firefox = __importStar(require_firefox());
    var types_js_1 = require_types2();
    Object.defineProperty(exports2, "Browser", { enumerable: true, get: function() {
      return types_js_1.Browser;
    } });
    Object.defineProperty(exports2, "BrowserPlatform", { enumerable: true, get: function() {
      return types_js_1.BrowserPlatform;
    } });
    Object.defineProperty(exports2, "ChromeReleaseChannel", { enumerable: true, get: function() {
      return types_js_1.ChromeReleaseChannel;
    } });
    exports2.downloadUrls = {
      [types_js_1.Browser.CHROMEDRIVER]: chromedriver.resolveDownloadUrl,
      [types_js_1.Browser.CHROME]: chrome.resolveDownloadUrl,
      [types_js_1.Browser.CHROMIUM]: chromium.resolveDownloadUrl,
      [types_js_1.Browser.FIREFOX]: firefox.resolveDownloadUrl
    };
    exports2.downloadPaths = {
      [types_js_1.Browser.CHROMEDRIVER]: chromedriver.resolveDownloadPath,
      [types_js_1.Browser.CHROME]: chrome.resolveDownloadPath,
      [types_js_1.Browser.CHROMIUM]: chromium.resolveDownloadPath,
      [types_js_1.Browser.FIREFOX]: firefox.resolveDownloadPath
    };
    exports2.executablePathByBrowser = {
      [types_js_1.Browser.CHROMEDRIVER]: chromedriver.relativeExecutablePath,
      [types_js_1.Browser.CHROME]: chrome.relativeExecutablePath,
      [types_js_1.Browser.CHROMIUM]: chromium.relativeExecutablePath,
      [types_js_1.Browser.FIREFOX]: firefox.relativeExecutablePath
    };
    async function resolveBuildId(browser, platform, tag) {
      switch (browser) {
        case types_js_1.Browser.FIREFOX:
          switch (tag) {
            case types_js_1.BrowserTag.LATEST:
              return await firefox.resolveBuildId("FIREFOX_NIGHTLY");
          }
        case types_js_1.Browser.CHROME:
          switch (tag) {
            case types_js_1.BrowserTag.LATEST:
              return await chrome.resolveBuildId(platform, "beta");
          }
        case types_js_1.Browser.CHROMEDRIVER:
          switch (tag) {
            case types_js_1.BrowserTag.LATEST:
              return await chromedriver.resolveBuildId("latest");
          }
        case types_js_1.Browser.CHROMIUM:
          switch (tag) {
            case types_js_1.BrowserTag.LATEST:
              return await chromium.resolveBuildId(platform, "latest");
          }
      }
      return tag;
    }
    exports2.resolveBuildId = resolveBuildId;
    async function createProfile(browser, opts) {
      switch (browser) {
        case types_js_1.Browser.FIREFOX:
          return await firefox.createProfile(opts);
        case types_js_1.Browser.CHROME:
        case types_js_1.Browser.CHROMIUM:
          throw new Error(`Profile creation is not support for ${browser} yet`);
      }
    }
    exports2.createProfile = createProfile;
    function resolveSystemExecutablePath(browser, platform, channel) {
      switch (browser) {
        case types_js_1.Browser.CHROMEDRIVER:
        case types_js_1.Browser.FIREFOX:
          throw new Error(`System browser detection is not supported for ${browser} yet.`);
        case types_js_1.Browser.CHROME:
          return chromium.resolveSystemExecutablePath(platform, channel);
        case types_js_1.Browser.CHROMIUM:
          return chrome.resolveSystemExecutablePath(platform, channel);
      }
    }
    exports2.resolveSystemExecutablePath = resolveSystemExecutablePath;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/Cache.js
var require_Cache = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/Cache.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Cache_rootDir;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var browser_data_js_1 = require_browser_data();
    var Cache = class {
      constructor(rootDir) {
        _Cache_rootDir.set(this, void 0);
        __classPrivateFieldSet(this, _Cache_rootDir, rootDir, "f");
      }
      browserRoot(browser) {
        return path_1.default.join(__classPrivateFieldGet(this, _Cache_rootDir, "f"), browser);
      }
      installationDir(browser, platform, buildId) {
        return path_1.default.join(this.browserRoot(browser), `${platform}-${buildId}`);
      }
      clear() {
        fs_1.default.rmSync(__classPrivateFieldGet(this, _Cache_rootDir, "f"), {
          force: true,
          recursive: true,
          maxRetries: 10,
          retryDelay: 500
        });
      }
      getInstalledBrowsers() {
        if (!fs_1.default.existsSync(__classPrivateFieldGet(this, _Cache_rootDir, "f"))) {
          return [];
        }
        const types = fs_1.default.readdirSync(__classPrivateFieldGet(this, _Cache_rootDir, "f"));
        const browsers = types.filter((t) => {
          return Object.values(browser_data_js_1.Browser).includes(t);
        });
        return browsers.flatMap((browser) => {
          const files = fs_1.default.readdirSync(this.browserRoot(browser));
          return files.map((file) => {
            const result = parseFolderPath(path_1.default.join(this.browserRoot(browser), file));
            if (!result) {
              return null;
            }
            return {
              path: path_1.default.join(this.browserRoot(browser), file),
              browser,
              platform: result.platform,
              buildId: result.buildId
            };
          }).filter((item) => {
            return item !== null;
          });
        });
      }
    };
    exports2.Cache = Cache;
    _Cache_rootDir = /* @__PURE__ */ new WeakMap();
    function parseFolderPath(folderPath) {
      const name = path_1.default.basename(folderPath);
      const splits = name.split("-");
      if (splits.length !== 2) {
        return;
      }
      const [platform, buildId] = splits;
      if (!buildId || !platform) {
        return;
      }
      return { platform, buildId };
    }
  }
});

// node_modules/@puppeteer/browsers/node_modules/ms/index.js
var require_ms4 = __commonJS({
  "node_modules/@puppeteer/browsers/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@puppeteer/browsers/node_modules/debug/src/common.js
var require_common5 = __commonJS({
  "node_modules/@puppeteer/browsers/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms4();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@puppeteer/browsers/node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "node_modules/@puppeteer/browsers/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@puppeteer/browsers/node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/@puppeteer/browsers/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/@puppeteer/browsers/node_modules/debug/src/index.js
var require_src5 = __commonJS({
  "node_modules/@puppeteer/browsers/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser4();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/debug.js
var require_debug = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/debug.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debug = void 0;
    var debug_1 = __importDefault(require_src5());
    exports2.debug = debug_1.default;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/detectPlatform.js
var require_detectPlatform = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/detectPlatform.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectBrowserPlatform = void 0;
    var os_1 = __importDefault(require("os"));
    var browser_data_js_1 = require_browser_data();
    function detectBrowserPlatform() {
      const platform = os_1.default.platform();
      switch (platform) {
        case "darwin":
          return os_1.default.arch() === "arm64" ? browser_data_js_1.BrowserPlatform.MAC_ARM : browser_data_js_1.BrowserPlatform.MAC;
        case "linux":
          return browser_data_js_1.BrowserPlatform.LINUX;
        case "win32":
          return os_1.default.arch() === "x64" || // Windows 11 for ARM supports x64 emulation
          os_1.default.arch() === "arm64" && isWindows11(os_1.default.release()) ? browser_data_js_1.BrowserPlatform.WIN64 : browser_data_js_1.BrowserPlatform.WIN32;
        default:
          return void 0;
      }
    }
    exports2.detectBrowserPlatform = detectBrowserPlatform;
    function isWindows11(version) {
      const parts = version.split(".");
      if (parts.length > 2) {
        const major = parseInt(parts[0], 10);
        const minor = parseInt(parts[1], 10);
        const patch = parseInt(parts[2], 10);
        return major > 10 || major === 10 && minor > 0 || major === 10 && minor === 0 && patch >= 22e3;
      }
      return false;
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/launch.js
var require_launch = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/launch.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Process_instances;
    var _Process_executablePath;
    var _Process_args;
    var _Process_browserProcess;
    var _Process_exited;
    var _Process_hooksRan;
    var _Process_onExitHook;
    var _Process_browserProcessExiting;
    var _Process_runHooks;
    var _Process_configureStdio;
    var _Process_clearListeners;
    var _Process_onDriverProcessExit;
    var _Process_onDriverProcessSignal;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutError = exports2.isErrnoException = exports2.isErrorLike = exports2.Process = exports2.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX = exports2.CDP_WEBSOCKET_ENDPOINT_REGEX = exports2.launch = exports2.computeSystemExecutablePath = exports2.computeExecutablePath = void 0;
    var child_process_1 = __importDefault(require("child_process"));
    var fs_1 = require("fs");
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var readline_1 = __importDefault(require("readline"));
    var browser_data_js_1 = require_browser_data();
    var Cache_js_1 = require_Cache();
    var debug_js_1 = require_debug();
    var detectPlatform_js_1 = require_detectPlatform();
    var debugLaunch = (0, debug_js_1.debug)("puppeteer:browsers:launcher");
    function computeExecutablePath(options) {
      var _a;
      (_a = options.platform) !== null && _a !== void 0 ? _a : options.platform = (0, detectPlatform_js_1.detectBrowserPlatform)();
      if (!options.platform) {
        throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);
      }
      const installationDir = new Cache_js_1.Cache(options.cacheDir).installationDir(options.browser, options.platform, options.buildId);
      return path_1.default.join(installationDir, browser_data_js_1.executablePathByBrowser[options.browser](options.platform, options.buildId));
    }
    exports2.computeExecutablePath = computeExecutablePath;
    function computeSystemExecutablePath(options) {
      var _a;
      (_a = options.platform) !== null && _a !== void 0 ? _a : options.platform = (0, detectPlatform_js_1.detectBrowserPlatform)();
      if (!options.platform) {
        throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);
      }
      const path = (0, browser_data_js_1.resolveSystemExecutablePath)(options.browser, options.platform, options.channel);
      try {
        (0, fs_1.accessSync)(path);
      } catch (error) {
        throw new Error(`Could not find Google Chrome executable for channel '${options.channel}' at '${path}'.`);
      }
      return path;
    }
    exports2.computeSystemExecutablePath = computeSystemExecutablePath;
    function launch(opts) {
      return new Process(opts);
    }
    exports2.launch = launch;
    exports2.CDP_WEBSOCKET_ENDPOINT_REGEX = /^DevTools listening on (ws:\/\/.*)$/;
    exports2.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX = /^WebDriver BiDi listening on (ws:\/\/.*)$/;
    var Process = class {
      constructor(opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        _Process_instances.add(this);
        _Process_executablePath.set(this, void 0);
        _Process_args.set(this, void 0);
        _Process_browserProcess.set(this, void 0);
        _Process_exited.set(this, false);
        _Process_hooksRan.set(this, false);
        _Process_onExitHook.set(this, async () => {
        });
        _Process_browserProcessExiting.set(this, void 0);
        _Process_onDriverProcessExit.set(this, (_code) => {
          this.kill();
        });
        _Process_onDriverProcessSignal.set(this, (signal) => {
          switch (signal) {
            case "SIGINT":
              this.kill();
              process.exit(130);
            case "SIGTERM":
            case "SIGHUP":
              void this.close();
              break;
          }
        });
        __classPrivateFieldSet(this, _Process_executablePath, opts.executablePath, "f");
        __classPrivateFieldSet(this, _Process_args, (_a = opts.args) !== null && _a !== void 0 ? _a : [], "f");
        (_b = opts.pipe) !== null && _b !== void 0 ? _b : opts.pipe = false;
        (_c = opts.dumpio) !== null && _c !== void 0 ? _c : opts.dumpio = false;
        (_d = opts.handleSIGINT) !== null && _d !== void 0 ? _d : opts.handleSIGINT = true;
        (_e = opts.handleSIGTERM) !== null && _e !== void 0 ? _e : opts.handleSIGTERM = true;
        (_f = opts.handleSIGHUP) !== null && _f !== void 0 ? _f : opts.handleSIGHUP = true;
        (_g = opts.detached) !== null && _g !== void 0 ? _g : opts.detached = process.platform !== "win32";
        const stdio = __classPrivateFieldGet(this, _Process_instances, "m", _Process_configureStdio).call(this, {
          pipe: opts.pipe,
          dumpio: opts.dumpio
        });
        debugLaunch(`Launching ${__classPrivateFieldGet(this, _Process_executablePath, "f")} ${__classPrivateFieldGet(this, _Process_args, "f").join(" ")}`, {
          detached: opts.detached,
          env: opts.env,
          stdio
        });
        __classPrivateFieldSet(this, _Process_browserProcess, child_process_1.default.spawn(__classPrivateFieldGet(this, _Process_executablePath, "f"), __classPrivateFieldGet(this, _Process_args, "f"), {
          detached: opts.detached,
          env: opts.env,
          stdio
        }), "f");
        debugLaunch(`Launched ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid}`);
        if (opts.dumpio) {
          (_h = __classPrivateFieldGet(this, _Process_browserProcess, "f").stderr) === null || _h === void 0 ? void 0 : _h.pipe(process.stderr);
          (_j = __classPrivateFieldGet(this, _Process_browserProcess, "f").stdout) === null || _j === void 0 ? void 0 : _j.pipe(process.stdout);
        }
        process.on("exit", __classPrivateFieldGet(this, _Process_onDriverProcessExit, "f"));
        if (opts.handleSIGINT) {
          process.on("SIGINT", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
        }
        if (opts.handleSIGTERM) {
          process.on("SIGTERM", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
        }
        if (opts.handleSIGHUP) {
          process.on("SIGHUP", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
        }
        if (opts.onExit) {
          __classPrivateFieldSet(this, _Process_onExitHook, opts.onExit, "f");
        }
        __classPrivateFieldSet(this, _Process_browserProcessExiting, new Promise((resolve, reject) => {
          __classPrivateFieldGet(this, _Process_browserProcess, "f").once("exit", async () => {
            debugLaunch(`Browser process ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid} onExit`);
            __classPrivateFieldGet(this, _Process_instances, "m", _Process_clearListeners).call(this);
            __classPrivateFieldSet(this, _Process_exited, true, "f");
            try {
              await __classPrivateFieldGet(this, _Process_instances, "m", _Process_runHooks).call(this);
            } catch (err) {
              reject(err);
              return;
            }
            resolve();
          });
        }), "f");
      }
      get nodeProcess() {
        return __classPrivateFieldGet(this, _Process_browserProcess, "f");
      }
      async close() {
        await __classPrivateFieldGet(this, _Process_instances, "m", _Process_runHooks).call(this);
        if (!__classPrivateFieldGet(this, _Process_exited, "f")) {
          this.kill();
        }
        return __classPrivateFieldGet(this, _Process_browserProcessExiting, "f");
      }
      hasClosed() {
        return __classPrivateFieldGet(this, _Process_browserProcessExiting, "f");
      }
      kill() {
        debugLaunch(`Trying to kill ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid}`);
        if (__classPrivateFieldGet(this, _Process_browserProcess, "f") && __classPrivateFieldGet(this, _Process_browserProcess, "f").pid && pidExists(__classPrivateFieldGet(this, _Process_browserProcess, "f").pid)) {
          try {
            debugLaunch(`Browser process ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid} exists`);
            if (process.platform === "win32") {
              try {
                child_process_1.default.execSync(`taskkill /pid ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid} /T /F`);
              } catch (error) {
                debugLaunch(`Killing ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid} using taskkill failed`, error);
                __classPrivateFieldGet(this, _Process_browserProcess, "f").kill();
              }
            } else {
              const processGroupId = -__classPrivateFieldGet(this, _Process_browserProcess, "f").pid;
              try {
                process.kill(processGroupId, "SIGKILL");
              } catch (error) {
                debugLaunch(`Killing ${__classPrivateFieldGet(this, _Process_browserProcess, "f").pid} using process.kill failed`, error);
                __classPrivateFieldGet(this, _Process_browserProcess, "f").kill("SIGKILL");
              }
            }
          } catch (error) {
            throw new Error(`${PROCESS_ERROR_EXPLANATION}
Error cause: ${isErrorLike(error) ? error.stack : error}`);
          }
        }
        __classPrivateFieldGet(this, _Process_instances, "m", _Process_clearListeners).call(this);
      }
      waitForLineOutput(regex, timeout) {
        if (!__classPrivateFieldGet(this, _Process_browserProcess, "f").stderr) {
          throw new Error("`browserProcess` does not have stderr.");
        }
        const rl = readline_1.default.createInterface(__classPrivateFieldGet(this, _Process_browserProcess, "f").stderr);
        let stderr = "";
        return new Promise((resolve, reject) => {
          rl.on("line", onLine);
          rl.on("close", onClose);
          __classPrivateFieldGet(this, _Process_browserProcess, "f").on("exit", onClose);
          __classPrivateFieldGet(this, _Process_browserProcess, "f").on("error", onClose);
          const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
          const cleanup = () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            rl.off("line", onLine);
            rl.off("close", onClose);
            __classPrivateFieldGet(this, _Process_browserProcess, "f").off("exit", onClose);
            __classPrivateFieldGet(this, _Process_browserProcess, "f").off("error", onClose);
          };
          function onClose(error) {
            cleanup();
            reject(new Error([
              `Failed to launch the browser process!${error ? " " + error.message : ""}`,
              stderr,
              "",
              "TROUBLESHOOTING: https://pptr.dev/troubleshooting",
              ""
            ].join("\n")));
          }
          function onTimeout() {
            cleanup();
            reject(new TimeoutError(`Timed out after ${timeout} ms while waiting for the WS endpoint URL to appear in stdout!`));
          }
          function onLine(line) {
            stderr += line + "\n";
            const match = line.match(regex);
            if (!match) {
              return;
            }
            cleanup();
            resolve(match[1]);
          }
        });
      }
    };
    exports2.Process = Process;
    _Process_executablePath = /* @__PURE__ */ new WeakMap(), _Process_args = /* @__PURE__ */ new WeakMap(), _Process_browserProcess = /* @__PURE__ */ new WeakMap(), _Process_exited = /* @__PURE__ */ new WeakMap(), _Process_hooksRan = /* @__PURE__ */ new WeakMap(), _Process_onExitHook = /* @__PURE__ */ new WeakMap(), _Process_browserProcessExiting = /* @__PURE__ */ new WeakMap(), _Process_onDriverProcessExit = /* @__PURE__ */ new WeakMap(), _Process_onDriverProcessSignal = /* @__PURE__ */ new WeakMap(), _Process_instances = /* @__PURE__ */ new WeakSet(), _Process_runHooks = async function _Process_runHooks2() {
      if (__classPrivateFieldGet(this, _Process_hooksRan, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _Process_hooksRan, true, "f");
      await __classPrivateFieldGet(this, _Process_onExitHook, "f").call(this);
    }, _Process_configureStdio = function _Process_configureStdio2(opts) {
      if (opts.pipe) {
        if (opts.dumpio) {
          return ["ignore", "pipe", "pipe", "pipe", "pipe"];
        } else {
          return ["ignore", "ignore", "ignore", "pipe", "pipe"];
        }
      } else {
        if (opts.dumpio) {
          return ["pipe", "pipe", "pipe"];
        } else {
          return ["pipe", "ignore", "pipe"];
        }
      }
    }, _Process_clearListeners = function _Process_clearListeners2() {
      process.off("exit", __classPrivateFieldGet(this, _Process_onDriverProcessExit, "f"));
      process.off("SIGINT", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
      process.off("SIGTERM", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
      process.off("SIGHUP", __classPrivateFieldGet(this, _Process_onDriverProcessSignal, "f"));
    };
    var PROCESS_ERROR_EXPLANATION = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;
    function pidExists(pid) {
      try {
        return process.kill(pid, 0);
      } catch (error) {
        if (isErrnoException(error)) {
          if (error.code && error.code === "ESRCH") {
            return false;
          }
        }
        throw error;
      }
    }
    function isErrorLike(obj) {
      return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
    }
    exports2.isErrorLike = isErrorLike;
    function isErrnoException(obj) {
      return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
    }
    exports2.isErrnoException = isErrnoException;
    var TimeoutError = class extends Error {
      /**
       * @internal
       */
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    exports2.TimeoutError = TimeoutError;
  }
});

// node_modules/extract-zip/node_modules/ms/index.js
var require_ms5 = __commonJS({
  "node_modules/extract-zip/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/extract-zip/node_modules/debug/src/common.js
var require_common6 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms5();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/extract-zip/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common6()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/extract-zip/node_modules/debug/src/node.js
var require_node5 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common6()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/extract-zip/node_modules/debug/src/index.js
var require_src6 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser5();
    } else {
      module2.exports = require_node5();
    }
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
    module2.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports2) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/extract-zip/index.js"(exports2, module2) {
    var debug = require_src6()("extract-zip");
    var { createWriteStream, promises: fs } = require("fs");
    var getStream = require_get_stream();
    var path = require("path");
    var { promisify } = require("util");
    var stream = require("stream");
    var yauzl = require_yauzl();
    var openZip = promisify(yauzl.open);
    var pipeline = promisify(stream.pipeline);
    var Extractor = class {
      constructor(zipPath, opts) {
        this.zipPath = zipPath;
        this.opts = opts;
      }
      async extract() {
        debug("opening", this.zipPath, "with opts", this.opts);
        this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
        this.canceled = false;
        return new Promise((resolve, reject) => {
          this.zipfile.on("error", (err) => {
            this.canceled = true;
            reject(err);
          });
          this.zipfile.readEntry();
          this.zipfile.on("close", () => {
            if (!this.canceled) {
              debug("zip extraction complete");
              resolve();
            }
          });
          this.zipfile.on("entry", async (entry) => {
            if (this.canceled) {
              debug("skipping entry", entry.fileName, { cancelled: this.canceled });
              return;
            }
            debug("zipfile entry", entry.fileName);
            if (entry.fileName.startsWith("__MACOSX/")) {
              this.zipfile.readEntry();
              return;
            }
            const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
            try {
              await fs.mkdir(destDir, { recursive: true });
              const canonicalDestDir = await fs.realpath(destDir);
              const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
              if (relativeDestDir.split(path.sep).includes("..")) {
                throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
              }
              await this.extractEntry(entry);
              debug("finished processing", entry.fileName);
              this.zipfile.readEntry();
            } catch (err) {
              this.canceled = true;
              this.zipfile.close();
              reject(err);
            }
          });
        });
      }
      async extractEntry(entry) {
        if (this.canceled) {
          debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
          return;
        }
        if (this.opts.onEntry) {
          this.opts.onEntry(entry, this.zipfile);
        }
        const dest = path.join(this.opts.dir, entry.fileName);
        const mode = entry.externalFileAttributes >> 16 & 65535;
        const IFMT = 61440;
        const IFDIR = 16384;
        const IFLNK = 40960;
        const symlink = (mode & IFMT) === IFLNK;
        let isDir = (mode & IFMT) === IFDIR;
        if (!isDir && entry.fileName.endsWith("/")) {
          isDir = true;
        }
        const madeBy = entry.versionMadeBy >> 8;
        if (!isDir)
          isDir = madeBy === 0 && entry.externalFileAttributes === 16;
        debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
        const procMode = this.getExtractedMode(mode, isDir) & 511;
        const destDir = isDir ? dest : path.dirname(dest);
        const mkdirOptions = { recursive: true };
        if (isDir) {
          mkdirOptions.mode = procMode;
        }
        debug("mkdir", { dir: destDir, ...mkdirOptions });
        await fs.mkdir(destDir, mkdirOptions);
        if (isDir)
          return;
        debug("opening read stream", dest);
        const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
        if (symlink) {
          const link = await getStream(readStream);
          debug("creating symlink", link, dest);
          await fs.symlink(link, dest);
        } else {
          await pipeline(readStream, createWriteStream(dest, { mode: procMode }));
        }
      }
      getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        if (mode === 0) {
          if (isDir) {
            if (this.opts.defaultDirMode) {
              mode = parseInt(this.opts.defaultDirMode, 10);
            }
            if (!mode) {
              mode = 493;
            }
          } else {
            if (this.opts.defaultFileMode) {
              mode = parseInt(this.opts.defaultFileMode, 10);
            }
            if (!mode) {
              mode = 420;
            }
          }
        }
        return mode;
      }
    };
    module2.exports = async function(zipPath, opts) {
      debug("creating target directory", opts.dir);
      if (!path.isAbsolute(opts.dir)) {
        throw new Error("Target directory is expected to be absolute");
      }
      await fs.mkdir(opts.dir, { recursive: true });
      opts.dir = await fs.realpath(opts.dir);
      return new Extractor(zipPath, opts).extract();
    };
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var LCHOWN = fs.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path2, uid, gid) => {
      try {
        return fs[LCHOWNSYNC](path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path2, uid, gid) => {
      try {
        return fs.chownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path2, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs.chown(path2, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path2, uid, gid) => {
      try {
        return lchownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path2, uid, gid);
      }
    } : (path2, uid, gid) => lchownSync(path2, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path2, options, cb) => fs.readdir(path2, options, cb);
    var readdirSync = (path2, options) => fs.readdirSync(path2, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path2, options, cb) => fs.readdir(path2, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs.lstat(path.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs.lstatSync(path.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path.resolve(p, child.name), uid, gid);
      handleEISDirSync(path.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node6 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node6()
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream2();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "node_modules/tar-stream/headers.js"(exports2) {
    var alloc = Buffer.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
    var USTAR_VER = Buffer.from("00", "binary");
    var GNU_MAGIC = Buffer.from("ustar ", "binary");
    var GNU_VER = Buffer.from(" \0", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++)
        sum += block[i];
      for (var j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var tuple = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive)
          tuple.push(byte);
        else
          tuple.push(255 - byte);
      }
      var sum = 0;
      var l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer.from(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len)
          return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
      USTAR_VER.copy(buf, VERSION_OFFSET);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      var c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
        if (buf[345])
          name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "node_modules/tar-stream/extract.js"(exports2, module2) {
    var util = require("util");
    var bl = require_bl();
    var headers = require_headers();
    var Writable = require_readable().Writable;
    var PassThrough = require_readable().PassThrough;
    var noop = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this, { autoDestroy: false });
    };
    util.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s)
          return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s)
        s.end(data);
      else
        b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// node_modules/fs-constants/index.js
var require_fs_constants = __commonJS({
  "node_modules/fs-constants/index.js"(exports2, module2) {
    module2.exports = require("fs").constants || require("constants");
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "node_modules/tar-stream/pack.js"(exports2, module2) {
    var constants = require_fs_constants();
    var eos = require_end_of_stream();
    var inherits = require_inherits();
    var alloc = Buffer.alloc;
    var Readable = require_readable().Readable;
    var Writable = require_readable().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    inherits(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    };
    inherits(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable.call(this);
      this._destroyed = false;
    };
    inherits(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    inherits(Pack, Readable);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = /* @__PURE__ */ new Date();
      if (typeof buffer === "string")
        buffer = Buffer.from(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        var ok = this.push(buffer);
        overflow(self2, header.size);
        if (ok)
          process.nextTick(callback);
        else
          this._drain = callback;
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "node_modules/tar-stream/index.js"(exports2) {
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/mkdirp-classic/index.js
var require_mkdirp_classic = __commonJS({
  "node_modules/mkdirp-classic/index.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/tar-fs/index.js
var require_tar_fs = __commonJS({
  "node_modules/tar-fs/index.js"(exports2) {
    var chownr = require_chownr();
    var tar = require_tar_stream();
    var pump = require_pump();
    var mkdirp = require_mkdirp_classic();
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var win32 = os.platform() === "win32";
    var noop = function() {
    };
    var echo = function(name) {
      return name;
    };
    var normalize = !win32 ? echo : function(name) {
      return name.replace(/\\/g, "/").replace(/[:?<>|]/g, "_");
    };
    var statAll = function(fs2, stat, cwd, ignore, entries, sort) {
      var queue = entries || ["."];
      return function loop(callback) {
        if (!queue.length)
          return callback();
        var next = queue.shift();
        var nextAbs = path.join(cwd, next);
        stat.call(fs2, nextAbs, function(err, stat2) {
          if (err)
            return callback(err);
          if (!stat2.isDirectory())
            return callback(null, next, stat2);
          fs2.readdir(nextAbs, function(err2, files) {
            if (err2)
              return callback(err2);
            if (sort)
              files.sort();
            for (var i = 0; i < files.length; i++) {
              if (!ignore(path.join(cwd, next, files[i])))
                queue.push(path.join(next, files[i]));
            }
            callback(null, next, stat2);
          });
        });
      };
    };
    var strip = function(map, level) {
      return function(header) {
        header.name = header.name.split("/").slice(level).join("/");
        var linkname = header.linkname;
        if (linkname && (header.type === "link" || path.isAbsolute(linkname))) {
          header.linkname = linkname.split("/").slice(level).join("/");
        }
        return map(header);
      };
    };
    exports2.pack = function(cwd, opts) {
      if (!cwd)
        cwd = ".";
      if (!opts)
        opts = {};
      var xfs = opts.fs || fs;
      var ignore = opts.ignore || opts.filter || noop;
      var map = opts.map || noop;
      var mapStream = opts.mapStream || echo;
      var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);
      var strict = opts.strict !== false;
      var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
      var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
      var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
      var pack = opts.pack || tar.pack();
      var finish = opts.finish || noop;
      if (opts.strip)
        map = strip(map, opts.strip);
      if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
      }
      if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
      }
      var onsymlink = function(filename, header) {
        xfs.readlink(path.join(cwd, filename), function(err, linkname) {
          if (err)
            return pack.destroy(err);
          header.linkname = normalize(linkname);
          pack.entry(header, onnextentry);
        });
      };
      var onstat = function(err, filename, stat) {
        if (err)
          return pack.destroy(err);
        if (!filename) {
          if (opts.finalize !== false)
            pack.finalize();
          return finish(pack);
        }
        if (stat.isSocket())
          return onnextentry();
        var header = {
          name: normalize(filename),
          mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
          mtime: stat.mtime,
          size: stat.size,
          type: "file",
          uid: stat.uid,
          gid: stat.gid
        };
        if (stat.isDirectory()) {
          header.size = 0;
          header.type = "directory";
          header = map(header) || header;
          return pack.entry(header, onnextentry);
        }
        if (stat.isSymbolicLink()) {
          header.size = 0;
          header.type = "symlink";
          header = map(header) || header;
          return onsymlink(filename, header);
        }
        header = map(header) || header;
        if (!stat.isFile()) {
          if (strict)
            return pack.destroy(new Error("unsupported type for " + filename));
          return onnextentry();
        }
        var entry = pack.entry(header, onnextentry);
        if (!entry)
          return;
        var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header);
        rs.on("error", function(err2) {
          entry.destroy(err2);
        });
        pump(rs, entry);
      };
      var onnextentry = function(err) {
        if (err)
          return pack.destroy(err);
        statNext(onstat);
      };
      onnextentry();
      return pack;
    };
    var head = function(list) {
      return list.length ? list[list.length - 1] : null;
    };
    var processGetuid = function() {
      return process.getuid ? process.getuid() : -1;
    };
    var processUmask = function() {
      return process.umask ? process.umask() : 0;
    };
    exports2.extract = function(cwd, opts) {
      if (!cwd)
        cwd = ".";
      if (!opts)
        opts = {};
      var xfs = opts.fs || fs;
      var ignore = opts.ignore || opts.filter || noop;
      var map = opts.map || noop;
      var mapStream = opts.mapStream || echo;
      var own = opts.chown !== false && !win32 && processGetuid() === 0;
      var extract = opts.extract || tar.extract();
      var stack = [];
      var now = /* @__PURE__ */ new Date();
      var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
      var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
      var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
      var strict = opts.strict !== false;
      if (opts.strip)
        map = strip(map, opts.strip);
      if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
      }
      if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
      }
      var utimesParent = function(name, cb) {
        var top;
        while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0])
          stack.pop();
        if (!top)
          return cb();
        xfs.utimes(top[0], now, top[1], cb);
      };
      var utimes = function(name, header, cb) {
        if (opts.utimes === false)
          return cb();
        if (header.type === "directory")
          return xfs.utimes(name, now, header.mtime, cb);
        if (header.type === "symlink")
          return utimesParent(name, cb);
        xfs.utimes(name, now, header.mtime, function(err) {
          if (err)
            return cb(err);
          utimesParent(name, cb);
        });
      };
      var chperm = function(name, header, cb) {
        var link = header.type === "symlink";
        var chmod = link ? xfs.lchmod : xfs.chmod;
        var chown = link ? xfs.lchown : xfs.chown;
        if (!chmod)
          return cb();
        var mode = (header.mode | (header.type === "directory" ? dmode : fmode)) & umask;
        if (chown && own)
          chown.call(xfs, name, header.uid, header.gid, onchown);
        else
          onchown(null);
        function onchown(err) {
          if (err)
            return cb(err);
          if (!chmod)
            return cb();
          chmod.call(xfs, name, mode, cb);
        }
      };
      extract.on("entry", function(header, stream, next) {
        header = map(header) || header;
        header.name = normalize(header.name);
        var name = path.join(cwd, path.join("/", header.name));
        if (ignore(name, header)) {
          stream.resume();
          return next();
        }
        var stat = function(err) {
          if (err)
            return next(err);
          utimes(name, header, function(err2) {
            if (err2)
              return next(err2);
            if (win32)
              return next();
            chperm(name, header, next);
          });
        };
        var onsymlink = function() {
          if (win32)
            return next();
          xfs.unlink(name, function() {
            xfs.symlink(header.linkname, name, stat);
          });
        };
        var onlink = function() {
          if (win32)
            return next();
          xfs.unlink(name, function() {
            var srcpath = path.join(cwd, path.join("/", header.linkname));
            xfs.link(srcpath, name, function(err) {
              if (err && err.code === "EPERM" && opts.hardlinkAsFilesFallback) {
                stream = xfs.createReadStream(srcpath);
                return onfile();
              }
              stat(err);
            });
          });
        };
        var onfile = function() {
          var ws = xfs.createWriteStream(name);
          var rs = mapStream(stream, header);
          ws.on("error", function(err) {
            rs.destroy(err);
          });
          pump(rs, ws, function(err) {
            if (err)
              return next(err);
            ws.on("close", stat);
          });
        };
        if (header.type === "directory") {
          stack.push([name, header.mtime]);
          return mkdirfix(name, {
            fs: xfs,
            own,
            uid: header.uid,
            gid: header.gid
          }, stat);
        }
        var dir = path.dirname(name);
        validate(xfs, dir, path.join(cwd, "."), function(err, valid) {
          if (err)
            return next(err);
          if (!valid)
            return next(new Error(dir + " is not a valid path"));
          mkdirfix(dir, {
            fs: xfs,
            own,
            uid: header.uid,
            gid: header.gid
          }, function(err2) {
            if (err2)
              return next(err2);
            switch (header.type) {
              case "file":
                return onfile();
              case "link":
                return onlink();
              case "symlink":
                return onsymlink();
            }
            if (strict)
              return next(new Error("unsupported type for " + name + " (" + header.type + ")"));
            stream.resume();
            next();
          });
        });
      });
      if (opts.finish)
        extract.on("finish", opts.finish);
      return extract;
    };
    function validate(fs2, name, root, cb) {
      if (name === root)
        return cb(null, true);
      fs2.lstat(name, function(err, st) {
        if (err && err.code !== "ENOENT")
          return cb(err);
        if (err || st.isDirectory())
          return validate(fs2, path.join(name, ".."), root, cb);
        cb(null, false);
      });
    }
    function mkdirfix(name, opts, cb) {
      mkdirp(name, { fs: opts.fs }, function(err, made) {
        if (!err && made && opts.own) {
          chownr(made, opts.uid, opts.gid, cb);
        } else {
          cb(err);
        }
      });
    }
  }
});

// node_modules/through/index.js
var require_through = __commonJS({
  "node_modules/through/index.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (null === data)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      stream.queue = stream.push = function(data) {
        if (_ended)
          return stream;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      stream.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused)
          return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
  }
});

// node_modules/unbzip2-stream/lib/bzip2.js
var require_bzip2 = __commonJS({
  "node_modules/unbzip2-stream/lib/bzip2.js"(exports2, module2) {
    function Bzip2Error(message2) {
      this.name = "Bzip2Error";
      this.message = message2;
      this.stack = new Error().stack;
    }
    Bzip2Error.prototype = new Error();
    var message = {
      Error: function(message2) {
        throw new Bzip2Error(message2);
      }
    };
    var bzip2 = {};
    bzip2.Bzip2Error = Bzip2Error;
    bzip2.crcTable = [
      0,
      79764919,
      159529838,
      222504665,
      319059676,
      398814059,
      445009330,
      507990021,
      638119352,
      583659535,
      797628118,
      726387553,
      890018660,
      835552979,
      1015980042,
      944750013,
      1276238704,
      1221641927,
      1167319070,
      1095957929,
      1595256236,
      1540665371,
      1452775106,
      1381403509,
      1780037320,
      1859660671,
      1671105958,
      1733955601,
      2031960084,
      2111593891,
      1889500026,
      1952343757,
      2552477408,
      2632100695,
      2443283854,
      2506133561,
      2334638140,
      2414271883,
      2191915858,
      2254759653,
      3190512472,
      3135915759,
      3081330742,
      3009969537,
      2905550212,
      2850959411,
      2762807018,
      2691435357,
      3560074640,
      3505614887,
      3719321342,
      3648080713,
      3342211916,
      3287746299,
      3467911202,
      3396681109,
      4063920168,
      4143685023,
      4223187782,
      4286162673,
      3779000052,
      3858754371,
      3904687514,
      3967668269,
      881225847,
      809987520,
      1023691545,
      969234094,
      662832811,
      591600412,
      771767749,
      717299826,
      311336399,
      374308984,
      453813921,
      533576470,
      25881363,
      88864420,
      134795389,
      214552010,
      2023205639,
      2086057648,
      1897238633,
      1976864222,
      1804852699,
      1867694188,
      1645340341,
      1724971778,
      1587496639,
      1516133128,
      1461550545,
      1406951526,
      1302016099,
      1230646740,
      1142491917,
      1087903418,
      2896545431,
      2825181984,
      2770861561,
      2716262478,
      3215044683,
      3143675388,
      3055782693,
      3001194130,
      2326604591,
      2389456536,
      2200899649,
      2280525302,
      2578013683,
      2640855108,
      2418763421,
      2498394922,
      3769900519,
      3832873040,
      3912640137,
      3992402750,
      4088425275,
      4151408268,
      4197601365,
      4277358050,
      3334271071,
      3263032808,
      3476998961,
      3422541446,
      3585640067,
      3514407732,
      3694837229,
      3640369242,
      1762451694,
      1842216281,
      1619975040,
      1682949687,
      2047383090,
      2127137669,
      1938468188,
      2001449195,
      1325665622,
      1271206113,
      1183200824,
      1111960463,
      1543535498,
      1489069629,
      1434599652,
      1363369299,
      622672798,
      568075817,
      748617968,
      677256519,
      907627842,
      853037301,
      1067152940,
      995781531,
      51762726,
      131386257,
      177728840,
      240578815,
      269590778,
      349224269,
      429104020,
      491947555,
      4046411278,
      4126034873,
      4172115296,
      4234965207,
      3794477266,
      3874110821,
      3953728444,
      4016571915,
      3609705398,
      3555108353,
      3735388376,
      3664026991,
      3290680682,
      3236090077,
      3449943556,
      3378572211,
      3174993278,
      3120533705,
      3032266256,
      2961025959,
      2923101090,
      2868635157,
      2813903052,
      2742672763,
      2604032198,
      2683796849,
      2461293480,
      2524268063,
      2284983834,
      2364738477,
      2175806836,
      2238787779,
      1569362073,
      1498123566,
      1409854455,
      1355396672,
      1317987909,
      1246755826,
      1192025387,
      1137557660,
      2072149281,
      2135122070,
      1912620623,
      1992383480,
      1753615357,
      1816598090,
      1627664531,
      1707420964,
      295390185,
      358241886,
      404320391,
      483945776,
      43990325,
      106832002,
      186451547,
      266083308,
      932423249,
      861060070,
      1041341759,
      986742920,
      613929101,
      542559546,
      756411363,
      701822548,
      3316196985,
      3244833742,
      3425377559,
      3370778784,
      3601682597,
      3530312978,
      3744426955,
      3689838204,
      3819031489,
      3881883254,
      3928223919,
      4007849240,
      4037393693,
      4100235434,
      4180117107,
      4259748804,
      2310601993,
      2373574846,
      2151335527,
      2231098320,
      2596047829,
      2659030626,
      2470359227,
      2550115596,
      2947551409,
      2876312838,
      2788305887,
      2733848168,
      3165939309,
      3094707162,
      3040238851,
      2985771188
    ];
    bzip2.array = function(bytes) {
      var bit = 0, byte = 0;
      var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(n) {
        var result = 0;
        while (n > 0) {
          var left = 8 - bit;
          if (n >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n -= left;
          } else {
            result <<= n;
            result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
            bit += n;
            n = 0;
          }
        }
        return result;
      };
    };
    bzip2.simple = function(srcbuffer, stream) {
      var bits = bzip2.array(srcbuffer);
      var size = bzip2.header(bits);
      var ret = false;
      var bufsize = 1e5 * size;
      var buf = new Int32Array(bufsize);
      do {
        ret = bzip2.decompress(bits, stream, buf, bufsize);
      } while (!ret);
    };
    bzip2.header = function(bits) {
      this.byteCount = new Int32Array(256);
      this.symToByte = new Uint8Array(256);
      this.mtfSymbol = new Int32Array(256);
      this.selectors = new Uint8Array(32768);
      if (bits(8 * 3) != 4348520)
        message.Error("No magic number found");
      var i = bits(8) - 48;
      if (i < 1 || i > 9)
        message.Error("Not a BZIP archive");
      return i;
    };
    bzip2.decompress = function(bits, stream, buf, bufsize, streamCRC) {
      var MAX_HUFCODE_BITS = 20;
      var MAX_SYMBOLS = 258;
      var SYMBOL_RUNA = 0;
      var SYMBOL_RUNB = 1;
      var GROUP_SIZE = 50;
      var crc = 0 ^ -1;
      for (var h = "", i = 0; i < 6; i++)
        h += bits(8).toString(16);
      if (h == "177245385090") {
        var finalCRC = bits(32) | 0;
        if (finalCRC !== streamCRC)
          message.Error("Error in bzip2: crc32 do not match");
        bits(null);
        return null;
      }
      if (h != "314159265359")
        message.Error("eek not valid bzip data");
      var crcblock = bits(32) | 0;
      if (bits(1))
        message.Error("unsupported obsolete version");
      var origPtr = bits(24);
      if (origPtr > bufsize)
        message.Error("Initial position larger than buffer size");
      var t = bits(16);
      var symTotal = 0;
      for (i = 0; i < 16; i++) {
        if (t & 1 << 15 - i) {
          var k = bits(16);
          for (j = 0; j < 16; j++) {
            if (k & 1 << 15 - j) {
              this.symToByte[symTotal++] = 16 * i + j;
            }
          }
        }
      }
      var groupCount = bits(3);
      if (groupCount < 2 || groupCount > 6)
        message.Error("another error");
      var nSelectors = bits(15);
      if (nSelectors == 0)
        message.Error("meh");
      for (var i = 0; i < groupCount; i++)
        this.mtfSymbol[i] = i;
      for (var i = 0; i < nSelectors; i++) {
        for (var j = 0; bits(1); j++)
          if (j >= groupCount)
            message.Error("whoops another error");
        var uc = this.mtfSymbol[j];
        for (var k = j - 1; k >= 0; k--) {
          this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc;
        this.selectors[i] = uc;
      }
      var symCount = symTotal + 2;
      var groups = [];
      var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
      var hufGroup;
      for (var j = 0; j < groupCount; j++) {
        t = bits(5);
        for (var i = 0; i < symCount; i++) {
          while (true) {
            if (t < 1 || t > MAX_HUFCODE_BITS)
              message.Error("I gave up a while ago on writing error messages");
            if (!bits(1))
              break;
            if (!bits(1))
              t++;
            else
              t--;
          }
          length[i] = t;
        }
        var minLen, maxLen;
        minLen = maxLen = length[0];
        for (var i = 1; i < symCount; i++) {
          if (length[i] > maxLen)
            maxLen = length[i];
          else if (length[i] < minLen)
            minLen = length[i];
        }
        hufGroup = groups[j] = {};
        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base;
        var limit = hufGroup.limit;
        var pp = 0;
        for (var i = minLen; i <= maxLen; i++)
          for (var t = 0; t < symCount; t++)
            if (length[t] == i)
              hufGroup.permute[pp++] = t;
        for (i = minLen; i <= maxLen; i++)
          temp[i] = limit[i] = 0;
        for (i = 0; i < symCount; i++)
          temp[length[i]]++;
        pp = t = 0;
        for (i = minLen; i < maxLen; i++) {
          pp += temp[i];
          limit[i] = pp - 1;
          pp <<= 1;
          base[i + 1] = pp - (t += temp[i]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
      }
      for (var i = 0; i < 256; i++) {
        this.mtfSymbol[i] = i;
        this.byteCount[i] = 0;
      }
      var runPos, count, symCount, selector;
      runPos = count = symCount = selector = 0;
      while (true) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors)
            message.Error("meow i'm a kitty, that's an error");
          hufGroup = groups[this.selectors[selector++]];
          base = hufGroup.base;
          limit = hufGroup.limit;
        }
        i = hufGroup.minLen;
        j = bits(i);
        while (true) {
          if (i > hufGroup.maxLen)
            message.Error("rawr i'm a dinosaur");
          if (j <= limit[i])
            break;
          i++;
          j = j << 1 | bits(1);
        }
        j -= base[i];
        if (j < 0 || j >= MAX_SYMBOLS)
          message.Error("moo i'm a cow");
        var nextSym = hufGroup.permute[j];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t = 0;
          }
          if (nextSym == SYMBOL_RUNA)
            t += runPos;
          else
            t += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (count + t > bufsize)
            message.Error("Boom.");
          uc = this.symToByte[this.mtfSymbol[0]];
          this.byteCount[uc] += t;
          while (t--)
            buf[count++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (count >= bufsize)
          message.Error("I can't think of anything. Error");
        i = nextSym - 1;
        uc = this.mtfSymbol[i];
        for (var k = i - 1; k >= 0; k--) {
          this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc;
        uc = this.symToByte[uc];
        this.byteCount[uc]++;
        buf[count++] = uc;
      }
      if (origPtr < 0 || origPtr >= count)
        message.Error("I'm a monkey and I'm throwing something at someone, namely you");
      var j = 0;
      for (var i = 0; i < 256; i++) {
        k = j + this.byteCount[i];
        this.byteCount[i] = j;
        j = k;
      }
      for (var i = 0; i < count; i++) {
        uc = buf[i] & 255;
        buf[this.byteCount[uc]] |= i << 8;
        this.byteCount[uc]++;
      }
      var pos = 0, current = 0, run = 0;
      if (count) {
        pos = buf[origPtr];
        current = pos & 255;
        pos >>= 8;
        run = -1;
      }
      count = count;
      var copies, previous, outbyte;
      while (count) {
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run++ == 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        while (copies--) {
          crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 255]) & 4294967295;
          stream(outbyte);
        }
        if (current != previous)
          run = 0;
      }
      crc = (crc ^ -1) >>> 0;
      if ((crc | 0) != (crcblock | 0))
        message.Error("Error in bzip2: crc32 do not match");
      streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 4294967295;
      return streamCRC;
    };
    module2.exports = bzip2;
  }
});

// node_modules/unbzip2-stream/lib/bit_iterator.js
var require_bit_iterator = __commonJS({
  "node_modules/unbzip2-stream/lib/bit_iterator.js"(exports2, module2) {
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    module2.exports = function bitIterator(nextBuffer) {
      var bit = 0, byte = 0;
      var bytes = nextBuffer();
      var f = function(n) {
        if (n === null && bit != 0) {
          bit = 0;
          byte++;
          return;
        }
        var result = 0;
        while (n > 0) {
          if (byte >= bytes.length) {
            byte = 0;
            bytes = nextBuffer();
          }
          var left = 8 - bit;
          if (bit === 0 && n > 0)
            f.bytesRead++;
          if (n >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n -= left;
          } else {
            result <<= n;
            result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
            bit += n;
            n = 0;
          }
        }
        return result;
      };
      f.bytesRead = 0;
      return f;
    };
  }
});

// node_modules/unbzip2-stream/index.js
var require_unbzip2_stream = __commonJS({
  "node_modules/unbzip2-stream/index.js"(exports2, module2) {
    var through = require_through();
    var bz2 = require_bzip2();
    var bitIterator = require_bit_iterator();
    module2.exports = unbzip2Stream;
    function unbzip2Stream() {
      var bufferQueue = [];
      var hasBytes = 0;
      var blockSize = 0;
      var broken = false;
      var done = false;
      var bitReader = null;
      var streamCRC = null;
      function decompressBlock(push) {
        if (!blockSize) {
          blockSize = bz2.header(bitReader);
          streamCRC = 0;
          return true;
        } else {
          var bufsize = 1e5 * blockSize;
          var buf = new Int32Array(bufsize);
          var chunk = [];
          var f = function(b) {
            chunk.push(b);
          };
          streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);
          if (streamCRC === null) {
            blockSize = 0;
            return false;
          } else {
            push(Buffer.from(chunk));
            return true;
          }
        }
      }
      var outlength = 0;
      function decompressAndQueue(stream) {
        if (broken)
          return;
        try {
          return decompressBlock(function(d) {
            stream.queue(d);
            if (d !== null) {
              outlength += d.length;
            } else {
            }
          });
        } catch (e) {
          stream.emit("error", e);
          broken = true;
          return false;
        }
      }
      return through(
        function write(data) {
          bufferQueue.push(data);
          hasBytes += data.length;
          if (bitReader === null) {
            bitReader = bitIterator(function() {
              return bufferQueue.shift();
            });
          }
          while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25e3 + 1e5 * blockSize || 4)) {
            decompressAndQueue(this);
          }
        },
        function end(x) {
          while (!broken && bitReader && hasBytes > bitReader.bytesRead) {
            decompressAndQueue(this);
          }
          if (!broken) {
            if (streamCRC !== null)
              this.emit("error", new Error("input stream ended prematurely"));
            this.queue(null);
          }
        }
      );
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/fileUtil.js
var require_fileUtil = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/fileUtil.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unpackArchive = void 0;
    var child_process_1 = require("child_process");
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var path = __importStar(require("path"));
    var util_1 = require("util");
    var extract_zip_1 = __importDefault(require_extract_zip());
    var tar_fs_1 = __importDefault(require_tar_fs());
    var unbzip2_stream_1 = __importDefault(require_unbzip2_stream());
    var exec = (0, util_1.promisify)(child_process_1.exec);
    async function unpackArchive(archivePath, folderPath) {
      if (archivePath.endsWith(".zip")) {
        await (0, extract_zip_1.default)(archivePath, { dir: folderPath });
      } else if (archivePath.endsWith(".tar.bz2")) {
        await extractTar(archivePath, folderPath);
      } else if (archivePath.endsWith(".dmg")) {
        await (0, promises_1.mkdir)(folderPath);
        await installDMG(archivePath, folderPath);
      } else {
        throw new Error(`Unsupported archive format: ${archivePath}`);
      }
    }
    exports2.unpackArchive = unpackArchive;
    function extractTar(tarPath, folderPath) {
      return new Promise((fulfill, reject) => {
        const tarStream = tar_fs_1.default.extract(folderPath);
        tarStream.on("error", reject);
        tarStream.on("finish", fulfill);
        const readStream = (0, fs_1.createReadStream)(tarPath);
        readStream.pipe((0, unbzip2_stream_1.default)()).pipe(tarStream);
      });
    }
    async function installDMG(dmgPath, folderPath) {
      const { stdout } = await exec(`hdiutil attach -nobrowse -noautoopen "${dmgPath}"`);
      const volumes = stdout.match(/\/Volumes\/(.*)/m);
      if (!volumes) {
        throw new Error(`Could not find volume path in ${stdout}`);
      }
      const mountPath = volumes[0];
      try {
        const fileNames = await (0, promises_1.readdir)(mountPath);
        const appName = fileNames.find((item) => {
          return typeof item === "string" && item.endsWith(".app");
        });
        if (!appName) {
          throw new Error(`Cannot find app in ${mountPath}`);
        }
        const mountedPath = path.join(mountPath, appName);
        await exec(`cp -R "${mountedPath}" "${folderPath}"`);
      } finally {
        await exec(`hdiutil detach "${mountPath}" -quiet`);
      }
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/install.js
var require_install = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/install.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canDownload = exports2.install = void 0;
    var assert_1 = __importDefault(require("assert"));
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var browser_data_js_1 = require_browser_data();
    var Cache_js_1 = require_Cache();
    var debug_js_1 = require_debug();
    var detectPlatform_js_1 = require_detectPlatform();
    var fileUtil_js_1 = require_fileUtil();
    var httpUtil_js_1 = require_httpUtil();
    var debugInstall = (0, debug_js_1.debug)("puppeteer:browsers:install");
    var times = /* @__PURE__ */ new Map();
    function debugTime(label) {
      times.set(label, process.hrtime());
    }
    function debugTimeEnd(label) {
      const end = process.hrtime();
      const start = times.get(label);
      if (!start) {
        return;
      }
      const duration = end[0] * 1e3 + end[1] / 1e6 - (start[0] * 1e3 + start[1] / 1e6);
      debugInstall(`Duration for ${label}: ${duration}ms`);
    }
    async function install(options) {
      var _a, _b;
      (_a = options.platform) !== null && _a !== void 0 ? _a : options.platform = (0, detectPlatform_js_1.detectBrowserPlatform)();
      (_b = options.unpack) !== null && _b !== void 0 ? _b : options.unpack = true;
      if (!options.platform) {
        throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);
      }
      const url = getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl);
      const fileName = url.toString().split("/").pop();
      (0, assert_1.default)(fileName, `A malformed download URL was found: ${url}.`);
      const structure = new Cache_js_1.Cache(options.cacheDir);
      const browserRoot = structure.browserRoot(options.browser);
      const archivePath = path_1.default.join(browserRoot, fileName);
      if (!(0, fs_1.existsSync)(browserRoot)) {
        await (0, promises_1.mkdir)(browserRoot, { recursive: true });
      }
      if (!options.unpack) {
        if ((0, fs_1.existsSync)(archivePath)) {
          return {
            path: archivePath,
            browser: options.browser,
            platform: options.platform,
            buildId: options.buildId
          };
        }
        debugInstall(`Downloading binary from ${url}`);
        debugTime("download");
        await (0, httpUtil_js_1.downloadFile)(url, archivePath, options.downloadProgressCallback);
        debugTimeEnd("download");
        return {
          path: archivePath,
          browser: options.browser,
          platform: options.platform,
          buildId: options.buildId
        };
      }
      const outputPath = structure.installationDir(options.browser, options.platform, options.buildId);
      if ((0, fs_1.existsSync)(outputPath)) {
        return {
          path: outputPath,
          browser: options.browser,
          platform: options.platform,
          buildId: options.buildId
        };
      }
      try {
        debugInstall(`Downloading binary from ${url}`);
        try {
          debugTime("download");
          await (0, httpUtil_js_1.downloadFile)(url, archivePath, options.downloadProgressCallback);
        } finally {
          debugTimeEnd("download");
        }
        debugInstall(`Installing ${archivePath} to ${outputPath}`);
        try {
          debugTime("extract");
          await (0, fileUtil_js_1.unpackArchive)(archivePath, outputPath);
        } finally {
          debugTimeEnd("extract");
        }
      } finally {
        if ((0, fs_1.existsSync)(archivePath)) {
          await (0, promises_1.unlink)(archivePath);
        }
      }
      return {
        path: outputPath,
        browser: options.browser,
        platform: options.platform,
        buildId: options.buildId
      };
    }
    exports2.install = install;
    async function canDownload(options) {
      var _a;
      (_a = options.platform) !== null && _a !== void 0 ? _a : options.platform = (0, detectPlatform_js_1.detectBrowserPlatform)();
      if (!options.platform) {
        throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);
      }
      return await (0, httpUtil_js_1.headHttpRequest)(getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl));
    }
    exports2.canDownload = canDownload;
    function getDownloadUrl(browser, platform, buildId, baseUrl) {
      return new URL(browser_data_js_1.downloadUrls[browser](platform, buildId, baseUrl));
    }
  }
});

// node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS({
  "node_modules/progress/lib/node-progress.js"(exports2, module2) {
    exports2 = module2.exports = ProgressBar;
    function ProgressBar(fmt, options) {
      this.stream = options.stream || process.stderr;
      if (typeof options == "number") {
        var total = options;
        options = {};
        options.total = total;
      } else {
        options = options || {};
        if ("string" != typeof fmt)
          throw new Error("format required");
        if ("number" != typeof options.total)
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options.curr || 0;
      this.total = options.total;
      this.width = options.width || this.total;
      this.clear = options.clear;
      this.chars = {
        complete: options.complete || "=",
        incomplete: options.incomplete || "-",
        head: options.head || (options.complete || "=")
      };
      this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if ("object" == typeof len)
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (0 == this.curr)
        this.start = /* @__PURE__ */ new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = /* @__PURE__ */ new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  }
});

// node_modules/progress/index.js
var require_progress = __commonJS({
  "node_modules/progress/index.js"(exports2, module2) {
    module2.exports = require_node_progress();
  }
});

// node_modules/y18n/build/index.cjs
var require_build = __commonJS({
  "node_modules/y18n/build/index.cjs"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var path = require("path");
    var shim;
    var Y18N = class {
      constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || "./locales";
        this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
        this.locale = opts.locale || "en";
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.writeQueue = [];
      }
      __(...args) {
        if (typeof arguments[0] !== "string") {
          return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale])
          this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
          this.cache[this.locale][str] = str;
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
      }
      __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        if (!this.cache[this.locale])
          this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
          const entry = this.cache[this.locale][singular];
          str = entry[quantity === 1 ? "one" : "other"];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
          this.cache[this.locale][singular] = {
            one: singular,
            other: plural
          };
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        const values = [str];
        if (~str.indexOf("%d"))
          values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
      }
      setLocale(locale) {
        this.locale = locale;
      }
      getLocale() {
        return this.locale;
      }
      updateLocale(obj) {
        if (!this.cache[this.locale])
          this._readLocaleFile();
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            this.cache[this.locale][key] = obj[key];
          }
        }
      }
      _taggedLiteral(parts, ...args) {
        let str = "";
        parts.forEach(function(part, i) {
          const arg = args[i + 1];
          str += part;
          if (typeof arg !== "undefined") {
            str += "%s";
          }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
      }
      _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
          this._processWriteQueue();
      }
      _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
          _this.writeQueue.shift();
          if (_this.writeQueue.length > 0)
            _this._processWriteQueue();
          cb(err);
        });
      }
      _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
          if (shim.fs.readFileSync) {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
          }
        } catch (err) {
          if (err instanceof SyntaxError) {
            err.message = "syntax error in " + languageFile;
          }
          if (err.code === "ENOENT")
            localeLookup = {};
          else
            throw err;
        }
        this.cache[this.locale] = localeLookup;
      }
      _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, "./", locale + ".json");
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
          const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
          if (this._fileExistsSync(languageFile))
            file = languageFile;
        }
        return file;
      }
      _fileExistsSync(file) {
        return shim.exists(file);
      }
    };
    function y18n$1(opts, _shim) {
      shim = _shim;
      const y18n2 = new Y18N(opts);
      return {
        __: y18n2.__.bind(y18n2),
        __n: y18n2.__n.bind(y18n2),
        setLocale: y18n2.setLocale.bind(y18n2),
        getLocale: y18n2.getLocale.bind(y18n2),
        updateLocale: y18n2.updateLocale.bind(y18n2),
        locale: y18n2.locale
      };
    }
    var nodePlatformShim = {
      fs: {
        readFileSync: fs.readFileSync,
        writeFile: fs.writeFile
      },
      format: util.format,
      resolve: path.resolve,
      exists: (file) => {
        try {
          return fs.statSync(file).isFile();
        } catch (err) {
          return false;
        }
      }
    };
    var y18n = (opts) => {
      return y18n$1(opts, nodePlatformShim);
    };
    module2.exports = y18n;
  }
});

// node_modules/yargs-parser/build/index.cjs
var require_build2 = __commonJS({
  "node_modules/yargs-parser/build/index.cjs"(exports2, module2) {
    "use strict";
    var util = require("util");
    var path = require("path");
    var fs = require("fs");
    function camelCase(str) {
      const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
      if (!isCamelCase) {
        str = str.toLowerCase();
      }
      if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
        return str;
      } else {
        let camelcase = "";
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
          let chr = str.charAt(i);
          if (nextChrUpper) {
            nextChrUpper = false;
            chr = chr.toUpperCase();
          }
          if (i !== 0 && (chr === "-" || chr === "_")) {
            nextChrUpper = true;
          } else if (chr !== "-" && chr !== "_") {
            camelcase += chr;
          }
        }
        return camelcase;
      }
    }
    function decamelize(str, joinString) {
      const lowercase = str.toLowerCase();
      joinString = joinString || "-";
      let notCamelcase = "";
      for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
          notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
          notCamelcase += chrString;
        }
      }
      return notCamelcase;
    }
    function looksLikeNumber(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (/^0[^.]/.test(x))
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function tokenizeArgString(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args[i])
          args[i] = "";
        args[i] += c;
      }
      return args;
    }
    var DefaultValuesForTypeKey;
    (function(DefaultValuesForTypeKey2) {
      DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey2["STRING"] = "string";
      DefaultValuesForTypeKey2["NUMBER"] = "number";
      DefaultValuesForTypeKey2["ARRAY"] = "array";
    })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
    var mixin;
    var YargsParser = class {
      constructor(_mixin) {
        mixin = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === "string";
        const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value]) => {
            if (typeof value === "number") {
              flags.nargs[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value]) => {
            if (typeof value === "function") {
              flags.coercions[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value]) => {
              if (typeof value === "boolean" || typeof value === "function") {
                flags.configs[key] = value;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value;
          if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/^---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args, m[2]);
              } else {
                setArg(m[1], m[2], true);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args, value);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args, value);
                } else {
                  setArg(key, value);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv[key];
          });
        }
        if (configuration["strip-aliased"]) {
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args2, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args2.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args2.length; ii++) {
              if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args2[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args2, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args2[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign, true));
            }
            for (let ii = i + 1; ii < args2.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args2[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next, inputIsString));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value = processValue(key, val, shouldStripQuotes);
          const splitKey = key.split(".");
          setKey(argv, splitKey, value);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv, keyProperties, value);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv, keyProperties, value);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value2) {
                  val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val, shouldStripQuotes) {
          if (shouldStripQuotes) {
            val = stripQuotes(val);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
            value = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value = val.map((val2) => {
                return mixin.normalize(val2);
              });
            else
              value = mixin.normalize(val);
          }
          return value;
        }
        function maybeCoerceNumber(key, value) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
            const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
            if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
              value = Number(value);
            }
          }
          return value;
        }
        function setConfig(argv2) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv2[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv2[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
              setConfigObject(value, fullKey);
            } else {
              if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv2, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env2 = mixin.env();
          Object.keys(env2).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
                setArg(keys.join("."), env2[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv2) {
          let coerce;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv2).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value = maybeCoerceNumber(key, coerce(argv2[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv2[ali] = value;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv2) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv2[key] === "undefined")
              argv2[key] = void 0;
          });
          return argv2;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value;
            } else {
              o[key] = o[key].concat([value]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value : [value];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value];
          } else {
            o[key] = value;
          }
        }
        function extendAliases(...args2) {
          args2.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type) {
          const def = {
            [DefaultValuesForTypeKey.BOOLEAN]: true,
            [DefaultValuesForTypeKey.STRING]: "",
            [DefaultValuesForTypeKey.NUMBER]: void 0,
            [DefaultValuesForTypeKey.ARRAY]: []
          };
          return def[type];
        }
        function guessType(key) {
          let type = DefaultValuesForTypeKey.BOOLEAN;
          if (checkAllAliases(key, flags.strings))
            type = DefaultValuesForTypeKey.STRING;
          else if (checkAllAliases(key, flags.numbers))
            type = DefaultValuesForTypeKey.NUMBER;
          else if (checkAllAliases(key, flags.bools))
            type = DefaultValuesForTypeKey.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays))
            type = DefaultValuesForTypeKey.ARRAY;
          return type;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    function combineAliases(aliases) {
      const aliasArrays = [];
      const combined = /* @__PURE__ */ Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self2) {
          return self2.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== void 0 && typeof lastAlias === "string") {
          combined[lastAlias] = aliasArray;
        }
      });
      return combined;
    }
    function increment(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    function stripQuotes(val) {
      return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
    }
    var _a;
    var _b;
    var _c;
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    var nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
    if (nodeVersion) {
      const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    var env = process ? process.env : {};
    var parser = new YargsParser({
      cwd: process.cwd,
      env: () => {
        return env;
      },
      format: util.format,
      normalize: path.normalize,
      resolve: path.resolve,
      require: (path2) => {
        if (typeof require !== "undefined") {
          return require(path2);
        } else if (path2.match(/\.json$/)) {
          return JSON.parse(fs.readFileSync(path2, "utf8"));
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    var yargsParser = function Parser(args, opts) {
      const result = parser.parse(args.slice(), opts);
      return result.argv;
    };
    yargsParser.detailed = function(args, opts) {
      return parser.parse(args.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    module2.exports = yargsParser;
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/wrap-ansi/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/wrap-ansi/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "node_modules/wrap-ansi/index.js"(exports2, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var ANSI_ESCAPE_BELL = "\x07";
    var ANSI_CSI = "[";
    var ANSI_OSC = "]";
    var ANSI_SGR_TERMINATOR = "m";
    var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
    var wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let isInsideLinkEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
          isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
        }
        if (isInsideEscape) {
          if (isInsideLinkEscape) {
            if (character === ANSI_ESCAPE_BELL) {
              isInsideEscape = false;
              isInsideLinkEscape = false;
            }
          } else if (character === ANSI_SGR_TERMINATOR) {
            isInsideEscape = false;
          }
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (string) => {
      const words = string.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return string;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let returnValue = "";
      let escapeCode;
      let escapeUrl;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimStart();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      const pre = [...rows.join("\n")];
      for (const [index, character] of pre.entries()) {
        returnValue += character;
        if (ESCAPES.has(character)) {
          const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
          if (groups.code !== void 0) {
            const code2 = Number.parseFloat(groups.code);
            escapeCode = code2 === END_CODE ? void 0 : code2;
          } else if (groups.uri !== void 0) {
            escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
          }
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (pre[index + 1] === "\n") {
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink("");
          }
          if (escapeCode && code) {
            returnValue += wrapAnsi(code);
          }
        } else if (character === "\n") {
          if (escapeCode && code) {
            returnValue += wrapAnsi(escapeCode);
          }
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink(escapeUrl);
          }
        }
      }
      return returnValue;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
    };
  }
});

// node_modules/cliui/build/index.cjs
var require_build3 = __commonJS({
  "node_modules/cliui/build/index.cjs"(exports2, module2) {
    "use strict";
    var align = {
      right: alignRight,
      center: alignCenter
    };
    var top = 0;
    var right = 1;
    var bottom = 2;
    var left = 3;
    var UI = class {
      constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
      }
      span(...args) {
        const cols = this.div(...args);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args) {
        if (args.length === 0) {
          this.div("");
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
          return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg) => {
          if (typeof arg === "string") {
            return this.colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
      }
      applyLayoutDSL(str) {
        const rows = str.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this.measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      colFromString(text) {
        return {
          text,
          padding: this.measurePadding(text)
        };
      }
      measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
          let str = "";
          rrow.forEach((col, c) => {
            const { width } = row[c];
            const wrapWidth = this.negatePadding(row[c]);
            let ts = col;
            if (wrapWidth > mixin.stringWidth(col)) {
              ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              const fn = align[row[c].align];
              ts = fn(ts, wrapWidth);
              if (mixin.stringWidth(ts) < wrapWidth) {
                ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
              }
            }
            const padding = row[c].padding || [0, 0, 0, 0];
            if (padding[left]) {
              str += " ".repeat(padding[left]);
            }
            str += addBorder(row[c], ts, "| ");
            str += ts;
            str += addBorder(row[c], ts, " |");
            if (padding[right]) {
              str += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str = this.renderInline(str, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      // if the full 'source' can render in
      // the target line, do so.
      renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str);
          });
        });
        return rrows;
      }
      negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || mixin.stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    function addBorder(col, ts, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
          return "";
        }
        if (ts.trim().length !== 0) {
          return style;
        }
        return "  ";
      }
      return "";
    }
    function _minWidth(col) {
      const padding = col.padding || [];
      const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
      if (col.border) {
        return minWidth + 4;
      }
      return minWidth;
    }
    function getWindowWidth() {
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
      }
      return 80;
    }
    function alignRight(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth < width) {
        return " ".repeat(width - strWidth) + str;
      }
      return str;
    }
    function alignCenter(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth >= width) {
        return str;
      }
      return " ".repeat(width - strWidth >> 1) + str;
    }
    var mixin;
    function cliui(opts, _mixin) {
      mixin = _mixin;
      return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
      });
    }
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var wrap = require_wrap_ansi();
    function ui(opts) {
      return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
      });
    }
    module2.exports = ui;
  }
});

// node_modules/escalade/sync/index.js
var require_sync = __commonJS({
  "node_modules/escalade/sync/index.js"(exports2, module2) {
    var { dirname, resolve } = require("path");
    var { readdirSync, statSync } = require("fs");
    module2.exports = function(start, callback) {
      let dir = resolve(".", start);
      let tmp, stats = statSync(dir);
      if (!stats.isDirectory()) {
        dir = dirname(dir);
      }
      while (true) {
        tmp = callback(dir, readdirSync(dir));
        if (tmp)
          return resolve(dir, tmp);
        dir = dirname(tmp = dir);
        if (tmp === dir)
          break;
      }
    };
  }
});

// node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS({
  "node_modules/get-caller-file/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function getCallerFile(position) {
      if (position === void 0) {
        position = 2;
      }
      if (position >= Error.stackTraceLimit) {
        throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
      }
      var oldPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = oldPrepareStackTrace;
      if (stack !== null && typeof stack === "object") {
        return stack[position] ? stack[position].getFileName() : void 0;
      }
    };
  }
});

// node_modules/require-directory/index.js
var require_require_directory = __commonJS({
  "node_modules/require-directory/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var join = require("path").join;
    var resolve = require("path").resolve;
    var dirname = require("path").dirname;
    var defaultOptions = {
      extensions: ["js", "json", "coffee"],
      recurse: true,
      rename: function(name) {
        return name;
      },
      visit: function(obj) {
        return obj;
      }
    };
    function checkFileInclusion(path, filename, options) {
      return (
        // verify file has valid extension
        new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
        !(options.include && options.include instanceof RegExp && !options.include.test(path)) && // if options.include is a function, evaluate it and make sure the path passes
        !(options.include && typeof options.include === "function" && !options.include(path, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
        !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
        !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename))
      );
    }
    function requireDirectory(m, path, options) {
      var retval = {};
      if (path && !options && typeof path !== "string") {
        options = path;
        path = null;
      }
      options = options || {};
      for (var prop in defaultOptions) {
        if (typeof options[prop] === "undefined") {
          options[prop] = defaultOptions[prop];
        }
      }
      path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);
      fs.readdirSync(path).forEach(function(filename) {
        var joined = join(path, filename), files, key, obj;
        if (fs.statSync(joined).isDirectory() && options.recurse) {
          files = requireDirectory(m, joined, options);
          if (Object.keys(files).length) {
            retval[options.rename(filename, joined, filename)] = files;
          }
        } else {
          if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
            key = filename.substring(0, filename.lastIndexOf("."));
            obj = m.require(joined);
            retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
          }
        }
      });
      return retval;
    }
    module2.exports = requireDirectory;
    module2.exports.defaults = defaultOptions;
  }
});

// node_modules/yargs/build/index.cjs
var require_build4 = __commonJS({
  "node_modules/yargs/build/index.cjs"(exports2, module2) {
    "use strict";
    var t = require("assert");
    var e = class extends Error {
      constructor(t2) {
        super(t2 || "yargs error"), this.name = "YError", Error.captureStackTrace && Error.captureStackTrace(this, e);
      }
    };
    var s;
    var i = [];
    function n(t2, o2, a2, h2) {
      s = h2;
      let l2 = {};
      if (Object.prototype.hasOwnProperty.call(t2, "extends")) {
        if ("string" != typeof t2.extends)
          return l2;
        const r2 = /\.json|\..*rc$/.test(t2.extends);
        let h3 = null;
        if (r2)
          h3 = function(t3, e2) {
            return s.path.resolve(t3, e2);
          }(o2, t2.extends);
        else
          try {
            h3 = require.resolve(t2.extends);
          } catch (e2) {
            return t2;
          }
        !function(t3) {
          if (i.indexOf(t3) > -1)
            throw new e(`Circular extended configurations: '${t3}'.`);
        }(h3), i.push(h3), l2 = r2 ? JSON.parse(s.readFileSync(h3, "utf8")) : require(t2.extends), delete t2.extends, l2 = n(l2, s.path.dirname(h3), a2, s);
      }
      return i = [], a2 ? r(l2, t2) : Object.assign({}, l2, t2);
    }
    function r(t2, e2) {
      const s2 = {};
      function i2(t3) {
        return t3 && "object" == typeof t3 && !Array.isArray(t3);
      }
      Object.assign(s2, t2);
      for (const n2 of Object.keys(e2))
        i2(e2[n2]) && i2(s2[n2]) ? s2[n2] = r(t2[n2], e2[n2]) : s2[n2] = e2[n2];
      return s2;
    }
    function o(t2) {
      const e2 = t2.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), s2 = /\.*[\][<>]/g, i2 = e2.shift();
      if (!i2)
        throw new Error(`No command found in: ${t2}`);
      const n2 = { cmd: i2.replace(s2, ""), demanded: [], optional: [] };
      return e2.forEach((t3, i3) => {
        let r2 = false;
        t3 = t3.replace(/\s/g, ""), /\.+[\]>]/.test(t3) && i3 === e2.length - 1 && (r2 = true), /^\[/.test(t3) ? n2.optional.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 }) : n2.demanded.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 });
      }), n2;
    }
    var a = ["first", "second", "third", "fourth", "fifth", "sixth"];
    function h(t2, s2, i2) {
      try {
        let n2 = 0;
        const [r2, a2, h2] = "object" == typeof t2 ? [{ demanded: [], optional: [] }, t2, s2] : [o(`cmd ${t2}`), s2, i2], f2 = [].slice.call(a2);
        for (; f2.length && void 0 === f2[f2.length - 1]; )
          f2.pop();
        const d2 = h2 || f2.length;
        if (d2 < r2.demanded.length)
          throw new e(`Not enough arguments provided. Expected ${r2.demanded.length} but received ${f2.length}.`);
        const u2 = r2.demanded.length + r2.optional.length;
        if (d2 > u2)
          throw new e(`Too many arguments provided. Expected max ${u2} but received ${d2}.`);
        r2.demanded.forEach((t3) => {
          const e2 = l(f2.shift());
          0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
        }), r2.optional.forEach((t3) => {
          if (0 === f2.length)
            return;
          const e2 = l(f2.shift());
          0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
        });
      } catch (t3) {
        console.warn(t3.stack);
      }
    }
    function l(t2) {
      return Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
    }
    function c(t2, s2, i2) {
      throw new e(`Invalid ${a[i2] || "manyith"} argument. Expected ${s2.join(" or ")} but received ${t2}.`);
    }
    function f(t2) {
      return !!t2 && !!t2.then && "function" == typeof t2.then;
    }
    function d(t2, e2, s2, i2) {
      s2.assert.notStrictEqual(t2, e2, i2);
    }
    function u(t2, e2) {
      e2.assert.strictEqual(typeof t2, "string");
    }
    function p(t2) {
      return Object.keys(t2);
    }
    function g(t2 = {}, e2 = () => true) {
      const s2 = {};
      return p(t2).forEach((i2) => {
        e2(i2, t2[i2]) && (s2[i2] = t2[i2]);
      }), s2;
    }
    function m() {
      return process.versions.electron && !process.defaultApp ? 0 : 1;
    }
    function y() {
      return process.argv[m()];
    }
    var b = Object.freeze({ __proto__: null, hideBin: function(t2) {
      return t2.slice(m() + 1);
    }, getProcessArgvBin: y });
    function v(t2, e2, s2, i2) {
      if ("a" === s2 && !i2)
        throw new TypeError("Private accessor was defined without a getter");
      if ("function" == typeof e2 ? t2 !== e2 || !i2 : !e2.has(t2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === s2 ? i2 : "a" === s2 ? i2.call(t2) : i2 ? i2.value : e2.get(t2);
    }
    function O(t2, e2, s2, i2, n2) {
      if ("m" === i2)
        throw new TypeError("Private method is not writable");
      if ("a" === i2 && !n2)
        throw new TypeError("Private accessor was defined without a setter");
      if ("function" == typeof e2 ? t2 !== e2 || !n2 : !e2.has(t2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === i2 ? n2.call(t2, s2) : n2 ? n2.value = s2 : e2.set(t2, s2), s2;
    }
    var w = class {
      constructor(t2) {
        this.globalMiddleware = [], this.frozens = [], this.yargs = t2;
      }
      addMiddleware(t2, e2, s2 = true, i2 = false) {
        if (h("<array|function> [boolean] [boolean] [boolean]", [t2, e2, s2], arguments.length), Array.isArray(t2)) {
          for (let i3 = 0; i3 < t2.length; i3++) {
            if ("function" != typeof t2[i3])
              throw Error("middleware must be a function");
            const n2 = t2[i3];
            n2.applyBeforeValidation = e2, n2.global = s2;
          }
          Array.prototype.push.apply(this.globalMiddleware, t2);
        } else if ("function" == typeof t2) {
          const n2 = t2;
          n2.applyBeforeValidation = e2, n2.global = s2, n2.mutates = i2, this.globalMiddleware.push(t2);
        }
        return this.yargs;
      }
      addCoerceMiddleware(t2, e2) {
        const s2 = this.yargs.getAliases();
        return this.globalMiddleware = this.globalMiddleware.filter((t3) => {
          const i2 = [...s2[e2] || [], e2];
          return !t3.option || !i2.includes(t3.option);
        }), t2.option = e2, this.addMiddleware(t2, true, true, true);
      }
      getMiddleware() {
        return this.globalMiddleware;
      }
      freeze() {
        this.frozens.push([...this.globalMiddleware]);
      }
      unfreeze() {
        const t2 = this.frozens.pop();
        void 0 !== t2 && (this.globalMiddleware = t2);
      }
      reset() {
        this.globalMiddleware = this.globalMiddleware.filter((t2) => t2.global);
      }
    };
    function C(t2, e2, s2, i2) {
      return s2.reduce((t3, s3) => {
        if (s3.applyBeforeValidation !== i2)
          return t3;
        if (s3.mutates) {
          if (s3.applied)
            return t3;
          s3.applied = true;
        }
        if (f(t3))
          return t3.then((t4) => Promise.all([t4, s3(t4, e2)])).then(([t4, e3]) => Object.assign(t4, e3));
        {
          const i3 = s3(t3, e2);
          return f(i3) ? i3.then((e3) => Object.assign(t3, e3)) : Object.assign(t3, i3);
        }
      }, t2);
    }
    function j(t2, e2, s2 = (t3) => {
      throw t3;
    }) {
      try {
        const s3 = "function" == typeof t2 ? t2() : t2;
        return f(s3) ? s3.then((t3) => e2(t3)) : e2(s3);
      } catch (t3) {
        return s2(t3);
      }
    }
    var M = /(^\*)|(^\$0)/;
    var _ = class {
      constructor(t2, e2, s2, i2) {
        this.requireCache = /* @__PURE__ */ new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i2, this.usage = t2, this.globalMiddleware = s2, this.validation = e2;
      }
      addDirectory(t2, e2, s2, i2) {
        "boolean" != typeof (i2 = i2 || {}).recurse && (i2.recurse = false), Array.isArray(i2.extensions) || (i2.extensions = ["js"]);
        const n2 = "function" == typeof i2.visit ? i2.visit : (t3) => t3;
        i2.visit = (t3, e3, s3) => {
          const i3 = n2(t3, e3, s3);
          if (i3) {
            if (this.requireCache.has(e3))
              return i3;
            this.requireCache.add(e3), this.addHandler(i3);
          }
          return i3;
        }, this.shim.requireDirectory({ require: e2, filename: s2 }, t2, i2);
      }
      addHandler(t2, e2, s2, i2, n2, r2) {
        let a2 = [];
        const h2 = function(t3) {
          return t3 ? t3.map((t4) => (t4.applyBeforeValidation = false, t4)) : [];
        }(n2);
        if (i2 = i2 || (() => {
        }), Array.isArray(t2))
          if (function(t3) {
            return t3.every((t4) => "string" == typeof t4);
          }(t2))
            [t2, ...a2] = t2;
          else
            for (const e3 of t2)
              this.addHandler(e3);
        else {
          if (function(t3) {
            return "object" == typeof t3 && !Array.isArray(t3);
          }(t2)) {
            let e3 = Array.isArray(t2.command) || "string" == typeof t2.command ? t2.command : this.moduleName(t2);
            return t2.aliases && (e3 = [].concat(e3).concat(t2.aliases)), void this.addHandler(e3, this.extractDesc(t2), t2.builder, t2.handler, t2.middlewares, t2.deprecated);
          }
          if (k(s2))
            return void this.addHandler([t2].concat(a2), e2, s2.builder, s2.handler, s2.middlewares, s2.deprecated);
        }
        if ("string" == typeof t2) {
          const n3 = o(t2);
          a2 = a2.map((t3) => o(t3).cmd);
          let l2 = false;
          const c2 = [n3.cmd].concat(a2).filter((t3) => !M.test(t3) || (l2 = true, false));
          0 === c2.length && l2 && c2.push("$0"), l2 && (n3.cmd = c2[0], a2 = c2.slice(1), t2 = t2.replace(M, n3.cmd)), a2.forEach((t3) => {
            this.aliasMap[t3] = n3.cmd;
          }), false !== e2 && this.usage.command(t2, e2, l2, a2, r2), this.handlers[n3.cmd] = { original: t2, description: e2, handler: i2, builder: s2 || {}, middlewares: h2, deprecated: r2, demanded: n3.demanded, optional: n3.optional }, l2 && (this.defaultCommand = this.handlers[n3.cmd]);
        }
      }
      getCommandHandlers() {
        return this.handlers;
      }
      getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
      }
      hasDefaultCommand() {
        return !!this.defaultCommand;
      }
      runCommand(t2, e2, s2, i2, n2, r2) {
        const o2 = this.handlers[t2] || this.handlers[this.aliasMap[t2]] || this.defaultCommand, a2 = e2.getInternalMethods().getContext(), h2 = a2.commands.slice(), l2 = !t2;
        t2 && (a2.commands.push(t2), a2.fullCommands.push(o2.original));
        const c2 = this.applyBuilderUpdateUsageAndParse(l2, o2, e2, s2.aliases, h2, i2, n2, r2);
        return f(c2) ? c2.then((t3) => this.applyMiddlewareAndGetResult(l2, o2, t3.innerArgv, a2, n2, t3.aliases, e2)) : this.applyMiddlewareAndGetResult(l2, o2, c2.innerArgv, a2, n2, c2.aliases, e2);
      }
      applyBuilderUpdateUsageAndParse(t2, e2, s2, i2, n2, r2, o2, a2) {
        const h2 = e2.builder;
        let l2 = s2;
        if (x(h2)) {
          s2.getInternalMethods().getUsageInstance().freeze();
          const c2 = h2(s2.getInternalMethods().reset(i2), a2);
          if (f(c2))
            return c2.then((i3) => {
              var a3;
              return l2 = (a3 = i3) && "function" == typeof a3.getInternalMethods ? i3 : s2, this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
            });
        } else
          (function(t3) {
            return "object" == typeof t3;
          })(h2) && (s2.getInternalMethods().getUsageInstance().freeze(), l2 = s2.getInternalMethods().reset(i2), Object.keys(e2.builder).forEach((t3) => {
            l2.option(t3, h2[t3]);
          }));
        return this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
      }
      parseAndUpdateUsage(t2, e2, s2, i2, n2, r2) {
        t2 && s2.getInternalMethods().getUsageInstance().unfreeze(true), this.shouldUpdateUsage(s2) && s2.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i2, e2), e2.description);
        const o2 = s2.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, n2, r2);
        return f(o2) ? o2.then((t3) => ({ aliases: s2.parsed.aliases, innerArgv: t3 })) : { aliases: s2.parsed.aliases, innerArgv: o2 };
      }
      shouldUpdateUsage(t2) {
        return !t2.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === t2.getInternalMethods().getUsageInstance().getUsage().length;
      }
      usageFromParentCommandsCommandHandler(t2, e2) {
        const s2 = M.test(e2.original) ? e2.original.replace(M, "").trim() : e2.original, i2 = t2.filter((t3) => !M.test(t3));
        return i2.push(s2), `$0 ${i2.join(" ")}`;
      }
      handleValidationAndGetResult(t2, e2, s2, i2, n2, r2, o2, a2) {
        if (!r2.getInternalMethods().getHasOutput()) {
          const e3 = r2.getInternalMethods().runValidation(n2, a2, r2.parsed.error, t2);
          s2 = j(s2, (t3) => (e3(t3), t3));
        }
        if (e2.handler && !r2.getInternalMethods().getHasOutput()) {
          r2.getInternalMethods().setHasOutput();
          const i3 = !!r2.getOptions().configuration["populate--"];
          r2.getInternalMethods().postProcess(s2, i3, false, false), s2 = j(s2 = C(s2, r2, o2, false), (t3) => {
            const s3 = e2.handler(t3);
            return f(s3) ? s3.then(() => t3) : t3;
          }), t2 || r2.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s2) && !r2.getInternalMethods().hasParseCallback() && s2.catch((t3) => {
            try {
              r2.getInternalMethods().getUsageInstance().fail(null, t3);
            } catch (t4) {
            }
          });
        }
        return t2 || (i2.commands.pop(), i2.fullCommands.pop()), s2;
      }
      applyMiddlewareAndGetResult(t2, e2, s2, i2, n2, r2, o2) {
        let a2 = {};
        if (n2)
          return s2;
        o2.getInternalMethods().getHasOutput() || (a2 = this.populatePositionals(e2, s2, i2, o2));
        const h2 = this.globalMiddleware.getMiddleware().slice(0).concat(e2.middlewares), l2 = C(s2, o2, h2, true);
        return f(l2) ? l2.then((s3) => this.handleValidationAndGetResult(t2, e2, s3, i2, r2, o2, h2, a2)) : this.handleValidationAndGetResult(t2, e2, l2, i2, r2, o2, h2, a2);
      }
      populatePositionals(t2, e2, s2, i2) {
        e2._ = e2._.slice(s2.commands.length);
        const n2 = t2.demanded.slice(0), r2 = t2.optional.slice(0), o2 = {};
        for (this.validation.positionalCount(n2.length, e2._.length); n2.length; ) {
          const t3 = n2.shift();
          this.populatePositional(t3, e2, o2);
        }
        for (; r2.length; ) {
          const t3 = r2.shift();
          this.populatePositional(t3, e2, o2);
        }
        return e2._ = s2.commands.concat(e2._.map((t3) => "" + t3)), this.postProcessPositionals(e2, o2, this.cmdToParseOptions(t2.original), i2), o2;
      }
      populatePositional(t2, e2, s2) {
        const i2 = t2.cmd[0];
        t2.variadic ? s2[i2] = e2._.splice(0).map(String) : e2._.length && (s2[i2] = [String(e2._.shift())]);
      }
      cmdToParseOptions(t2) {
        const e2 = { array: [], default: {}, alias: {}, demand: {} }, s2 = o(t2);
        return s2.demanded.forEach((t3) => {
          const [s3, ...i2] = t3.cmd;
          t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2, e2.demand[s3] = true;
        }), s2.optional.forEach((t3) => {
          const [s3, ...i2] = t3.cmd;
          t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2;
        }), e2;
      }
      postProcessPositionals(t2, e2, s2, i2) {
        const n2 = Object.assign({}, i2.getOptions());
        n2.default = Object.assign(s2.default, n2.default);
        for (const t3 of Object.keys(s2.alias))
          n2.alias[t3] = (n2.alias[t3] || []).concat(s2.alias[t3]);
        n2.array = n2.array.concat(s2.array), n2.config = {};
        const r2 = [];
        if (Object.keys(e2).forEach((t3) => {
          e2[t3].map((e3) => {
            n2.configuration["unknown-options-as-args"] && (n2.key[t3] = true), r2.push(`--${t3}`), r2.push(e3);
          });
        }), !r2.length)
          return;
        const o2 = Object.assign({}, n2.configuration, { "populate--": false }), a2 = this.shim.Parser.detailed(r2, Object.assign({}, n2, { configuration: o2 }));
        if (a2.error)
          i2.getInternalMethods().getUsageInstance().fail(a2.error.message, a2.error);
        else {
          const s3 = Object.keys(e2);
          Object.keys(e2).forEach((t3) => {
            s3.push(...a2.aliases[t3]);
          }), Object.keys(a2.argv).forEach((n3) => {
            s3.includes(n3) && (e2[n3] || (e2[n3] = a2.argv[n3]), !this.isInConfigs(i2, n3) && !this.isDefaulted(i2, n3) && Object.prototype.hasOwnProperty.call(t2, n3) && Object.prototype.hasOwnProperty.call(a2.argv, n3) && (Array.isArray(t2[n3]) || Array.isArray(a2.argv[n3])) ? t2[n3] = [].concat(t2[n3], a2.argv[n3]) : t2[n3] = a2.argv[n3]);
          });
        }
      }
      isDefaulted(t2, e2) {
        const { default: s2 } = t2.getOptions();
        return Object.prototype.hasOwnProperty.call(s2, e2) || Object.prototype.hasOwnProperty.call(s2, this.shim.Parser.camelCase(e2));
      }
      isInConfigs(t2, e2) {
        const { configObjects: s2 } = t2.getOptions();
        return s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, e2)) || s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, this.shim.Parser.camelCase(e2)));
      }
      runDefaultBuilderOn(t2) {
        if (!this.defaultCommand)
          return;
        if (this.shouldUpdateUsage(t2)) {
          const e3 = M.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          t2.getInternalMethods().getUsageInstance().usage(e3, this.defaultCommand.description);
        }
        const e2 = this.defaultCommand.builder;
        if (x(e2))
          return e2(t2, true);
        k(e2) || Object.keys(e2).forEach((s2) => {
          t2.option(s2, e2[s2]);
        });
      }
      moduleName(t2) {
        const e2 = function(t3) {
          if ("undefined" == typeof require)
            return null;
          for (let e3, s2 = 0, i2 = Object.keys(require.cache); s2 < i2.length; s2++)
            if (e3 = require.cache[i2[s2]], e3.exports === t3)
              return e3;
          return null;
        }(t2);
        if (!e2)
          throw new Error(`No command name given for module: ${this.shim.inspect(t2)}`);
        return this.commandFromFilename(e2.filename);
      }
      commandFromFilename(t2) {
        return this.shim.path.basename(t2, this.shim.path.extname(t2));
      }
      extractDesc({ describe: t2, description: e2, desc: s2 }) {
        for (const i2 of [t2, e2, s2]) {
          if ("string" == typeof i2 || false === i2)
            return i2;
          d(i2, true, this.shim);
        }
        return false;
      }
      freeze() {
        this.frozens.push({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand });
      }
      unfreeze() {
        const t2 = this.frozens.pop();
        d(t2, void 0, this.shim), { handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = t2;
      }
      reset() {
        return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = /* @__PURE__ */ new Set(), this;
      }
    };
    function k(t2) {
      return "object" == typeof t2 && !!t2.builder && "function" == typeof t2.handler;
    }
    function x(t2) {
      return "function" == typeof t2;
    }
    function E(t2) {
      "undefined" != typeof process && [process.stdout, process.stderr].forEach((e2) => {
        const s2 = e2;
        s2._handle && s2.isTTY && "function" == typeof s2._handle.setBlocking && s2._handle.setBlocking(t2);
      });
    }
    function A(t2) {
      return "boolean" == typeof t2;
    }
    function P(t2, s2) {
      const i2 = s2.y18n.__, n2 = {}, r2 = [];
      n2.failFn = function(t3) {
        r2.push(t3);
      };
      let o2 = null, a2 = null, h2 = true;
      n2.showHelpOnFail = function(e2 = true, s3) {
        const [i3, r3] = "string" == typeof e2 ? [true, e2] : [e2, s3];
        return t2.getInternalMethods().isGlobalContext() && (a2 = r3), o2 = r3, h2 = i3, n2;
      };
      let l2 = false;
      n2.fail = function(s3, i3) {
        const c3 = t2.getInternalMethods().getLoggerInstance();
        if (!r2.length) {
          if (t2.getExitProcess() && E(true), !l2) {
            l2 = true, h2 && (t2.showHelp("error"), c3.error()), (s3 || i3) && c3.error(s3 || i3);
            const e2 = o2 || a2;
            e2 && ((s3 || i3) && c3.error(""), c3.error(e2));
          }
          if (i3 = i3 || new e(s3), t2.getExitProcess())
            return t2.exit(1);
          if (t2.getInternalMethods().hasParseCallback())
            return t2.exit(1, i3);
          throw i3;
        }
        for (let t3 = r2.length - 1; t3 >= 0; --t3) {
          const e2 = r2[t3];
          if (A(e2)) {
            if (i3)
              throw i3;
            if (s3)
              throw Error(s3);
          } else
            e2(s3, i3, n2);
        }
      };
      let c2 = [], f2 = false;
      n2.usage = (t3, e2) => null === t3 ? (f2 = true, c2 = [], n2) : (f2 = false, c2.push([t3, e2 || ""]), n2), n2.getUsage = () => c2, n2.getUsageDisabled = () => f2, n2.getPositionalGroupName = () => i2("Positionals:");
      let d2 = [];
      n2.example = (t3, e2) => {
        d2.push([t3, e2 || ""]);
      };
      let u2 = [];
      n2.command = function(t3, e2, s3, i3, n3 = false) {
        s3 && (u2 = u2.map((t4) => (t4[2] = false, t4))), u2.push([t3, e2 || "", s3, i3, n3]);
      }, n2.getCommands = () => u2;
      let p2 = {};
      n2.describe = function(t3, e2) {
        Array.isArray(t3) ? t3.forEach((t4) => {
          n2.describe(t4, e2);
        }) : "object" == typeof t3 ? Object.keys(t3).forEach((e3) => {
          n2.describe(e3, t3[e3]);
        }) : p2[t3] = e2;
      }, n2.getDescriptions = () => p2;
      let m2 = [];
      n2.epilog = (t3) => {
        m2.push(t3);
      };
      let y2, b2 = false;
      n2.wrap = (t3) => {
        b2 = true, y2 = t3;
      }, n2.getWrap = () => s2.getEnv("YARGS_DISABLE_WRAP") ? null : (b2 || (y2 = function() {
        const t3 = 80;
        return s2.process.stdColumns ? Math.min(t3, s2.process.stdColumns) : t3;
      }(), b2 = true), y2);
      const v2 = "__yargsString__:";
      function O2(t3, e2, i3) {
        let n3 = 0;
        return Array.isArray(t3) || (t3 = Object.values(t3).map((t4) => [t4])), t3.forEach((t4) => {
          n3 = Math.max(s2.stringWidth(i3 ? `${i3} ${I(t4[0])}` : I(t4[0])) + $(t4[0]), n3);
        }), e2 && (n3 = Math.min(n3, parseInt((0.5 * e2).toString(), 10))), n3;
      }
      let w2;
      function C2(e2) {
        return t2.getOptions().hiddenOptions.indexOf(e2) < 0 || t2.parsed.argv[t2.getOptions().showHiddenOpt];
      }
      function j2(t3, e2) {
        let s3 = `[${i2("default:")} `;
        if (void 0 === t3 && !e2)
          return null;
        if (e2)
          s3 += e2;
        else
          switch (typeof t3) {
            case "string":
              s3 += `"${t3}"`;
              break;
            case "object":
              s3 += JSON.stringify(t3);
              break;
            default:
              s3 += t3;
          }
        return `${s3}]`;
      }
      n2.deferY18nLookup = (t3) => v2 + t3, n2.help = function() {
        if (w2)
          return w2;
        !function() {
          const e3 = t2.getDemandedOptions(), s3 = t2.getOptions();
          (Object.keys(s3.alias) || []).forEach((i3) => {
            s3.alias[i3].forEach((r4) => {
              p2[r4] && n2.describe(i3, p2[r4]), r4 in e3 && t2.demandOption(i3, e3[r4]), s3.boolean.includes(r4) && t2.boolean(i3), s3.count.includes(r4) && t2.count(i3), s3.string.includes(r4) && t2.string(i3), s3.normalize.includes(r4) && t2.normalize(i3), s3.array.includes(r4) && t2.array(i3), s3.number.includes(r4) && t2.number(i3);
            });
          });
        }();
        const e2 = t2.customScriptName ? t2.$0 : s2.path.basename(t2.$0), r3 = t2.getDemandedOptions(), o3 = t2.getDemandedCommands(), a3 = t2.getDeprecatedOptions(), h3 = t2.getGroups(), l3 = t2.getOptions();
        let g2 = [];
        g2 = g2.concat(Object.keys(p2)), g2 = g2.concat(Object.keys(r3)), g2 = g2.concat(Object.keys(o3)), g2 = g2.concat(Object.keys(l3.default)), g2 = g2.filter(C2), g2 = Object.keys(g2.reduce((t3, e3) => ("_" !== e3 && (t3[e3] = true), t3), {}));
        const y3 = n2.getWrap(), b3 = s2.cliui({ width: y3, wrap: !!y3 });
        if (!f2) {
          if (c2.length)
            c2.forEach((t3) => {
              b3.div({ text: `${t3[0].replace(/\$0/g, e2)}` }), t3[1] && b3.div({ text: `${t3[1]}`, padding: [1, 0, 0, 0] });
            }), b3.div();
          else if (u2.length) {
            let t3 = null;
            t3 = o3._ ? `${e2} <${i2("command")}>
` : `${e2} [${i2("command")}]
`, b3.div(`${t3}`);
          }
        }
        if (u2.length > 1 || 1 === u2.length && !u2[0][2]) {
          b3.div(i2("Commands:"));
          const s3 = t2.getInternalMethods().getContext(), n3 = s3.commands.length ? `${s3.commands.join(" ")} ` : "";
          true === t2.getInternalMethods().getParserConfiguration()["sort-commands"] && (u2 = u2.sort((t3, e3) => t3[0].localeCompare(e3[0])));
          const r4 = e2 ? `${e2} ` : "";
          u2.forEach((t3) => {
            const s4 = `${r4}${n3}${t3[0].replace(/^\$0 ?/, "")}`;
            b3.span({ text: s4, padding: [0, 2, 0, 2], width: O2(u2, y3, `${e2}${n3}`) + 4 }, { text: t3[1] });
            const o4 = [];
            t3[2] && o4.push(`[${i2("default")}]`), t3[3] && t3[3].length && o4.push(`[${i2("aliases:")} ${t3[3].join(", ")}]`), t3[4] && ("string" == typeof t3[4] ? o4.push(`[${i2("deprecated: %s", t3[4])}]`) : o4.push(`[${i2("deprecated")}]`)), o4.length ? b3.div({ text: o4.join(" "), padding: [0, 0, 0, 2], align: "right" }) : b3.div();
          }), b3.div();
        }
        const M3 = (Object.keys(l3.alias) || []).concat(Object.keys(t2.parsed.newAliases) || []);
        g2 = g2.filter((e3) => !t2.parsed.newAliases[e3] && M3.every((t3) => -1 === (l3.alias[t3] || []).indexOf(e3)));
        const _3 = i2("Options:");
        h3[_3] || (h3[_3] = []), function(t3, e3, s3, i3) {
          let n3 = [], r4 = null;
          Object.keys(s3).forEach((t4) => {
            n3 = n3.concat(s3[t4]);
          }), t3.forEach((t4) => {
            r4 = [t4].concat(e3[t4]), r4.some((t5) => -1 !== n3.indexOf(t5)) || s3[i3].push(t4);
          });
        }(g2, l3.alias, h3, _3);
        const k2 = (t3) => /^--/.test(I(t3)), x2 = Object.keys(h3).filter((t3) => h3[t3].length > 0).map((t3) => ({ groupName: t3, normalizedKeys: h3[t3].filter(C2).map((t4) => {
          if (M3.includes(t4))
            return t4;
          for (let e3, s3 = 0; void 0 !== (e3 = M3[s3]); s3++)
            if ((l3.alias[e3] || []).includes(t4))
              return e3;
          return t4;
        }) })).filter(({ normalizedKeys: t3 }) => t3.length > 0).map(({ groupName: t3, normalizedKeys: e3 }) => {
          const s3 = e3.reduce((e4, s4) => (e4[s4] = [s4].concat(l3.alias[s4] || []).map((e5) => t3 === n2.getPositionalGroupName() ? e5 : (/^[0-9]$/.test(e5) ? l3.boolean.includes(s4) ? "-" : "--" : e5.length > 1 ? "--" : "-") + e5).sort((t4, e5) => k2(t4) === k2(e5) ? 0 : k2(t4) ? 1 : -1).join(", "), e4), {});
          return { groupName: t3, normalizedKeys: e3, switches: s3 };
        });
        if (x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).some(({ normalizedKeys: t3, switches: e3 }) => !t3.every((t4) => k2(e3[t4]))) && x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).forEach(({ normalizedKeys: t3, switches: e3 }) => {
          t3.forEach((t4) => {
            var s3, i3;
            k2(e3[t4]) && (e3[t4] = (s3 = e3[t4], i3 = "-x, ".length, S(s3) ? { text: s3.text, indentation: s3.indentation + i3 } : { text: s3, indentation: i3 }));
          });
        }), x2.forEach(({ groupName: e3, normalizedKeys: s3, switches: o4 }) => {
          b3.div(e3), s3.forEach((e4) => {
            const s4 = o4[e4];
            let h4 = p2[e4] || "", c3 = null;
            h4.includes(v2) && (h4 = i2(h4.substring(v2.length))), l3.boolean.includes(e4) && (c3 = `[${i2("boolean")}]`), l3.count.includes(e4) && (c3 = `[${i2("count")}]`), l3.string.includes(e4) && (c3 = `[${i2("string")}]`), l3.normalize.includes(e4) && (c3 = `[${i2("string")}]`), l3.array.includes(e4) && (c3 = `[${i2("array")}]`), l3.number.includes(e4) && (c3 = `[${i2("number")}]`);
            const f3 = [e4 in a3 ? (d3 = a3[e4], "string" == typeof d3 ? `[${i2("deprecated: %s", d3)}]` : `[${i2("deprecated")}]`) : null, c3, e4 in r3 ? `[${i2("required")}]` : null, l3.choices && l3.choices[e4] ? `[${i2("choices:")} ${n2.stringifiedValues(l3.choices[e4])}]` : null, j2(l3.default[e4], l3.defaultDescription[e4])].filter(Boolean).join(" ");
            var d3;
            b3.span({ text: I(s4), padding: [0, 2, 0, 2 + $(s4)], width: O2(o4, y3) + 4 }, h4);
            const u3 = true === t2.getInternalMethods().getUsageConfiguration()["hide-types"];
            f3 && !u3 ? b3.div({ text: f3, padding: [0, 0, 0, 2], align: "right" }) : b3.div();
          }), b3.div();
        }), d2.length && (b3.div(i2("Examples:")), d2.forEach((t3) => {
          t3[0] = t3[0].replace(/\$0/g, e2);
        }), d2.forEach((t3) => {
          "" === t3[1] ? b3.div({ text: t3[0], padding: [0, 2, 0, 2] }) : b3.div({ text: t3[0], padding: [0, 2, 0, 2], width: O2(d2, y3) + 4 }, { text: t3[1] });
        }), b3.div()), m2.length > 0) {
          const t3 = m2.map((t4) => t4.replace(/\$0/g, e2)).join("\n");
          b3.div(`${t3}
`);
        }
        return b3.toString().replace(/\s*$/, "");
      }, n2.cacheHelpMessage = function() {
        w2 = this.help();
      }, n2.clearCachedHelpMessage = function() {
        w2 = void 0;
      }, n2.hasCachedHelpMessage = function() {
        return !!w2;
      }, n2.showHelp = (e2) => {
        const s3 = t2.getInternalMethods().getLoggerInstance();
        e2 || (e2 = "error");
        ("function" == typeof e2 ? e2 : s3[e2])(n2.help());
      }, n2.functionDescription = (t3) => ["(", t3.name ? s2.Parser.decamelize(t3.name, "-") : i2("generated-value"), ")"].join(""), n2.stringifiedValues = function(t3, e2) {
        let s3 = "";
        const i3 = e2 || ", ", n3 = [].concat(t3);
        return t3 && n3.length ? (n3.forEach((t4) => {
          s3.length && (s3 += i3), s3 += JSON.stringify(t4);
        }), s3) : s3;
      };
      let M2 = null;
      n2.version = (t3) => {
        M2 = t3;
      }, n2.showVersion = (e2) => {
        const s3 = t2.getInternalMethods().getLoggerInstance();
        e2 || (e2 = "error");
        ("function" == typeof e2 ? e2 : s3[e2])(M2);
      }, n2.reset = function(t3) {
        return o2 = null, l2 = false, c2 = [], f2 = false, m2 = [], d2 = [], u2 = [], p2 = g(p2, (e2) => !t3[e2]), n2;
      };
      const _2 = [];
      return n2.freeze = function() {
        _2.push({ failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 });
      }, n2.unfreeze = function(t3 = false) {
        const e2 = _2.pop();
        e2 && (t3 ? (p2 = { ...e2.descriptions, ...p2 }, u2 = [...e2.commands, ...u2], c2 = [...e2.usages, ...c2], d2 = [...e2.examples, ...d2], m2 = [...e2.epilogs, ...m2]) : { failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 } = e2);
      }, n2;
    }
    function S(t2) {
      return "object" == typeof t2;
    }
    function $(t2) {
      return S(t2) ? t2.indentation : 0;
    }
    function I(t2) {
      return S(t2) ? t2.text : t2;
    }
    var D = class {
      constructor(t2, e2, s2, i2) {
        var n2, r2, o2;
        this.yargs = t2, this.usage = e2, this.command = s2, this.shim = i2, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = null !== (o2 = (null === (n2 = this.shim.getEnv("SHELL")) || void 0 === n2 ? void 0 : n2.includes("zsh")) || (null === (r2 = this.shim.getEnv("ZSH_NAME")) || void 0 === r2 ? void 0 : r2.includes("zsh"))) && void 0 !== o2 && o2;
      }
      defaultCompletion(t2, e2, s2, i2) {
        const n2 = this.command.getCommandHandlers();
        for (let e3 = 0, s3 = t2.length; e3 < s3; ++e3)
          if (n2[t2[e3]] && n2[t2[e3]].builder) {
            const s4 = n2[t2[e3]].builder;
            if (x(s4)) {
              this.indexAfterLastReset = e3 + 1;
              const t3 = this.yargs.getInternalMethods().reset();
              return s4(t3, true), t3.argv;
            }
          }
        const r2 = [];
        this.commandCompletions(r2, t2, s2), this.optionCompletions(r2, t2, e2, s2), this.choicesFromOptionsCompletions(r2, t2, e2, s2), this.choicesFromPositionalsCompletions(r2, t2, e2, s2), i2(null, r2);
      }
      commandCompletions(t2, e2, s2) {
        const i2 = this.yargs.getInternalMethods().getContext().commands;
        s2.match(/^-/) || i2[i2.length - 1] === s2 || this.previousArgHasChoices(e2) || this.usage.getCommands().forEach((s3) => {
          const i3 = o(s3[0]).cmd;
          if (-1 === e2.indexOf(i3))
            if (this.zshShell) {
              const e3 = s3[1] || "";
              t2.push(i3.replace(/:/g, "\\:") + ":" + e3);
            } else
              t2.push(i3);
        });
      }
      optionCompletions(t2, e2, s2, i2) {
        if ((i2.match(/^-/) || "" === i2 && 0 === t2.length) && !this.previousArgHasChoices(e2)) {
          const s3 = this.yargs.getOptions(), n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
          Object.keys(s3.key).forEach((r2) => {
            const o2 = !!s3.configuration["boolean-negation"] && s3.boolean.includes(r2);
            n2.includes(r2) || s3.hiddenOptions.includes(r2) || this.argsContainKey(e2, r2, o2) || (this.completeOptionKey(r2, t2, i2), o2 && s3.default[r2] && this.completeOptionKey(`no-${r2}`, t2, i2));
          });
        }
      }
      choicesFromOptionsCompletions(t2, e2, s2, i2) {
        if (this.previousArgHasChoices(e2)) {
          const s3 = this.getPreviousArgChoices(e2);
          s3 && s3.length > 0 && t2.push(...s3.map((t3) => t3.replace(/:/g, "\\:")));
        }
      }
      choicesFromPositionalsCompletions(t2, e2, s2, i2) {
        if ("" === i2 && t2.length > 0 && this.previousArgHasChoices(e2))
          return;
        const n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [], r2 = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1), o2 = n2[s2._.length - r2 - 1];
        if (!o2)
          return;
        const a2 = this.yargs.getOptions().choices[o2] || [];
        for (const e3 of a2)
          e3.startsWith(i2) && t2.push(e3.replace(/:/g, "\\:"));
      }
      getPreviousArgChoices(t2) {
        if (t2.length < 1)
          return;
        let e2 = t2[t2.length - 1], s2 = "";
        if (!e2.startsWith("-") && t2.length > 1 && (s2 = e2, e2 = t2[t2.length - 2]), !e2.startsWith("-"))
          return;
        const i2 = e2.replace(/^-+/, ""), n2 = this.yargs.getOptions(), r2 = [i2, ...this.yargs.getAliases()[i2] || []];
        let o2;
        for (const t3 of r2)
          if (Object.prototype.hasOwnProperty.call(n2.key, t3) && Array.isArray(n2.choices[t3])) {
            o2 = n2.choices[t3];
            break;
          }
        return o2 ? o2.filter((t3) => !s2 || t3.startsWith(s2)) : void 0;
      }
      previousArgHasChoices(t2) {
        const e2 = this.getPreviousArgChoices(t2);
        return void 0 !== e2 && e2.length > 0;
      }
      argsContainKey(t2, e2, s2) {
        const i2 = (e3) => -1 !== t2.indexOf((/^[^0-9]$/.test(e3) ? "-" : "--") + e3);
        if (i2(e2))
          return true;
        if (s2 && i2(`no-${e2}`))
          return true;
        if (this.aliases) {
          for (const t3 of this.aliases[e2])
            if (i2(t3))
              return true;
        }
        return false;
      }
      completeOptionKey(t2, e2, s2) {
        var i2, n2, r2;
        const o2 = this.usage.getDescriptions(), a2 = !/^--/.test(s2) && ((t3) => /^[^0-9]$/.test(t3))(t2) ? "-" : "--";
        if (this.zshShell) {
          const s3 = null === (i2 = null == this ? void 0 : this.aliases) || void 0 === i2 ? void 0 : i2[t2].find((t3) => {
            const e3 = o2[t3];
            return "string" == typeof e3 && e3.length > 0;
          }), h2 = s3 ? o2[s3] : void 0, l2 = null !== (r2 = null !== (n2 = o2[t2]) && void 0 !== n2 ? n2 : h2) && void 0 !== r2 ? r2 : "";
          e2.push(a2 + `${t2.replace(/:/g, "\\:")}:${l2.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`);
        } else
          e2.push(a2 + t2);
      }
      customCompletion(t2, e2, s2, i2) {
        if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
          const t3 = this.customCompletionFunction(s2, e2);
          return f(t3) ? t3.then((t4) => {
            this.shim.process.nextTick(() => {
              i2(null, t4);
            });
          }).catch((t4) => {
            this.shim.process.nextTick(() => {
              i2(t4, void 0);
            });
          }) : i2(null, t3);
        }
        return function(t3) {
          return t3.length > 3;
        }(this.customCompletionFunction) ? this.customCompletionFunction(s2, e2, (n2 = i2) => this.defaultCompletion(t2, e2, s2, n2), (t3) => {
          i2(null, t3);
        }) : this.customCompletionFunction(s2, e2, (t3) => {
          i2(null, t3);
        });
      }
      getCompletion(t2, e2) {
        const s2 = t2.length ? t2[t2.length - 1] : "", i2 = this.yargs.parse(t2, true), n2 = this.customCompletionFunction ? (i3) => this.customCompletion(t2, i3, s2, e2) : (i3) => this.defaultCompletion(t2, i3, s2, e2);
        return f(i2) ? i2.then(n2) : n2(i2);
      }
      generateCompletionScript(t2, e2) {
        let s2 = this.zshShell ? `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
` : '###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';
        const i2 = this.shim.path.basename(t2);
        return t2.match(/\.js$/) && (t2 = `./${t2}`), s2 = s2.replace(/{{app_name}}/g, i2), s2 = s2.replace(/{{completion_command}}/g, e2), s2.replace(/{{app_path}}/g, t2);
      }
      registerFunction(t2) {
        this.customCompletionFunction = t2;
      }
      setParsed(t2) {
        this.aliases = t2.aliases;
      }
    };
    function N(t2, e2) {
      if (0 === t2.length)
        return e2.length;
      if (0 === e2.length)
        return t2.length;
      const s2 = [];
      let i2, n2;
      for (i2 = 0; i2 <= e2.length; i2++)
        s2[i2] = [i2];
      for (n2 = 0; n2 <= t2.length; n2++)
        s2[0][n2] = n2;
      for (i2 = 1; i2 <= e2.length; i2++)
        for (n2 = 1; n2 <= t2.length; n2++)
          e2.charAt(i2 - 1) === t2.charAt(n2 - 1) ? s2[i2][n2] = s2[i2 - 1][n2 - 1] : i2 > 1 && n2 > 1 && e2.charAt(i2 - 2) === t2.charAt(n2 - 1) && e2.charAt(i2 - 1) === t2.charAt(n2 - 2) ? s2[i2][n2] = s2[i2 - 2][n2 - 2] + 1 : s2[i2][n2] = Math.min(s2[i2 - 1][n2 - 1] + 1, Math.min(s2[i2][n2 - 1] + 1, s2[i2 - 1][n2] + 1));
      return s2[e2.length][t2.length];
    }
    var H = ["$0", "--", "_"];
    var z;
    var W;
    var q;
    var U;
    var F;
    var L;
    var V;
    var G;
    var R;
    var T;
    var B;
    var K;
    var Y;
    var J;
    var Z;
    var X;
    var Q;
    var tt;
    var et;
    var st;
    var it;
    var nt;
    var rt;
    var ot;
    var at;
    var ht;
    var lt;
    var ct;
    var ft;
    var dt;
    var ut;
    var pt;
    var gt;
    var mt;
    var yt;
    var bt = Symbol("copyDoubleDash");
    var vt = Symbol("copyDoubleDash");
    var Ot = Symbol("deleteFromParserHintObject");
    var wt = Symbol("emitWarning");
    var Ct = Symbol("freeze");
    var jt = Symbol("getDollarZero");
    var Mt = Symbol("getParserConfiguration");
    var _t = Symbol("getUsageConfiguration");
    var kt = Symbol("guessLocale");
    var xt = Symbol("guessVersion");
    var Et = Symbol("parsePositionalNumbers");
    var At = Symbol("pkgUp");
    var Pt = Symbol("populateParserHintArray");
    var St = Symbol("populateParserHintSingleValueDictionary");
    var $t = Symbol("populateParserHintArrayDictionary");
    var It = Symbol("populateParserHintDictionary");
    var Dt = Symbol("sanitizeKey");
    var Nt = Symbol("setKey");
    var Ht = Symbol("unfreeze");
    var zt = Symbol("validateAsync");
    var Wt = Symbol("getCommandInstance");
    var qt = Symbol("getContext");
    var Ut = Symbol("getHasOutput");
    var Ft = Symbol("getLoggerInstance");
    var Lt = Symbol("getParseContext");
    var Vt = Symbol("getUsageInstance");
    var Gt = Symbol("getValidationInstance");
    var Rt = Symbol("hasParseCallback");
    var Tt = Symbol("isGlobalContext");
    var Bt = Symbol("postProcess");
    var Kt = Symbol("rebase");
    var Yt = Symbol("reset");
    var Jt = Symbol("runYargsParserAndExecuteCommands");
    var Zt = Symbol("runValidation");
    var Xt = Symbol("setHasOutput");
    var Qt = Symbol("kTrackManuallySetKeys");
    var te = class {
      constructor(t2 = [], e2, s2, i2) {
        this.customScriptName = false, this.parsed = false, z.set(this, void 0), W.set(this, void 0), q.set(this, { commands: [], fullCommands: [] }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), G.set(this, true), R.set(this, {}), T.set(this, true), B.set(this, []), K.set(this, void 0), Y.set(this, {}), J.set(this, false), Z.set(this, null), X.set(this, true), Q.set(this, void 0), tt.set(this, ""), et.set(this, void 0), st.set(this, void 0), it.set(this, {}), nt.set(this, null), rt.set(this, null), ot.set(this, {}), at.set(this, {}), ht.set(this, void 0), lt.set(this, false), ct.set(this, void 0), ft.set(this, false), dt.set(this, false), ut.set(this, false), pt.set(this, void 0), gt.set(this, {}), mt.set(this, null), yt.set(this, void 0), O(this, ct, i2, "f"), O(this, ht, t2, "f"), O(this, W, e2, "f"), O(this, st, s2, "f"), O(this, K, new w(this), "f"), this.$0 = this[jt](), this[Yt](), O(this, z, v(this, z, "f"), "f"), O(this, pt, v(this, pt, "f"), "f"), O(this, yt, v(this, yt, "f"), "f"), O(this, et, v(this, et, "f"), "f"), v(this, et, "f").showHiddenOpt = v(this, L, "f"), O(this, Q, this[vt](), "f");
      }
      addHelpOpt(t2, e2) {
        return h("[string|boolean] [string]", [t2, e2], arguments.length), v(this, Z, "f") && (this[Ot](v(this, Z, "f")), O(this, Z, null, "f")), false === t2 && void 0 === e2 || (O(this, Z, "string" == typeof t2 ? t2 : "help", "f"), this.boolean(v(this, Z, "f")), this.describe(v(this, Z, "f"), e2 || v(this, pt, "f").deferY18nLookup("Show help"))), this;
      }
      help(t2, e2) {
        return this.addHelpOpt(t2, e2);
      }
      addShowHiddenOpt(t2, e2) {
        if (h("[string|boolean] [string]", [t2, e2], arguments.length), false === t2 && void 0 === e2)
          return this;
        const s2 = "string" == typeof t2 ? t2 : v(this, L, "f");
        return this.boolean(s2), this.describe(s2, e2 || v(this, pt, "f").deferY18nLookup("Show hidden options")), v(this, et, "f").showHiddenOpt = s2, this;
      }
      showHidden(t2, e2) {
        return this.addShowHiddenOpt(t2, e2);
      }
      alias(t2, e2) {
        return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.alias.bind(this), "alias", t2, e2), this;
      }
      array(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("array", t2), this[Qt](t2), this;
      }
      boolean(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("boolean", t2), this[Qt](t2), this;
      }
      check(t2, e2) {
        return h("<function> [boolean]", [t2, e2], arguments.length), this.middleware((e3, s2) => j(() => t2(e3, s2.getOptions()), (s3) => (s3 ? ("string" == typeof s3 || s3 instanceof Error) && v(this, pt, "f").fail(s3.toString(), s3) : v(this, pt, "f").fail(v(this, ct, "f").y18n.__("Argument check failed: %s", t2.toString())), e3), (t3) => (v(this, pt, "f").fail(t3.message ? t3.message : t3.toString(), t3), e3)), false, e2), this;
      }
      choices(t2, e2) {
        return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.choices.bind(this), "choices", t2, e2), this;
      }
      coerce(t2, s2) {
        if (h("<object|string|array> [function]", [t2, s2], arguments.length), Array.isArray(t2)) {
          if (!s2)
            throw new e("coerce callback must be provided");
          for (const e2 of t2)
            this.coerce(e2, s2);
          return this;
        }
        if ("object" == typeof t2) {
          for (const e2 of Object.keys(t2))
            this.coerce(e2, t2[e2]);
          return this;
        }
        if (!s2)
          throw new e("coerce callback must be provided");
        return v(this, et, "f").key[t2] = true, v(this, K, "f").addCoerceMiddleware((i2, n2) => {
          let r2;
          return Object.prototype.hasOwnProperty.call(i2, t2) ? j(() => (r2 = n2.getAliases(), s2(i2[t2])), (e2) => {
            i2[t2] = e2;
            const s3 = n2.getInternalMethods().getParserConfiguration()["strip-aliased"];
            if (r2[t2] && true !== s3)
              for (const s4 of r2[t2])
                i2[s4] = e2;
            return i2;
          }, (t3) => {
            throw new e(t3.message);
          }) : i2;
        }, t2), this;
      }
      conflicts(t2, e2) {
        return h("<string|object> [string|array]", [t2, e2], arguments.length), v(this, yt, "f").conflicts(t2, e2), this;
      }
      config(t2 = "config", e2, s2) {
        return h("[object|string] [string|function] [function]", [t2, e2, s2], arguments.length), "object" != typeof t2 || Array.isArray(t2) ? ("function" == typeof e2 && (s2 = e2, e2 = void 0), this.describe(t2, e2 || v(this, pt, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
          v(this, et, "f").config[t3] = s2 || true;
        }), this) : (t2 = n(t2, v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(t2), this);
      }
      completion(t2, e2, s2) {
        return h("[string] [string|boolean|function] [function]", [t2, e2, s2], arguments.length), "function" == typeof e2 && (s2 = e2, e2 = void 0), O(this, F, t2 || v(this, F, "f") || "completion", "f"), e2 || false === e2 || (e2 = "generate completion script"), this.command(v(this, F, "f"), e2), s2 && v(this, U, "f").registerFunction(s2), this;
      }
      command(t2, e2, s2, i2, n2, r2) {
        return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t2, e2, s2, i2, n2, r2], arguments.length), v(this, z, "f").addHandler(t2, e2, s2, i2, n2, r2), this;
      }
      commands(t2, e2, s2, i2, n2, r2) {
        return this.command(t2, e2, s2, i2, n2, r2);
      }
      commandDir(t2, e2) {
        h("<string> [object]", [t2, e2], arguments.length);
        const s2 = v(this, st, "f") || v(this, ct, "f").require;
        return v(this, z, "f").addDirectory(t2, s2, v(this, ct, "f").getCallerFile(), e2), this;
      }
      count(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("count", t2), this[Qt](t2), this;
      }
      default(t2, e2, s2) {
        return h("<object|string|array> [*] [string]", [t2, e2, s2], arguments.length), s2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] = s2), "function" == typeof e2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] || (v(this, et, "f").defaultDescription[t2] = v(this, pt, "f").functionDescription(e2)), e2 = e2.call()), this[St](this.default.bind(this), "default", t2, e2), this;
      }
      defaults(t2, e2, s2) {
        return this.default(t2, e2, s2);
      }
      demandCommand(t2 = 1, e2, s2, i2) {
        return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t2, e2, s2, i2], arguments.length), "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), this.global("_", false), v(this, et, "f").demandedCommands._ = { min: t2, max: e2, minMsg: s2, maxMsg: i2 }, this;
      }
      demand(t2, e2, s2) {
        return Array.isArray(e2) ? (e2.forEach((t3) => {
          d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
        }), e2 = 1 / 0) : "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), "number" == typeof t2 ? (d(s2, true, v(this, ct, "f")), this.demandCommand(t2, e2, s2, s2)) : Array.isArray(t2) ? t2.forEach((t3) => {
          d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
        }) : "string" == typeof s2 ? this.demandOption(t2, s2) : true !== s2 && void 0 !== s2 || this.demandOption(t2), this;
      }
      demandOption(t2, e2) {
        return h("<object|string|array> [string]", [t2, e2], arguments.length), this[St](this.demandOption.bind(this), "demandedOptions", t2, e2), this;
      }
      deprecateOption(t2, e2) {
        return h("<string> [string|boolean]", [t2, e2], arguments.length), v(this, et, "f").deprecatedOptions[t2] = e2, this;
      }
      describe(t2, e2) {
        return h("<object|string|array> [string]", [t2, e2], arguments.length), this[Nt](t2, true), v(this, pt, "f").describe(t2, e2), this;
      }
      detectLocale(t2) {
        return h("<boolean>", [t2], arguments.length), O(this, G, t2, "f"), this;
      }
      env(t2) {
        return h("[string|boolean]", [t2], arguments.length), false === t2 ? delete v(this, et, "f").envPrefix : v(this, et, "f").envPrefix = t2 || "", this;
      }
      epilogue(t2) {
        return h("<string>", [t2], arguments.length), v(this, pt, "f").epilog(t2), this;
      }
      epilog(t2) {
        return this.epilogue(t2);
      }
      example(t2, e2) {
        return h("<string|array> [string]", [t2, e2], arguments.length), Array.isArray(t2) ? t2.forEach((t3) => this.example(...t3)) : v(this, pt, "f").example(t2, e2), this;
      }
      exit(t2, e2) {
        O(this, J, true, "f"), O(this, V, e2, "f"), v(this, T, "f") && v(this, ct, "f").process.exit(t2);
      }
      exitProcess(t2 = true) {
        return h("[boolean]", [t2], arguments.length), O(this, T, t2, "f"), this;
      }
      fail(t2) {
        if (h("<function|boolean>", [t2], arguments.length), "boolean" == typeof t2 && false !== t2)
          throw new e("Invalid first argument. Expected function or boolean 'false'");
        return v(this, pt, "f").failFn(t2), this;
      }
      getAliases() {
        return this.parsed ? this.parsed.aliases : {};
      }
      async getCompletion(t2, e2) {
        return h("<array> [function]", [t2, e2], arguments.length), e2 ? v(this, U, "f").getCompletion(t2, e2) : new Promise((e3, s2) => {
          v(this, U, "f").getCompletion(t2, (t3, i2) => {
            t3 ? s2(t3) : e3(i2);
          });
        });
      }
      getDemandedOptions() {
        return h([], 0), v(this, et, "f").demandedOptions;
      }
      getDemandedCommands() {
        return h([], 0), v(this, et, "f").demandedCommands;
      }
      getDeprecatedOptions() {
        return h([], 0), v(this, et, "f").deprecatedOptions;
      }
      getDetectLocale() {
        return v(this, G, "f");
      }
      getExitProcess() {
        return v(this, T, "f");
      }
      getGroups() {
        return Object.assign({}, v(this, Y, "f"), v(this, at, "f"));
      }
      getHelp() {
        if (O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const t3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
            if (f(t3))
              return t3.then(() => v(this, pt, "f").help());
          }
          const t2 = v(this, z, "f").runDefaultBuilderOn(this);
          if (f(t2))
            return t2.then(() => v(this, pt, "f").help());
        }
        return Promise.resolve(v(this, pt, "f").help());
      }
      getOptions() {
        return v(this, et, "f");
      }
      getStrict() {
        return v(this, ft, "f");
      }
      getStrictCommands() {
        return v(this, dt, "f");
      }
      getStrictOptions() {
        return v(this, ut, "f");
      }
      global(t2, e2) {
        return h("<string|array> [boolean]", [t2, e2], arguments.length), t2 = [].concat(t2), false !== e2 ? v(this, et, "f").local = v(this, et, "f").local.filter((e3) => -1 === t2.indexOf(e3)) : t2.forEach((t3) => {
          v(this, et, "f").local.includes(t3) || v(this, et, "f").local.push(t3);
        }), this;
      }
      group(t2, e2) {
        h("<string|array> <string>", [t2, e2], arguments.length);
        const s2 = v(this, at, "f")[e2] || v(this, Y, "f")[e2];
        v(this, at, "f")[e2] && delete v(this, at, "f")[e2];
        const i2 = {};
        return v(this, Y, "f")[e2] = (s2 || []).concat(t2).filter((t3) => !i2[t3] && (i2[t3] = true)), this;
      }
      hide(t2) {
        return h("<string>", [t2], arguments.length), v(this, et, "f").hiddenOptions.push(t2), this;
      }
      implies(t2, e2) {
        return h("<string|object> [number|string|array]", [t2, e2], arguments.length), v(this, yt, "f").implies(t2, e2), this;
      }
      locale(t2) {
        return h("[string]", [t2], arguments.length), void 0 === t2 ? (this[kt](), v(this, ct, "f").y18n.getLocale()) : (O(this, G, false, "f"), v(this, ct, "f").y18n.setLocale(t2), this);
      }
      middleware(t2, e2, s2) {
        return v(this, K, "f").addMiddleware(t2, !!e2, s2);
      }
      nargs(t2, e2) {
        return h("<string|object|array> [number]", [t2, e2], arguments.length), this[St](this.nargs.bind(this), "narg", t2, e2), this;
      }
      normalize(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("normalize", t2), this;
      }
      number(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("number", t2), this[Qt](t2), this;
      }
      option(t2, e2) {
        if (h("<string|object> [object]", [t2, e2], arguments.length), "object" == typeof t2)
          Object.keys(t2).forEach((e3) => {
            this.options(e3, t2[e3]);
          });
        else {
          "object" != typeof e2 && (e2 = {}), this[Qt](t2), !v(this, mt, "f") || "version" !== t2 && "version" !== (null == e2 ? void 0 : e2.alias) || this[wt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join("\n"), void 0, "versionWarning"), v(this, et, "f").key[t2] = true, e2.alias && this.alias(t2, e2.alias);
          const s2 = e2.deprecate || e2.deprecated;
          s2 && this.deprecateOption(t2, s2);
          const i2 = e2.demand || e2.required || e2.require;
          i2 && this.demand(t2, i2), e2.demandOption && this.demandOption(t2, "string" == typeof e2.demandOption ? e2.demandOption : void 0), e2.conflicts && this.conflicts(t2, e2.conflicts), "default" in e2 && this.default(t2, e2.default), void 0 !== e2.implies && this.implies(t2, e2.implies), void 0 !== e2.nargs && this.nargs(t2, e2.nargs), e2.config && this.config(t2, e2.configParser), e2.normalize && this.normalize(t2), e2.choices && this.choices(t2, e2.choices), e2.coerce && this.coerce(t2, e2.coerce), e2.group && this.group(t2, e2.group), (e2.boolean || "boolean" === e2.type) && (this.boolean(t2), e2.alias && this.boolean(e2.alias)), (e2.array || "array" === e2.type) && (this.array(t2), e2.alias && this.array(e2.alias)), (e2.number || "number" === e2.type) && (this.number(t2), e2.alias && this.number(e2.alias)), (e2.string || "string" === e2.type) && (this.string(t2), e2.alias && this.string(e2.alias)), (e2.count || "count" === e2.type) && this.count(t2), "boolean" == typeof e2.global && this.global(t2, e2.global), e2.defaultDescription && (v(this, et, "f").defaultDescription[t2] = e2.defaultDescription), e2.skipValidation && this.skipValidation(t2);
          const n2 = e2.describe || e2.description || e2.desc, r2 = v(this, pt, "f").getDescriptions();
          Object.prototype.hasOwnProperty.call(r2, t2) && "string" != typeof n2 || this.describe(t2, n2), e2.hidden && this.hide(t2), e2.requiresArg && this.requiresArg(t2);
        }
        return this;
      }
      options(t2, e2) {
        return this.option(t2, e2);
      }
      parse(t2, e2, s2) {
        h("[string|array] [function|boolean|object] [function]", [t2, e2, s2], arguments.length), this[Ct](), void 0 === t2 && (t2 = v(this, ht, "f")), "object" == typeof e2 && (O(this, rt, e2, "f"), e2 = s2), "function" == typeof e2 && (O(this, nt, e2, "f"), e2 = false), e2 || O(this, ht, t2, "f"), v(this, nt, "f") && O(this, T, false, "f");
        const i2 = this[Jt](t2, !!e2), n2 = this.parsed;
        return v(this, U, "f").setParsed(this.parsed), f(i2) ? i2.then((t3) => (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), t3, v(this, tt, "f")), t3)).catch((t3) => {
          throw v(this, nt, "f") && v(this, nt, "f")(t3, this.parsed.argv, v(this, tt, "f")), t3;
        }).finally(() => {
          this[Ht](), this.parsed = n2;
        }) : (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), i2, v(this, tt, "f")), this[Ht](), this.parsed = n2, i2);
      }
      parseAsync(t2, e2, s2) {
        const i2 = this.parse(t2, e2, s2);
        return f(i2) ? i2 : Promise.resolve(i2);
      }
      parseSync(t2, s2, i2) {
        const n2 = this.parse(t2, s2, i2);
        if (f(n2))
          throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
        return n2;
      }
      parserConfiguration(t2) {
        return h("<object>", [t2], arguments.length), O(this, it, t2, "f"), this;
      }
      pkgConf(t2, e2) {
        h("<string> [string]", [t2, e2], arguments.length);
        let s2 = null;
        const i2 = this[At](e2 || v(this, W, "f"));
        return i2[t2] && "object" == typeof i2[t2] && (s2 = n(i2[t2], e2 || v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(s2)), this;
      }
      positional(t2, e2) {
        h("<string> <object>", [t2, e2], arguments.length);
        const s2 = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
        e2 = g(e2, (t3, e3) => !("type" === t3 && !["string", "number", "boolean"].includes(e3)) && s2.includes(t3));
        const i2 = v(this, q, "f").fullCommands[v(this, q, "f").fullCommands.length - 1], n2 = i2 ? v(this, z, "f").cmdToParseOptions(i2) : { array: [], alias: {}, default: {}, demand: {} };
        return p(n2).forEach((s3) => {
          const i3 = n2[s3];
          Array.isArray(i3) ? -1 !== i3.indexOf(t2) && (e2[s3] = true) : i3[t2] && !(s3 in e2) && (e2[s3] = i3[t2]);
        }), this.group(t2, v(this, pt, "f").getPositionalGroupName()), this.option(t2, e2);
      }
      recommendCommands(t2 = true) {
        return h("[boolean]", [t2], arguments.length), O(this, lt, t2, "f"), this;
      }
      required(t2, e2, s2) {
        return this.demand(t2, e2, s2);
      }
      require(t2, e2, s2) {
        return this.demand(t2, e2, s2);
      }
      requiresArg(t2) {
        return h("<array|string|object> [number]", [t2], arguments.length), "string" == typeof t2 && v(this, et, "f").narg[t2] || this[St](this.requiresArg.bind(this), "narg", t2, NaN), this;
      }
      showCompletionScript(t2, e2) {
        return h("[string] [string]", [t2, e2], arguments.length), t2 = t2 || this.$0, v(this, Q, "f").log(v(this, U, "f").generateCompletionScript(t2, e2 || v(this, F, "f") || "completion")), this;
      }
      showHelp(t2) {
        if (h("[string|function]", [t2], arguments.length), O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const e3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
            if (f(e3))
              return e3.then(() => {
                v(this, pt, "f").showHelp(t2);
              }), this;
          }
          const e2 = v(this, z, "f").runDefaultBuilderOn(this);
          if (f(e2))
            return e2.then(() => {
              v(this, pt, "f").showHelp(t2);
            }), this;
        }
        return v(this, pt, "f").showHelp(t2), this;
      }
      scriptName(t2) {
        return this.customScriptName = true, this.$0 = t2, this;
      }
      showHelpOnFail(t2, e2) {
        return h("[boolean|string] [string]", [t2, e2], arguments.length), v(this, pt, "f").showHelpOnFail(t2, e2), this;
      }
      showVersion(t2) {
        return h("[string|function]", [t2], arguments.length), v(this, pt, "f").showVersion(t2), this;
      }
      skipValidation(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("skipValidation", t2), this;
      }
      strict(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, ft, false !== t2, "f"), this;
      }
      strictCommands(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, dt, false !== t2, "f"), this;
      }
      strictOptions(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, ut, false !== t2, "f"), this;
      }
      string(t2) {
        return h("<array|string>", [t2], arguments.length), this[Pt]("string", t2), this[Qt](t2), this;
      }
      terminalWidth() {
        return h([], 0), v(this, ct, "f").process.stdColumns;
      }
      updateLocale(t2) {
        return this.updateStrings(t2);
      }
      updateStrings(t2) {
        return h("<object>", [t2], arguments.length), O(this, G, false, "f"), v(this, ct, "f").y18n.updateLocale(t2), this;
      }
      usage(t2, s2, i2, n2) {
        if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t2, s2, i2, n2], arguments.length), void 0 !== s2) {
          if (d(t2, null, v(this, ct, "f")), (t2 || "").match(/^\$0( |$)/))
            return this.command(t2, s2, i2, n2);
          throw new e(".usage() description must start with $0 if being used as alias for .command()");
        }
        return v(this, pt, "f").usage(t2), this;
      }
      usageConfiguration(t2) {
        return h("<object>", [t2], arguments.length), O(this, gt, t2, "f"), this;
      }
      version(t2, e2, s2) {
        const i2 = "version";
        if (h("[boolean|string] [string] [string]", [t2, e2, s2], arguments.length), v(this, mt, "f") && (this[Ot](v(this, mt, "f")), v(this, pt, "f").version(void 0), O(this, mt, null, "f")), 0 === arguments.length)
          s2 = this[xt](), t2 = i2;
        else if (1 === arguments.length) {
          if (false === t2)
            return this;
          s2 = t2, t2 = i2;
        } else
          2 === arguments.length && (s2 = e2, e2 = void 0);
        return O(this, mt, "string" == typeof t2 ? t2 : i2, "f"), e2 = e2 || v(this, pt, "f").deferY18nLookup("Show version number"), v(this, pt, "f").version(s2 || void 0), this.boolean(v(this, mt, "f")), this.describe(v(this, mt, "f"), e2), this;
      }
      wrap(t2) {
        return h("<number|null|undefined>", [t2], arguments.length), v(this, pt, "f").wrap(t2), this;
      }
      [(z = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), tt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), ht = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt)](t2) {
        if (!t2._ || !t2["--"])
          return t2;
        t2._.push.apply(t2._, t2["--"]);
        try {
          delete t2["--"];
        } catch (t3) {
        }
        return t2;
      }
      [vt]() {
        return { log: (...t2) => {
          this[Rt]() || console.log(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
        }, error: (...t2) => {
          this[Rt]() || console.error(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
        } };
      }
      [Ot](t2) {
        p(v(this, et, "f")).forEach((e2) => {
          if ("configObjects" === e2)
            return;
          const s2 = v(this, et, "f")[e2];
          Array.isArray(s2) ? s2.includes(t2) && s2.splice(s2.indexOf(t2), 1) : "object" == typeof s2 && delete s2[t2];
        }), delete v(this, pt, "f").getDescriptions()[t2];
      }
      [wt](t2, e2, s2) {
        v(this, R, "f")[s2] || (v(this, ct, "f").process.emitWarning(t2, e2), v(this, R, "f")[s2] = true);
      }
      [Ct]() {
        v(this, B, "f").push({ options: v(this, et, "f"), configObjects: v(this, et, "f").configObjects.slice(0), exitProcess: v(this, T, "f"), groups: v(this, Y, "f"), strict: v(this, ft, "f"), strictCommands: v(this, dt, "f"), strictOptions: v(this, ut, "f"), completionCommand: v(this, F, "f"), output: v(this, tt, "f"), exitError: v(this, V, "f"), hasOutput: v(this, J, "f"), parsed: this.parsed, parseFn: v(this, nt, "f"), parseContext: v(this, rt, "f") }), v(this, pt, "f").freeze(), v(this, yt, "f").freeze(), v(this, z, "f").freeze(), v(this, K, "f").freeze();
      }
      [jt]() {
        let t2, e2 = "";
        return t2 = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, ct, "f").process.argv()[0]) ? v(this, ct, "f").process.argv().slice(1, 2) : v(this, ct, "f").process.argv().slice(0, 1), e2 = t2.map((t3) => {
          const e3 = this[Kt](v(this, W, "f"), t3);
          return t3.match(/^(\/|([a-zA-Z]:)?\\)/) && e3.length < t3.length ? e3 : t3;
        }).join(" ").trim(), v(this, ct, "f").getEnv("_") && v(this, ct, "f").getProcessArgvBin() === v(this, ct, "f").getEnv("_") && (e2 = v(this, ct, "f").getEnv("_").replace(`${v(this, ct, "f").path.dirname(v(this, ct, "f").process.execPath())}/`, "")), e2;
      }
      [Mt]() {
        return v(this, it, "f");
      }
      [_t]() {
        return v(this, gt, "f");
      }
      [kt]() {
        if (!v(this, G, "f"))
          return;
        const t2 = v(this, ct, "f").getEnv("LC_ALL") || v(this, ct, "f").getEnv("LC_MESSAGES") || v(this, ct, "f").getEnv("LANG") || v(this, ct, "f").getEnv("LANGUAGE") || "en_US";
        this.locale(t2.replace(/[.:].*/, ""));
      }
      [xt]() {
        return this[At]().version || "unknown";
      }
      [Et](t2) {
        const e2 = t2["--"] ? t2["--"] : t2._;
        for (let t3, s2 = 0; void 0 !== (t3 = e2[s2]); s2++)
          v(this, ct, "f").Parser.looksLikeNumber(t3) && Number.isSafeInteger(Math.floor(parseFloat(`${t3}`))) && (e2[s2] = Number(t3));
        return t2;
      }
      [At](t2) {
        const e2 = t2 || "*";
        if (v(this, ot, "f")[e2])
          return v(this, ot, "f")[e2];
        let s2 = {};
        try {
          let e3 = t2 || v(this, ct, "f").mainFilename;
          !t2 && v(this, ct, "f").path.extname(e3) && (e3 = v(this, ct, "f").path.dirname(e3));
          const i2 = v(this, ct, "f").findUp(e3, (t3, e4) => e4.includes("package.json") ? "package.json" : void 0);
          d(i2, void 0, v(this, ct, "f")), s2 = JSON.parse(v(this, ct, "f").readFileSync(i2, "utf8"));
        } catch (t3) {
        }
        return v(this, ot, "f")[e2] = s2 || {}, v(this, ot, "f")[e2];
      }
      [Pt](t2, e2) {
        (e2 = [].concat(e2)).forEach((e3) => {
          e3 = this[Dt](e3), v(this, et, "f")[t2].push(e3);
        });
      }
      [St](t2, e2, s2, i2) {
        this[It](t2, e2, s2, i2, (t3, e3, s3) => {
          v(this, et, "f")[t3][e3] = s3;
        });
      }
      [$t](t2, e2, s2, i2) {
        this[It](t2, e2, s2, i2, (t3, e3, s3) => {
          v(this, et, "f")[t3][e3] = (v(this, et, "f")[t3][e3] || []).concat(s3);
        });
      }
      [It](t2, e2, s2, i2, n2) {
        if (Array.isArray(s2))
          s2.forEach((e3) => {
            t2(e3, i2);
          });
        else if (((t3) => "object" == typeof t3)(s2))
          for (const e3 of p(s2))
            t2(e3, s2[e3]);
        else
          n2(e2, this[Dt](s2), i2);
      }
      [Dt](t2) {
        return "__proto__" === t2 ? "___proto___" : t2;
      }
      [Nt](t2, e2) {
        return this[St](this[Nt].bind(this), "key", t2, e2), this;
      }
      [Ht]() {
        var t2, e2, s2, i2, n2, r2, o2, a2, h2, l2, c2, f2;
        const u2 = v(this, B, "f").pop();
        let p2;
        d(u2, void 0, v(this, ct, "f")), t2 = this, e2 = this, s2 = this, i2 = this, n2 = this, r2 = this, o2 = this, a2 = this, h2 = this, l2 = this, c2 = this, f2 = this, { options: { set value(e3) {
          O(t2, et, e3, "f");
        } }.value, configObjects: p2, exitProcess: { set value(t3) {
          O(e2, T, t3, "f");
        } }.value, groups: { set value(t3) {
          O(s2, Y, t3, "f");
        } }.value, output: { set value(t3) {
          O(i2, tt, t3, "f");
        } }.value, exitError: { set value(t3) {
          O(n2, V, t3, "f");
        } }.value, hasOutput: { set value(t3) {
          O(r2, J, t3, "f");
        } }.value, parsed: this.parsed, strict: { set value(t3) {
          O(o2, ft, t3, "f");
        } }.value, strictCommands: { set value(t3) {
          O(a2, dt, t3, "f");
        } }.value, strictOptions: { set value(t3) {
          O(h2, ut, t3, "f");
        } }.value, completionCommand: { set value(t3) {
          O(l2, F, t3, "f");
        } }.value, parseFn: { set value(t3) {
          O(c2, nt, t3, "f");
        } }.value, parseContext: { set value(t3) {
          O(f2, rt, t3, "f");
        } }.value } = u2, v(this, et, "f").configObjects = p2, v(this, pt, "f").unfreeze(), v(this, yt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, K, "f").unfreeze();
      }
      [zt](t2, e2) {
        return j(e2, (e3) => (t2(e3), e3));
      }
      getInternalMethods() {
        return { getCommandInstance: this[Wt].bind(this), getContext: this[qt].bind(this), getHasOutput: this[Ut].bind(this), getLoggerInstance: this[Ft].bind(this), getParseContext: this[Lt].bind(this), getParserConfiguration: this[Mt].bind(this), getUsageConfiguration: this[_t].bind(this), getUsageInstance: this[Vt].bind(this), getValidationInstance: this[Gt].bind(this), hasParseCallback: this[Rt].bind(this), isGlobalContext: this[Tt].bind(this), postProcess: this[Bt].bind(this), reset: this[Yt].bind(this), runValidation: this[Zt].bind(this), runYargsParserAndExecuteCommands: this[Jt].bind(this), setHasOutput: this[Xt].bind(this) };
      }
      [Wt]() {
        return v(this, z, "f");
      }
      [qt]() {
        return v(this, q, "f");
      }
      [Ut]() {
        return v(this, J, "f");
      }
      [Ft]() {
        return v(this, Q, "f");
      }
      [Lt]() {
        return v(this, rt, "f") || {};
      }
      [Vt]() {
        return v(this, pt, "f");
      }
      [Gt]() {
        return v(this, yt, "f");
      }
      [Rt]() {
        return !!v(this, nt, "f");
      }
      [Tt]() {
        return v(this, X, "f");
      }
      [Bt](t2, e2, s2, i2) {
        if (s2)
          return t2;
        if (f(t2))
          return t2;
        e2 || (t2 = this[bt](t2));
        return (this[Mt]()["parse-positional-numbers"] || void 0 === this[Mt]()["parse-positional-numbers"]) && (t2 = this[Et](t2)), i2 && (t2 = C(t2, this, v(this, K, "f").getMiddleware(), false)), t2;
      }
      [Yt](t2 = {}) {
        O(this, et, v(this, et, "f") || {}, "f");
        const e2 = {};
        e2.local = v(this, et, "f").local || [], e2.configObjects = v(this, et, "f").configObjects || [];
        const s2 = {};
        e2.local.forEach((e3) => {
          s2[e3] = true, (t2[e3] || []).forEach((t3) => {
            s2[t3] = true;
          });
        }), Object.assign(v(this, at, "f"), Object.keys(v(this, Y, "f")).reduce((t3, e3) => {
          const i2 = v(this, Y, "f")[e3].filter((t4) => !(t4 in s2));
          return i2.length > 0 && (t3[e3] = i2), t3;
        }, {})), O(this, Y, {}, "f");
        return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach((t3) => {
          e2[t3] = (v(this, et, "f")[t3] || []).filter((t4) => !s2[t4]);
        }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach((t3) => {
          e2[t3] = g(v(this, et, "f")[t3], (t4) => !s2[t4]);
        }), e2.envPrefix = v(this, et, "f").envPrefix, O(this, et, e2, "f"), O(this, pt, v(this, pt, "f") ? v(this, pt, "f").reset(s2) : P(this, v(this, ct, "f")), "f"), O(this, yt, v(this, yt, "f") ? v(this, yt, "f").reset(s2) : function(t3, e3, s3) {
          const i2 = s3.y18n.__, n2 = s3.y18n.__n, r2 = { nonOptionCount: function(s4) {
            const i3 = t3.getDemandedCommands(), r3 = s4._.length + (s4["--"] ? s4["--"].length : 0) - t3.getInternalMethods().getContext().commands.length;
            i3._ && (r3 < i3._.min || r3 > i3._.max) && (r3 < i3._.min ? void 0 !== i3._.minMsg ? e3.fail(i3._.minMsg ? i3._.minMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.min.toString()) : null) : e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r3, r3.toString(), i3._.min.toString())) : r3 > i3._.max && (void 0 !== i3._.maxMsg ? e3.fail(i3._.maxMsg ? i3._.maxMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.max.toString()) : null) : e3.fail(n2("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r3, r3.toString(), i3._.max.toString()))));
          }, positionalCount: function(t4, s4) {
            s4 < t4 && e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s4, s4 + "", t4 + ""));
          }, requiredArguments: function(t4, s4) {
            let i3 = null;
            for (const e4 of Object.keys(s4))
              Object.prototype.hasOwnProperty.call(t4, e4) && void 0 !== t4[e4] || (i3 = i3 || {}, i3[e4] = s4[e4]);
            if (i3) {
              const t5 = [];
              for (const e4 of Object.keys(i3)) {
                const s6 = i3[e4];
                s6 && t5.indexOf(s6) < 0 && t5.push(s6);
              }
              const s5 = t5.length ? `
${t5.join("\n")}` : "";
              e3.fail(n2("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i3).length, Object.keys(i3).join(", ") + s5));
            }
          }, unknownArguments: function(s4, i3, o3, a3, h2 = true) {
            var l3;
            const c3 = t3.getInternalMethods().getCommandInstance().getCommands(), f2 = [], d2 = t3.getInternalMethods().getContext();
            if (Object.keys(s4).forEach((e4) => {
              H.includes(e4) || Object.prototype.hasOwnProperty.call(o3, e4) || Object.prototype.hasOwnProperty.call(t3.getInternalMethods().getParseContext(), e4) || r2.isValidAndSomeAliasIsNotNew(e4, i3) || f2.push(e4);
            }), h2 && (d2.commands.length > 0 || c3.length > 0 || a3) && s4._.slice(d2.commands.length).forEach((t4) => {
              c3.includes("" + t4) || f2.push("" + t4);
            }), h2) {
              const e4 = (null === (l3 = t3.getDemandedCommands()._) || void 0 === l3 ? void 0 : l3.max) || 0, i4 = d2.commands.length + e4;
              i4 < s4._.length && s4._.slice(i4).forEach((t4) => {
                t4 = String(t4), d2.commands.includes(t4) || f2.includes(t4) || f2.push(t4);
              });
            }
            f2.length && e3.fail(n2("Unknown argument: %s", "Unknown arguments: %s", f2.length, f2.map((t4) => t4.trim() ? t4 : `"${t4}"`).join(", ")));
          }, unknownCommands: function(s4) {
            const i3 = t3.getInternalMethods().getCommandInstance().getCommands(), r3 = [], o3 = t3.getInternalMethods().getContext();
            return (o3.commands.length > 0 || i3.length > 0) && s4._.slice(o3.commands.length).forEach((t4) => {
              i3.includes("" + t4) || r3.push("" + t4);
            }), r3.length > 0 && (e3.fail(n2("Unknown command: %s", "Unknown commands: %s", r3.length, r3.join(", "))), true);
          }, isValidAndSomeAliasIsNotNew: function(e4, s4) {
            if (!Object.prototype.hasOwnProperty.call(s4, e4))
              return false;
            const i3 = t3.parsed.newAliases;
            return [e4, ...s4[e4]].some((t4) => !Object.prototype.hasOwnProperty.call(i3, t4) || !i3[e4]);
          }, limitedChoices: function(s4) {
            const n3 = t3.getOptions(), r3 = {};
            if (!Object.keys(n3.choices).length)
              return;
            Object.keys(s4).forEach((t4) => {
              -1 === H.indexOf(t4) && Object.prototype.hasOwnProperty.call(n3.choices, t4) && [].concat(s4[t4]).forEach((e4) => {
                -1 === n3.choices[t4].indexOf(e4) && void 0 !== e4 && (r3[t4] = (r3[t4] || []).concat(e4));
              });
            });
            const o3 = Object.keys(r3);
            if (!o3.length)
              return;
            let a3 = i2("Invalid values:");
            o3.forEach((t4) => {
              a3 += `
  ${i2("Argument: %s, Given: %s, Choices: %s", t4, e3.stringifiedValues(r3[t4]), e3.stringifiedValues(n3.choices[t4]))}`;
            }), e3.fail(a3);
          } };
          let o2 = {};
          function a2(t4, e4) {
            const s4 = Number(e4);
            return "number" == typeof (e4 = isNaN(s4) ? e4 : s4) ? e4 = t4._.length >= e4 : e4.match(/^--no-.+/) ? (e4 = e4.match(/^--no-(.+)/)[1], e4 = !Object.prototype.hasOwnProperty.call(t4, e4)) : e4 = Object.prototype.hasOwnProperty.call(t4, e4), e4;
          }
          r2.implies = function(e4, i3) {
            h("<string|object> [array|number|string]", [e4, i3], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
              r2.implies(t4, e4[t4]);
            }) : (t3.global(e4), o2[e4] || (o2[e4] = []), Array.isArray(i3) ? i3.forEach((t4) => r2.implies(e4, t4)) : (d(i3, void 0, s3), o2[e4].push(i3)));
          }, r2.getImplied = function() {
            return o2;
          }, r2.implications = function(t4) {
            const s4 = [];
            if (Object.keys(o2).forEach((e4) => {
              const i3 = e4;
              (o2[e4] || []).forEach((e5) => {
                let n3 = i3;
                const r3 = e5;
                n3 = a2(t4, n3), e5 = a2(t4, e5), n3 && !e5 && s4.push(` ${i3} -> ${r3}`);
              });
            }), s4.length) {
              let t5 = `${i2("Implications failed:")}
`;
              s4.forEach((e4) => {
                t5 += e4;
              }), e3.fail(t5);
            }
          };
          let l2 = {};
          r2.conflicts = function(e4, s4) {
            h("<string|object> [array|string]", [e4, s4], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
              r2.conflicts(t4, e4[t4]);
            }) : (t3.global(e4), l2[e4] || (l2[e4] = []), Array.isArray(s4) ? s4.forEach((t4) => r2.conflicts(e4, t4)) : l2[e4].push(s4));
          }, r2.getConflicting = () => l2, r2.conflicting = function(n3) {
            Object.keys(n3).forEach((t4) => {
              l2[t4] && l2[t4].forEach((s4) => {
                s4 && void 0 !== n3[t4] && void 0 !== n3[s4] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, s4));
              });
            }), t3.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l2).forEach((t4) => {
              l2[t4].forEach((r3) => {
                r3 && void 0 !== n3[s3.Parser.camelCase(t4)] && void 0 !== n3[s3.Parser.camelCase(r3)] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, r3));
              });
            });
          }, r2.recommendCommands = function(t4, s4) {
            s4 = s4.sort((t5, e4) => e4.length - t5.length);
            let n3 = null, r3 = 1 / 0;
            for (let e4, i3 = 0; void 0 !== (e4 = s4[i3]); i3++) {
              const s5 = N(t4, e4);
              s5 <= 3 && s5 < r3 && (r3 = s5, n3 = e4);
            }
            n3 && e3.fail(i2("Did you mean %s?", n3));
          }, r2.reset = function(t4) {
            return o2 = g(o2, (e4) => !t4[e4]), l2 = g(l2, (e4) => !t4[e4]), r2;
          };
          const c2 = [];
          return r2.freeze = function() {
            c2.push({ implied: o2, conflicting: l2 });
          }, r2.unfreeze = function() {
            const t4 = c2.pop();
            d(t4, void 0, s3), { implied: o2, conflicting: l2 } = t4;
          }, r2;
        }(this, v(this, pt, "f"), v(this, ct, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function(t3, e3, s3, i2) {
          return new _(t3, e3, s3, i2);
        }(v(this, pt, "f"), v(this, yt, "f"), v(this, K, "f"), v(this, ct, "f")), "f"), v(this, U, "f") || O(this, U, function(t3, e3, s3, i2) {
          return new D(t3, e3, s3, i2);
        }(this, v(this, pt, "f"), v(this, z, "f"), v(this, ct, "f")), "f"), v(this, K, "f").reset(), O(this, F, null, "f"), O(this, tt, "", "f"), O(this, V, null, "f"), O(this, J, false, "f"), this.parsed = false, this;
      }
      [Kt](t2, e2) {
        return v(this, ct, "f").path.relative(t2, e2);
      }
      [Jt](t2, s2, i2, n2 = 0, r2 = false) {
        let o2 = !!i2 || r2;
        t2 = t2 || v(this, ht, "f"), v(this, et, "f").__ = v(this, ct, "f").y18n.__, v(this, et, "f").configuration = this[Mt]();
        const a2 = !!v(this, et, "f").configuration["populate--"], h2 = Object.assign({}, v(this, et, "f").configuration, { "populate--": true }), l2 = v(this, ct, "f").Parser.detailed(t2, Object.assign({}, v(this, et, "f"), { configuration: { "parse-positional-numbers": false, ...h2 } })), c2 = Object.assign(l2.argv, v(this, rt, "f"));
        let d2;
        const u2 = l2.aliases;
        let p2 = false, g2 = false;
        Object.keys(c2).forEach((t3) => {
          t3 === v(this, Z, "f") && c2[t3] ? p2 = true : t3 === v(this, mt, "f") && c2[t3] && (g2 = true);
        }), c2.$0 = this.$0, this.parsed = l2, 0 === n2 && v(this, pt, "f").clearCachedHelpMessage();
        try {
          if (this[kt](), s2)
            return this[Bt](c2, a2, !!i2, false);
          if (v(this, Z, "f")) {
            [v(this, Z, "f")].concat(u2[v(this, Z, "f")] || []).filter((t3) => t3.length > 1).includes("" + c2._[c2._.length - 1]) && (c2._.pop(), p2 = true);
          }
          O(this, X, false, "f");
          const h3 = v(this, z, "f").getCommands(), m2 = v(this, U, "f").completionKey in c2, y2 = p2 || m2 || r2;
          if (c2._.length) {
            if (h3.length) {
              let t3;
              for (let e2, s3 = n2 || 0; void 0 !== c2._[s3]; s3++) {
                if (e2 = String(c2._[s3]), h3.includes(e2) && e2 !== v(this, F, "f")) {
                  const t4 = v(this, z, "f").runCommand(e2, this, l2, s3 + 1, r2, p2 || g2 || r2);
                  return this[Bt](t4, a2, !!i2, false);
                }
                if (!t3 && e2 !== v(this, F, "f")) {
                  t3 = e2;
                  break;
                }
              }
              !v(this, z, "f").hasDefaultCommand() && v(this, lt, "f") && t3 && !y2 && v(this, yt, "f").recommendCommands(t3, h3);
            }
            v(this, F, "f") && c2._.includes(v(this, F, "f")) && !m2 && (v(this, T, "f") && E(true), this.showCompletionScript(), this.exit(0));
          }
          if (v(this, z, "f").hasDefaultCommand() && !y2) {
            const t3 = v(this, z, "f").runCommand(null, this, l2, 0, r2, p2 || g2 || r2);
            return this[Bt](t3, a2, !!i2, false);
          }
          if (m2) {
            v(this, T, "f") && E(true);
            const s3 = (t2 = [].concat(t2)).slice(t2.indexOf(`--${v(this, U, "f").completionKey}`) + 1);
            return v(this, U, "f").getCompletion(s3, (t3, s4) => {
              if (t3)
                throw new e(t3.message);
              (s4 || []).forEach((t4) => {
                v(this, Q, "f").log(t4);
              }), this.exit(0);
            }), this[Bt](c2, !a2, !!i2, false);
          }
          if (v(this, J, "f") || (p2 ? (v(this, T, "f") && E(true), o2 = true, this.showHelp("log"), this.exit(0)) : g2 && (v(this, T, "f") && E(true), o2 = true, v(this, pt, "f").showVersion("log"), this.exit(0))), !o2 && v(this, et, "f").skipValidation.length > 0 && (o2 = Object.keys(c2).some((t3) => v(this, et, "f").skipValidation.indexOf(t3) >= 0 && true === c2[t3])), !o2) {
            if (l2.error)
              throw new e(l2.error.message);
            if (!m2) {
              const t3 = this[Zt](u2, {}, l2.error);
              i2 || (d2 = C(c2, this, v(this, K, "f").getMiddleware(), true)), d2 = this[zt](t3, null != d2 ? d2 : c2), f(d2) && !i2 && (d2 = d2.then(() => C(c2, this, v(this, K, "f").getMiddleware(), false)));
            }
          }
        } catch (t3) {
          if (!(t3 instanceof e))
            throw t3;
          v(this, pt, "f").fail(t3.message, t3);
        }
        return this[Bt](null != d2 ? d2 : c2, a2, !!i2, true);
      }
      [Zt](t2, s2, i2, n2) {
        const r2 = { ...this.getDemandedOptions() };
        return (o2) => {
          if (i2)
            throw new e(i2.message);
          v(this, yt, "f").nonOptionCount(o2), v(this, yt, "f").requiredArguments(o2, r2);
          let a2 = false;
          v(this, dt, "f") && (a2 = v(this, yt, "f").unknownCommands(o2)), v(this, ft, "f") && !a2 ? v(this, yt, "f").unknownArguments(o2, t2, s2, !!n2) : v(this, ut, "f") && v(this, yt, "f").unknownArguments(o2, t2, {}, false, false), v(this, yt, "f").limitedChoices(o2), v(this, yt, "f").implications(o2), v(this, yt, "f").conflicting(o2);
        };
      }
      [Xt]() {
        O(this, J, true, "f");
      }
      [Qt](t2) {
        if ("string" == typeof t2)
          v(this, et, "f").key[t2] = true;
        else
          for (const e2 of t2)
            v(this, et, "f").key[e2] = true;
      }
    };
    var ee;
    var se;
    var { readFileSync: ie } = require("fs");
    var { inspect: ne } = require("util");
    var { resolve: re } = require("path");
    var oe = require_build();
    var ae = require_build2();
    var he;
    var le = { assert: { notStrictEqual: t.notStrictEqual, strictEqual: t.strictEqual }, cliui: require_build3(), findUp: require_sync(), getEnv: (t2) => process.env[t2], getCallerFile: require_get_caller_file(), getProcessArgvBin: y, inspect: ne, mainFilename: null !== (se = null === (ee = null === require || void 0 === require ? void 0 : require.main) || void 0 === ee ? void 0 : ee.filename) && void 0 !== se ? se : process.cwd(), Parser: ae, path: require("path"), process: { argv: () => process.argv, cwd: process.cwd, emitWarning: (t2, e2) => process.emitWarning(t2, e2), execPath: () => process.execPath, exit: (t2) => {
      process.exit(t2);
    }, nextTick: process.nextTick, stdColumns: void 0 !== process.stdout.columns ? process.stdout.columns : null }, readFileSync: ie, require, requireDirectory: require_require_directory(), stringWidth: require_string_width(), y18n: oe({ directory: re(__dirname, "../locales"), updateFiles: false }) };
    var ce = (null === (he = null === process || void 0 === process ? void 0 : process.env) || void 0 === he ? void 0 : he.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    if (process && process.version) {
      if (Number(process.version.match(/v([^.]+)/)[1]) < ce)
        throw Error(`yargs supports a minimum Node.js version of ${ce}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
    }
    var fe = require_build2();
    var de;
    var ue = { applyExtends: n, cjsPlatformShim: le, Yargs: (de = le, (t2 = [], e2 = de.process.cwd(), s2) => {
      const i2 = new te(t2, e2, s2, de);
      return Object.defineProperty(i2, "argv", { get: () => i2.parse(), enumerable: true }), i2.help(), i2.version(), i2;
    }), argsert: h, isPromise: f, objFilter: g, parseCommand: o, Parser: fe, processArgv: b, YError: e };
    module2.exports = ue;
  }
});

// node_modules/yargs/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/yargs/helpers/index.js"(exports2, module2) {
    var {
      applyExtends,
      cjsPlatformShim,
      Parser,
      processArgv
    } = require_build4();
    module2.exports = {
      applyExtends: (config, cwd, mergeExtends) => {
        return applyExtends(config, cwd, mergeExtends, cjsPlatformShim);
      },
      hideBin: processArgv.hideBin,
      Parser
    };
  }
});

// node_modules/yargs/yargs
var require_yargs = __commonJS({
  "node_modules/yargs/yargs"(exports2, module2) {
    var { applyExtends, cjsPlatformShim, Parser, Yargs, processArgv } = require_build4();
    Yargs.applyExtends = (config, cwd, mergeExtends) => {
      return applyExtends(config, cwd, mergeExtends, cjsPlatformShim);
    };
    Yargs.hideBin = processArgv.hideBin;
    Yargs.Parser = Parser;
    module2.exports = Yargs;
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/CLI.js
var require_CLI = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/CLI.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _CLI_instances;
    var _CLI_cachePath;
    var _CLI_rl;
    var _CLI_defineBrowserParameter;
    var _CLI_definePlatformParameter;
    var _CLI_definePathParameter;
    var _CLI_parseBrowser;
    var _CLI_parseBuildId;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeProgressCallback = exports2.CLI = void 0;
    var process_1 = require("process");
    var readline = __importStar(require("readline"));
    var progress_1 = __importDefault(require_progress());
    var helpers_1 = require_helpers();
    var yargs_1 = __importDefault(require_yargs());
    var browser_data_js_1 = require_browser_data();
    var Cache_js_1 = require_Cache();
    var detectPlatform_js_1 = require_detectPlatform();
    var install_js_1 = require_install();
    var launch_js_1 = require_launch();
    var CLI = class {
      constructor(cachePath = process.cwd(), rl) {
        _CLI_instances.add(this);
        _CLI_cachePath.set(this, void 0);
        _CLI_rl.set(this, void 0);
        __classPrivateFieldSet(this, _CLI_cachePath, cachePath, "f");
        __classPrivateFieldSet(this, _CLI_rl, rl, "f");
      }
      async run(argv) {
        const yargsInstance = (0, yargs_1.default)((0, helpers_1.hideBin)(argv));
        await yargsInstance.scriptName("@puppeteer/browsers").command("install <browser>", "Download and install the specified browser. If successful, the command outputs the actual browser buildId that was installed and the absolute path to the browser executable (format: <browser>@<buildID> <path>).", (yargs) => {
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_defineBrowserParameter).call(this, yargs);
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_definePlatformParameter).call(this, yargs);
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_definePathParameter).call(this, yargs);
          yargs.option("base-url", {
            type: "string",
            desc: "Base URL to download from"
          });
          yargs.example("$0 install chrome", "Install the latest available build of the Chrome browser.");
          yargs.example("$0 install chrome@latest", "Install the latest available build for the Chrome browser.");
          yargs.example("$0 install chromium@1083080", "Install the revision 1083080 of the Chromium browser.");
          yargs.example("$0 install firefox", "Install the latest available build of the Firefox browser.");
          yargs.example("$0 install firefox --platform mac", "Install the latest Mac (Intel) build of the Firefox browser.");
          yargs.example("$0 install firefox --path /tmp/my-browser-cache", "Install to the specified cache directory.");
        }, async (argv2) => {
          var _a, _b, _c;
          const args = argv2;
          (_a = args.platform) !== null && _a !== void 0 ? _a : args.platform = (0, detectPlatform_js_1.detectBrowserPlatform)();
          if (!args.platform) {
            throw new Error(`Could not resolve the current platform`);
          }
          args.browser.buildId = await (0, browser_data_js_1.resolveBuildId)(args.browser.name, args.platform, args.browser.buildId);
          await (0, install_js_1.install)({
            browser: args.browser.name,
            buildId: args.browser.buildId,
            platform: args.platform,
            cacheDir: (_b = args.path) !== null && _b !== void 0 ? _b : __classPrivateFieldGet(this, _CLI_cachePath, "f"),
            downloadProgressCallback: makeProgressCallback(args.browser.name, args.browser.buildId),
            baseUrl: args.baseUrl
          });
          console.log(`${args.browser.name}@${args.browser.buildId} ${(0, launch_js_1.computeExecutablePath)({
            browser: args.browser.name,
            buildId: args.browser.buildId,
            cacheDir: (_c = args.path) !== null && _c !== void 0 ? _c : __classPrivateFieldGet(this, _CLI_cachePath, "f"),
            platform: args.platform
          })}`);
        }).command("launch <browser>", "Launch the specified browser", (yargs) => {
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_defineBrowserParameter).call(this, yargs);
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_definePlatformParameter).call(this, yargs);
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_definePathParameter).call(this, yargs);
          yargs.option("detached", {
            type: "boolean",
            desc: "Detach the child process.",
            default: false
          });
          yargs.option("system", {
            type: "boolean",
            desc: "Search for a browser installed on the system instead of the cache folder.",
            default: false
          });
          yargs.example("$0 launch chrome@1083080", "Launch the Chrome browser identified by the revision 1083080.");
          yargs.example("$0 launch firefox@112.0a1", "Launch the Firefox browser identified by the milestone 112.0a1.");
          yargs.example("$0 launch chrome@1083080 --detached", "Launch the browser but detach the sub-processes.");
          yargs.example("$0 launch chrome@canary --system", "Try to locate the Canary build of Chrome installed on the system and launch it.");
        }, async (argv2) => {
          var _a;
          const args = argv2;
          const executablePath = args.system ? (0, launch_js_1.computeSystemExecutablePath)({
            browser: args.browser.name,
            // TODO: throw an error if not a ChromeReleaseChannel is provided.
            channel: args.browser.buildId,
            platform: args.platform
          }) : (0, launch_js_1.computeExecutablePath)({
            browser: args.browser.name,
            buildId: args.browser.buildId,
            cacheDir: (_a = args.path) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _CLI_cachePath, "f"),
            platform: args.platform
          });
          (0, launch_js_1.launch)({
            executablePath,
            detached: args.detached
          });
        }).command("clear", "Removes all installed browsers from the specified cache directory", (yargs) => {
          __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_definePathParameter).call(this, yargs, true);
        }, async (argv2) => {
          var _a, _b;
          const args = argv2;
          const cacheDir = (_a = args.path) !== null && _a !== void 0 ? _a : __classPrivateFieldGet(this, _CLI_cachePath, "f");
          const rl = (_b = __classPrivateFieldGet(this, _CLI_rl, "f")) !== null && _b !== void 0 ? _b : readline.createInterface({ input: process_1.stdin, output: process_1.stdout });
          rl.question(`Do you want to permanently and recursively delete the content of ${cacheDir} (yes/No)? `, (answer) => {
            rl.close();
            if (!["y", "yes"].includes(answer.toLowerCase().trim())) {
              console.log("Cancelled.");
              return;
            }
            const cache = new Cache_js_1.Cache(cacheDir);
            cache.clear();
            console.log(`${cacheDir} cleared.`);
          });
        }).demandCommand(1).help().wrap(Math.min(120, yargsInstance.terminalWidth())).parse();
      }
    };
    exports2.CLI = CLI;
    _CLI_cachePath = /* @__PURE__ */ new WeakMap(), _CLI_rl = /* @__PURE__ */ new WeakMap(), _CLI_instances = /* @__PURE__ */ new WeakSet(), _CLI_defineBrowserParameter = function _CLI_defineBrowserParameter2(yargs) {
      yargs.positional("browser", {
        description: "Which browser to install <browser>[@<buildId|latest>]. `latest` will try to find the latest available build. `buildId` is a browser-specific identifier such as a version or a revision.",
        type: "string",
        coerce: (opt) => {
          return {
            name: __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_parseBrowser).call(this, opt),
            buildId: __classPrivateFieldGet(this, _CLI_instances, "m", _CLI_parseBuildId).call(this, opt)
          };
        }
      });
    }, _CLI_definePlatformParameter = function _CLI_definePlatformParameter2(yargs) {
      yargs.option("platform", {
        type: "string",
        desc: "Platform that the binary needs to be compatible with.",
        choices: Object.values(browser_data_js_1.BrowserPlatform),
        defaultDescription: "Auto-detected"
      });
    }, _CLI_definePathParameter = function _CLI_definePathParameter2(yargs, required = false) {
      yargs.option("path", {
        type: "string",
        desc: "Path to the root folder for the browser downloads and installation. The installation folder structure is compatible with the cache structure used by Puppeteer.",
        defaultDescription: "Current working directory",
        ...required ? {} : { default: process.cwd() }
      });
      if (required) {
        yargs.demandOption("path");
      }
    }, _CLI_parseBrowser = function _CLI_parseBrowser2(version) {
      return version.split("@").shift();
    }, _CLI_parseBuildId = function _CLI_parseBuildId2(version) {
      var _a;
      return (_a = version.split("@").pop()) !== null && _a !== void 0 ? _a : "latest";
    };
    function makeProgressCallback(browser, buildId) {
      let progressBar;
      let lastDownloadedBytes = 0;
      return (downloadedBytes, totalBytes) => {
        if (!progressBar) {
          progressBar = new progress_1.default(`Downloading ${browser} r${buildId} - ${toMegabytes(totalBytes)} [:bar] :percent :etas `, {
            complete: "=",
            incomplete: " ",
            width: 20,
            total: totalBytes
          });
        }
        const delta = downloadedBytes - lastDownloadedBytes;
        lastDownloadedBytes = downloadedBytes;
        progressBar.tick(delta);
      };
    }
    exports2.makeProgressCallback = makeProgressCallback;
    function toMegabytes(bytes) {
      const mb = bytes / 1e3 / 1e3;
      return `${Math.round(mb * 10) / 10} MB`;
    }
  }
});

// node_modules/@puppeteer/browsers/lib/cjs/main.js
var require_main = __commonJS({
  "node_modules/@puppeteer/browsers/lib/cjs/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cache = exports2.makeProgressCallback = exports2.CLI = exports2.createProfile = exports2.ChromeReleaseChannel = exports2.BrowserPlatform = exports2.Browser = exports2.resolveBuildId = exports2.detectBrowserPlatform = exports2.canDownload = exports2.install = exports2.Process = exports2.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX = exports2.CDP_WEBSOCKET_ENDPOINT_REGEX = exports2.TimeoutError = exports2.computeSystemExecutablePath = exports2.computeExecutablePath = exports2.launch = void 0;
    var launch_js_1 = require_launch();
    Object.defineProperty(exports2, "launch", { enumerable: true, get: function() {
      return launch_js_1.launch;
    } });
    Object.defineProperty(exports2, "computeExecutablePath", { enumerable: true, get: function() {
      return launch_js_1.computeExecutablePath;
    } });
    Object.defineProperty(exports2, "computeSystemExecutablePath", { enumerable: true, get: function() {
      return launch_js_1.computeSystemExecutablePath;
    } });
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return launch_js_1.TimeoutError;
    } });
    Object.defineProperty(exports2, "CDP_WEBSOCKET_ENDPOINT_REGEX", { enumerable: true, get: function() {
      return launch_js_1.CDP_WEBSOCKET_ENDPOINT_REGEX;
    } });
    Object.defineProperty(exports2, "WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX", { enumerable: true, get: function() {
      return launch_js_1.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX;
    } });
    Object.defineProperty(exports2, "Process", { enumerable: true, get: function() {
      return launch_js_1.Process;
    } });
    var install_js_1 = require_install();
    Object.defineProperty(exports2, "install", { enumerable: true, get: function() {
      return install_js_1.install;
    } });
    Object.defineProperty(exports2, "canDownload", { enumerable: true, get: function() {
      return install_js_1.canDownload;
    } });
    var detectPlatform_js_1 = require_detectPlatform();
    Object.defineProperty(exports2, "detectBrowserPlatform", { enumerable: true, get: function() {
      return detectPlatform_js_1.detectBrowserPlatform;
    } });
    var browser_data_js_1 = require_browser_data();
    Object.defineProperty(exports2, "resolveBuildId", { enumerable: true, get: function() {
      return browser_data_js_1.resolveBuildId;
    } });
    Object.defineProperty(exports2, "Browser", { enumerable: true, get: function() {
      return browser_data_js_1.Browser;
    } });
    Object.defineProperty(exports2, "BrowserPlatform", { enumerable: true, get: function() {
      return browser_data_js_1.BrowserPlatform;
    } });
    Object.defineProperty(exports2, "ChromeReleaseChannel", { enumerable: true, get: function() {
      return browser_data_js_1.ChromeReleaseChannel;
    } });
    Object.defineProperty(exports2, "createProfile", { enumerable: true, get: function() {
      return browser_data_js_1.createProfile;
    } });
    var CLI_js_1 = require_CLI();
    Object.defineProperty(exports2, "CLI", { enumerable: true, get: function() {
      return CLI_js_1.CLI;
    } });
    Object.defineProperty(exports2, "makeProgressCallback", { enumerable: true, get: function() {
      return CLI_js_1.makeProgressCallback;
    } });
    var Cache_js_1 = require_Cache();
    Object.defineProperty(exports2, "Cache", { enumerable: true, get: function() {
      return Cache_js_1.Cache;
    } });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/PipeTransport.js
var require_PipeTransport = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/PipeTransport.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _PipeTransport_instances;
    var _PipeTransport_pipeWrite;
    var _PipeTransport_eventListeners;
    var _PipeTransport_isClosed;
    var _PipeTransport_pendingMessage;
    var _PipeTransport_dispatch;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PipeTransport = void 0;
    var util_js_1 = require_util2();
    var assert_js_1 = require_assert();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        _PipeTransport_instances.add(this);
        _PipeTransport_pipeWrite.set(this, void 0);
        _PipeTransport_eventListeners.set(this, void 0);
        _PipeTransport_isClosed.set(this, false);
        _PipeTransport_pendingMessage.set(this, "");
        __classPrivateFieldSet(this, _PipeTransport_pipeWrite, pipeWrite, "f");
        __classPrivateFieldSet(this, _PipeTransport_eventListeners, [
          (0, util_js_1.addEventListener)(pipeRead, "data", (buffer) => {
            return __classPrivateFieldGet(this, _PipeTransport_instances, "m", _PipeTransport_dispatch).call(this, buffer);
          }),
          (0, util_js_1.addEventListener)(pipeRead, "close", () => {
            if (this.onclose) {
              this.onclose.call(null);
            }
          }),
          (0, util_js_1.addEventListener)(pipeRead, "error", util_js_1.debugError),
          (0, util_js_1.addEventListener)(pipeWrite, "error", util_js_1.debugError)
        ], "f");
      }
      send(message) {
        (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _PipeTransport_isClosed, "f"), "`PipeTransport` is closed.");
        __classPrivateFieldGet(this, _PipeTransport_pipeWrite, "f").write(message);
        __classPrivateFieldGet(this, _PipeTransport_pipeWrite, "f").write("\0");
      }
      close() {
        __classPrivateFieldSet(this, _PipeTransport_isClosed, true, "f");
        (0, util_js_1.removeEventListeners)(__classPrivateFieldGet(this, _PipeTransport_eventListeners, "f"));
      }
    };
    exports2.PipeTransport = PipeTransport;
    _PipeTransport_pipeWrite = /* @__PURE__ */ new WeakMap(), _PipeTransport_eventListeners = /* @__PURE__ */ new WeakMap(), _PipeTransport_isClosed = /* @__PURE__ */ new WeakMap(), _PipeTransport_pendingMessage = /* @__PURE__ */ new WeakMap(), _PipeTransport_instances = /* @__PURE__ */ new WeakSet(), _PipeTransport_dispatch = function _PipeTransport_dispatch2(buffer) {
      (0, assert_js_1.assert)(!__classPrivateFieldGet(this, _PipeTransport_isClosed, "f"), "`PipeTransport` is closed.");
      let end = buffer.indexOf("\0");
      if (end === -1) {
        __classPrivateFieldSet(this, _PipeTransport_pendingMessage, __classPrivateFieldGet(this, _PipeTransport_pendingMessage, "f") + buffer.toString(), "f");
        return;
      }
      const message = __classPrivateFieldGet(this, _PipeTransport_pendingMessage, "f") + buffer.toString(void 0, 0, end);
      if (this.onmessage) {
        this.onmessage.call(null, message);
      }
      let start = end + 1;
      end = buffer.indexOf("\0", start);
      while (end !== -1) {
        if (this.onmessage) {
          this.onmessage.call(null, buffer.toString(void 0, start, end));
        }
        start = end + 1;
        end = buffer.indexOf("\0", start);
      }
      __classPrivateFieldSet(this, _PipeTransport_pendingMessage, buffer.toString(void 0, start), "f");
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Serializer.js
var require_Serializer = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BidiSerializer = void 0;
    var util_js_1 = require_util2();
    var ElementHandle_js_1 = require_ElementHandle3();
    var JSHandle_js_1 = require_JSHandle3();
    var UnserializableError = class extends Error {
    };
    var BidiSerializer = class {
      static serializeNumber(arg) {
        let value;
        if (Object.is(arg, -0)) {
          value = "-0";
        } else if (Object.is(arg, Infinity)) {
          value = "Infinity";
        } else if (Object.is(arg, -Infinity)) {
          value = "-Infinity";
        } else if (Object.is(arg, NaN)) {
          value = "NaN";
        } else {
          value = arg;
        }
        return {
          type: "number",
          value
        };
      }
      static serializeObject(arg) {
        if (arg === null) {
          return {
            type: "null"
          };
        } else if (Array.isArray(arg)) {
          const parsedArray = arg.map((subArg) => {
            return BidiSerializer.serializeRemoveValue(subArg);
          });
          return {
            type: "array",
            value: parsedArray
          };
        } else if ((0, util_js_1.isPlainObject)(arg)) {
          try {
            JSON.stringify(arg);
          } catch (error) {
            if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
              error.message += " Recursive objects are not allowed.";
            }
            throw error;
          }
          const parsedObject = [];
          for (const key in arg) {
            parsedObject.push([
              BidiSerializer.serializeRemoveValue(key),
              BidiSerializer.serializeRemoveValue(arg[key])
            ]);
          }
          return {
            type: "object",
            value: parsedObject
          };
        } else if ((0, util_js_1.isRegExp)(arg)) {
          return {
            type: "regexp",
            value: {
              pattern: arg.source,
              flags: arg.flags
            }
          };
        } else if ((0, util_js_1.isDate)(arg)) {
          return {
            type: "date",
            value: arg.toISOString()
          };
        }
        throw new UnserializableError("Custom object sterilization not possible. Use plain objects instead.");
      }
      static serializeRemoveValue(arg) {
        switch (typeof arg) {
          case "symbol":
          case "function":
            throw new UnserializableError(`Unable to serializable ${typeof arg}`);
          case "object":
            return BidiSerializer.serializeObject(arg);
          case "undefined":
            return {
              type: "undefined"
            };
          case "number":
            return BidiSerializer.serializeNumber(arg);
          case "bigint":
            return {
              type: "bigint",
              value: arg.toString()
            };
          case "string":
            return {
              type: "string",
              value: arg
            };
          case "boolean":
            return {
              type: "boolean",
              value: arg
            };
        }
      }
      static serialize(arg, context) {
        const objectHandle = arg && (arg instanceof JSHandle_js_1.JSHandle || arg instanceof ElementHandle_js_1.ElementHandle) ? arg : null;
        if (objectHandle) {
          if (objectHandle.context() !== context) {
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          }
          if (objectHandle.disposed) {
            throw new Error("JSHandle is disposed!");
          }
          return objectHandle.remoteValue();
        }
        return BidiSerializer.serializeRemoveValue(arg);
      }
      static deserializeNumber(value) {
        switch (value) {
          case "-0":
            return -0;
          case "NaN":
            return NaN;
          case "Infinity":
          case "+Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          default:
            return value;
        }
      }
      static deserializeLocalValue(result) {
        var _a;
        switch (result.type) {
          case "array":
            return (_a = result.value) === null || _a === void 0 ? void 0 : _a.map((value) => {
              return BidiSerializer.deserializeLocalValue(value);
            });
          case "set":
            return result.value.reduce((acc, value) => {
              return acc.add(BidiSerializer.deserializeLocalValue(value));
            }, /* @__PURE__ */ new Set());
          case "object":
            if (result.value) {
              return result.value.reduce((acc, tuple) => {
                const { key, value } = BidiSerializer.deserializeTuple(tuple);
                acc[key] = value;
                return acc;
              }, {});
            }
            break;
          case "map":
            return result.value.reduce((acc, tuple) => {
              const { key, value } = BidiSerializer.deserializeTuple(tuple);
              return acc.set(key, value);
            }, /* @__PURE__ */ new Map());
          case "promise":
            return {};
          case "regexp":
            return new RegExp(result.value.pattern, result.value.flags);
          case "date":
            return new Date(result.value);
          case "undefined":
            return void 0;
          case "null":
            return null;
          case "number":
            return BidiSerializer.deserializeNumber(result.value);
          case "bigint":
            return BigInt(result.value);
          case "boolean":
            return Boolean(result.value);
          case "string":
            return result.value;
        }
        throw new UnserializableError(`Deserialization of type ${result.type} not supported.`);
      }
      static deserializeTuple([serializedKey, serializedValue]) {
        const key = typeof serializedKey === "string" ? serializedKey : BidiSerializer.deserializeLocalValue(serializedKey);
        const value = BidiSerializer.deserializeLocalValue(serializedValue);
        return { key, value };
      }
      static deserialize(result) {
        if (!result) {
          (0, util_js_1.debugError)("Service did not produce a result.");
          return void 0;
        }
        try {
          return BidiSerializer.deserializeLocalValue(result);
        } catch (error) {
          if (error instanceof UnserializableError) {
            (0, util_js_1.debugError)(error.message);
            return void 0;
          }
          throw error;
        }
      }
    };
    exports2.BidiSerializer = BidiSerializer;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/utils.js
var require_utils2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.releaseReference = exports2.debugError = void 0;
    var Debug_js_1 = require_Debug();
    exports2.debugError = (0, Debug_js_1.debug)("puppeteer:error");
    async function releaseReference(client, remoteReference) {
      if (!remoteReference.handle) {
        return;
      }
      await client.connection.send("script.disown", {
        target: { context: client._contextId },
        handles: [remoteReference.handle]
      }).catch((error) => {
        (0, exports2.debugError)(error);
      });
    }
    exports2.releaseReference = releaseReference;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/JSHandle.js
var require_JSHandle3 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/JSHandle.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _JSHandle_disposed;
    var _JSHandle_context;
    var _JSHandle_remoteValue;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSHandle = void 0;
    var JSHandle_js_1 = require_JSHandle();
    var Serializer_js_1 = require_Serializer();
    var utils_js_1 = require_utils2();
    var JSHandle = class extends JSHandle_js_1.JSHandle {
      constructor(context, remoteValue) {
        super();
        _JSHandle_disposed.set(this, false);
        _JSHandle_context.set(this, void 0);
        _JSHandle_remoteValue.set(this, void 0);
        __classPrivateFieldSet(this, _JSHandle_context, context, "f");
        __classPrivateFieldSet(this, _JSHandle_remoteValue, remoteValue, "f");
      }
      context() {
        return __classPrivateFieldGet(this, _JSHandle_context, "f");
      }
      get connection() {
        return __classPrivateFieldGet(this, _JSHandle_context, "f").connection;
      }
      get disposed() {
        return __classPrivateFieldGet(this, _JSHandle_disposed, "f");
      }
      async evaluate(pageFunction, ...args) {
        return await this.context().evaluate(pageFunction, this, ...args);
      }
      async evaluateHandle(pageFunction, ...args) {
        return await this.context().evaluateHandle(pageFunction, this, ...args);
      }
      async getProperty(propertyName) {
        return await this.evaluateHandle((object, propertyName2) => {
          return object[propertyName2];
        }, propertyName);
      }
      async getProperties() {
        const keys = await this.evaluate((object) => {
          return Object.getOwnPropertyNames(object);
        });
        const map = /* @__PURE__ */ new Map();
        const results = await Promise.all(keys.map((key) => {
          return this.getProperty(key);
        }));
        for (const [key, value] of Object.entries(keys)) {
          const handle = results[key];
          if (handle) {
            map.set(value, handle);
          }
        }
        return map;
      }
      async jsonValue() {
        const value = Serializer_js_1.BidiSerializer.deserialize(__classPrivateFieldGet(this, _JSHandle_remoteValue, "f"));
        if (__classPrivateFieldGet(this, _JSHandle_remoteValue, "f").type !== "undefined" && value === void 0) {
          throw new Error("Could not serialize referenced object");
        }
        return value;
      }
      asElement() {
        return null;
      }
      async dispose() {
        if (__classPrivateFieldGet(this, _JSHandle_disposed, "f")) {
          return;
        }
        __classPrivateFieldSet(this, _JSHandle_disposed, true, "f");
        if ("handle" in __classPrivateFieldGet(this, _JSHandle_remoteValue, "f")) {
          await (0, utils_js_1.releaseReference)(__classPrivateFieldGet(this, _JSHandle_context, "f"), __classPrivateFieldGet(this, _JSHandle_remoteValue, "f"));
        }
      }
      get isPrimitiveValue() {
        switch (__classPrivateFieldGet(this, _JSHandle_remoteValue, "f").type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean":
          case "undefined":
          case "null":
            return true;
          default:
            return false;
        }
      }
      toString() {
        if (this.isPrimitiveValue) {
          return "JSHandle:" + Serializer_js_1.BidiSerializer.deserialize(__classPrivateFieldGet(this, _JSHandle_remoteValue, "f"));
        }
        return "JSHandle@" + __classPrivateFieldGet(this, _JSHandle_remoteValue, "f").type;
      }
      get id() {
        return "handle" in __classPrivateFieldGet(this, _JSHandle_remoteValue, "f") ? __classPrivateFieldGet(this, _JSHandle_remoteValue, "f").handle : void 0;
      }
      remoteValue() {
        return __classPrivateFieldGet(this, _JSHandle_remoteValue, "f");
      }
    };
    exports2.JSHandle = JSHandle;
    _JSHandle_disposed = /* @__PURE__ */ new WeakMap(), _JSHandle_context = /* @__PURE__ */ new WeakMap(), _JSHandle_remoteValue = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/ElementHandle.js
var require_ElementHandle3 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/ElementHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementHandle = void 0;
    var ElementHandle_js_1 = require_ElementHandle();
    var JSHandle_js_1 = require_JSHandle3();
    var ElementHandle = class extends ElementHandle_js_1.ElementHandle {
      constructor(context, remoteValue) {
        super(new JSHandle_js_1.JSHandle(context, remoteValue));
      }
      context() {
        return this.handle.context();
      }
      get connection() {
        return this.handle.connection;
      }
      get isPrimitiveValue() {
        return this.handle.isPrimitiveValue;
      }
      remoteValue() {
        return this.handle.remoteValue();
      }
    };
    exports2.ElementHandle = ElementHandle;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Context.js
var require_Context = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Context.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Context_instances;
    var _Context_connection;
    var _Context_url;
    var _Context_evaluate;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBidiHandle = exports2.Context = void 0;
    var assert_js_1 = require_assert();
    var Function_js_1 = require_Function();
    var Errors_js_1 = require_Errors();
    var EventEmitter_js_1 = require_EventEmitter();
    var TimeoutSettings_js_1 = require_TimeoutSettings();
    var util_js_1 = require_util2();
    var ElementHandle_js_1 = require_ElementHandle3();
    var JSHandle_js_1 = require_JSHandle3();
    var Serializer_js_1 = require_Serializer();
    var lifeCycleToReadinessState = /* @__PURE__ */ new Map([
      ["load", "complete"],
      ["domcontentloaded", "interactive"]
    ]);
    var lifeCycleToSubscribedEvent = /* @__PURE__ */ new Map([
      ["load", "browsingContext.load"],
      ["domcontentloaded", "browsingContext.domContentLoaded"]
    ]);
    var Context = class extends EventEmitter_js_1.EventEmitter {
      constructor(connection, result) {
        super();
        _Context_instances.add(this);
        _Context_connection.set(this, void 0);
        _Context_url.set(this, void 0);
        this._timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();
        __classPrivateFieldSet(this, _Context_connection, connection, "f");
        this._contextId = result.context;
        __classPrivateFieldSet(this, _Context_url, result.url, "f");
      }
      get connection() {
        return __classPrivateFieldGet(this, _Context_connection, "f");
      }
      get id() {
        return this._contextId;
      }
      async evaluateHandle(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _Context_instances, "m", _Context_evaluate).call(this, false, pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _Context_instances, "m", _Context_evaluate).call(this, true, pageFunction, ...args);
      }
      async goto(url, options = {}) {
        const { waitUntil = "load", timeout = this._timeoutSettings.navigationTimeout() } = options;
        const readinessState = lifeCycleToReadinessState.get(getWaitUntilSingle(waitUntil));
        try {
          const response = await (0, util_js_1.waitWithTimeout)(this.connection.send("browsingContext.navigate", {
            url,
            context: this.id,
            wait: readinessState
          }), "Navigation", timeout);
          __classPrivateFieldSet(this, _Context_url, response.result.url, "f");
          return null;
        } catch (error) {
          if (error instanceof Errors_js_1.ProtocolError) {
            error.message += ` at ${url}`;
          } else if (error instanceof Errors_js_1.TimeoutError) {
            error.message = "Navigation timeout of " + timeout + " ms exceeded";
          }
          throw error;
        }
      }
      url() {
        return __classPrivateFieldGet(this, _Context_url, "f");
      }
      async setContent(html, options = {}) {
        const { waitUntil = "load", timeout = this._timeoutSettings.navigationTimeout() } = options;
        const waitUntilCommand = lifeCycleToSubscribedEvent.get(getWaitUntilSingle(waitUntil));
        await Promise.all([
          (0, util_js_1.setPageContent)(this, html),
          (0, util_js_1.waitWithTimeout)(new Promise((resolve) => {
            this.once(waitUntilCommand, () => {
              resolve();
            });
          }), waitUntilCommand, timeout)
        ]);
      }
      async sendCDPCommand(method, params = {}) {
        const session = await __classPrivateFieldGet(this, _Context_connection, "f").send("cdp.getSession", {
          context: this._contextId
        });
        const sessionId = session.result.cdpSession;
        return await __classPrivateFieldGet(this, _Context_connection, "f").send("cdp.sendCommand", {
          cdpMethod: method,
          cdpParams: params,
          cdpSession: sessionId
        });
      }
    };
    exports2.Context = Context;
    _Context_connection = /* @__PURE__ */ new WeakMap(), _Context_url = /* @__PURE__ */ new WeakMap(), _Context_instances = /* @__PURE__ */ new WeakSet(), _Context_evaluate = async function _Context_evaluate2(returnByValue, pageFunction, ...args) {
      let responsePromise;
      const resultOwnership = returnByValue ? "none" : "root";
      if ((0, util_js_1.isString)(pageFunction)) {
        responsePromise = __classPrivateFieldGet(this, _Context_connection, "f").send("script.evaluate", {
          expression: pageFunction,
          target: { context: this._contextId },
          resultOwnership,
          awaitPromise: true
        });
      } else {
        responsePromise = __classPrivateFieldGet(this, _Context_connection, "f").send("script.callFunction", {
          functionDeclaration: (0, Function_js_1.stringifyFunction)(pageFunction),
          arguments: await Promise.all(args.map((arg) => {
            return Serializer_js_1.BidiSerializer.serialize(arg, this);
          })),
          target: { context: this._contextId },
          resultOwnership,
          awaitPromise: true
        });
      }
      const { result } = await responsePromise;
      if ("type" in result && result.type === "exception") {
        throw new Error(result.exceptionDetails.text);
      }
      return returnByValue ? Serializer_js_1.BidiSerializer.deserialize(result.result) : getBidiHandle(this, result.result);
    };
    function getWaitUntilSingle(event) {
      if (Array.isArray(event) && event.length > 1) {
        throw new Error("BiDi support only single `waitUntil` argument");
      }
      const waitUntilSingle = Array.isArray(event) ? event.find((lifecycle) => {
        return lifecycle === "domcontentloaded" || lifecycle === "load";
      }) : event;
      if (waitUntilSingle === "networkidle0" || waitUntilSingle === "networkidle2") {
        throw new Error(`BiDi does not support 'waitUntil' ${waitUntilSingle}`);
      }
      (0, assert_js_1.assert)(waitUntilSingle, `Invalid waitUntil option ${waitUntilSingle}`);
      return waitUntilSingle;
    }
    function getBidiHandle(context, result) {
      if (result.type === "node" || result.type === "window") {
        return new ElementHandle_js_1.ElementHandle(context, result);
      }
      return new JSHandle_js_1.JSHandle(context, result);
    }
    exports2.getBidiHandle = getBidiHandle;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Page.js
var require_Page3 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Page.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Page_instances;
    var _Page_context;
    var _Page_subscribedEvents;
    var _Page_viewport;
    var _Page_onLogEntryAdded;
    var _Page_onLoad;
    var _Page_onDOMLoad;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Page = void 0;
    var Page_js_1 = require_Page();
    var ErrorLike_js_1 = require_ErrorLike();
    var ConsoleMessage_js_1 = require_ConsoleMessage();
    var util_js_1 = require_util2();
    var Context_js_1 = require_Context();
    var Serializer_js_1 = require_Serializer();
    var Page = class extends Page_js_1.Page {
      constructor(context) {
        super();
        _Page_instances.add(this);
        _Page_context.set(this, void 0);
        _Page_subscribedEvents.set(this, /* @__PURE__ */ new Map([
          ["log.entryAdded", __classPrivateFieldGet(this, _Page_instances, "m", _Page_onLogEntryAdded).bind(this)],
          ["browsingContext.load", __classPrivateFieldGet(this, _Page_instances, "m", _Page_onLoad).bind(this)],
          ["browsingContext.domContentLoaded", __classPrivateFieldGet(this, _Page_instances, "m", _Page_onDOMLoad).bind(this)]
        ]));
        _Page_viewport.set(this, null);
        __classPrivateFieldSet(this, _Page_context, context, "f");
        __classPrivateFieldGet(this, _Page_context, "f").connection.send("session.subscribe", {
          events: [
            ...__classPrivateFieldGet(this, _Page_subscribedEvents, "f").keys()
          ],
          contexts: [__classPrivateFieldGet(this, _Page_context, "f").id]
        }).catch((error) => {
          if ((0, ErrorLike_js_1.isErrorLike)(error) && !error.message.includes("Target closed")) {
            throw error;
          }
        });
        for (const [event, subscriber] of __classPrivateFieldGet(this, _Page_subscribedEvents, "f")) {
          __classPrivateFieldGet(this, _Page_context, "f").on(event, subscriber);
        }
      }
      async close() {
        await __classPrivateFieldGet(this, _Page_context, "f").connection.send("session.unsubscribe", {
          events: [...__classPrivateFieldGet(this, _Page_subscribedEvents, "f").keys()],
          contexts: [__classPrivateFieldGet(this, _Page_context, "f").id]
        });
        await __classPrivateFieldGet(this, _Page_context, "f").connection.send("browsingContext.close", {
          context: __classPrivateFieldGet(this, _Page_context, "f").id
        });
        for (const [event, subscriber] of __classPrivateFieldGet(this, _Page_subscribedEvents, "f")) {
          __classPrivateFieldGet(this, _Page_context, "f").off(event, subscriber);
        }
      }
      async evaluateHandle(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _Page_context, "f").evaluateHandle(pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        return __classPrivateFieldGet(this, _Page_context, "f").evaluate(pageFunction, ...args);
      }
      async goto(url, options) {
        return __classPrivateFieldGet(this, _Page_context, "f").goto(url, options);
      }
      url() {
        return __classPrivateFieldGet(this, _Page_context, "f").url();
      }
      setDefaultNavigationTimeout(timeout) {
        __classPrivateFieldGet(this, _Page_context, "f")._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        __classPrivateFieldGet(this, _Page_context, "f")._timeoutSettings.setDefaultTimeout(timeout);
      }
      async setContent(html, options = {}) {
        await __classPrivateFieldGet(this, _Page_context, "f").setContent(html, options);
      }
      async content() {
        return await this.evaluate(() => {
          let retVal = "";
          if (document.doctype) {
            retVal = new XMLSerializer().serializeToString(document.doctype);
          }
          if (document.documentElement) {
            retVal += document.documentElement.outerHTML;
          }
          return retVal;
        });
      }
      async setViewport(viewport) {
        const mobile = false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = 1;
        const screenOrientation = { angle: 0, type: "portraitPrimary" };
        await __classPrivateFieldGet(this, _Page_context, "f").sendCDPCommand("Emulation.setDeviceMetricsOverride", {
          mobile,
          width,
          height,
          deviceScaleFactor,
          screenOrientation
        });
        __classPrivateFieldSet(this, _Page_viewport, viewport, "f");
      }
      viewport() {
        return __classPrivateFieldGet(this, _Page_viewport, "f");
      }
      async pdf(options = {}) {
        const { path = void 0 } = options;
        const { printBackground: background, margin, landscape, width, height, pageRanges, scale, preferCSSPageSize, timeout } = this._getPDFOptions(options, "cm");
        const { result } = await (0, util_js_1.waitWithTimeout)(__classPrivateFieldGet(this, _Page_context, "f").connection.send("browsingContext.print", {
          context: __classPrivateFieldGet(this, _Page_context, "f")._contextId,
          background,
          margin,
          orientation: landscape ? "landscape" : "portrait",
          page: {
            width,
            height
          },
          pageRanges: pageRanges.split(", "),
          scale,
          shrinkToFit: !preferCSSPageSize
        }), "browsingContext.print", timeout);
        const buffer = Buffer.from(result.data, "base64");
        await this._maybeWriteBufferToFile(path, buffer);
        return buffer;
      }
      async createPDFStream(options) {
        const buffer = await this.pdf(options);
        try {
          const { Readable } = await Promise.resolve().then(() => __importStar(require("stream")));
          return Readable.from(buffer);
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error("Can only pass a file path in a Node-like environment.");
          }
          throw error;
        }
      }
      async screenshot(options = {}) {
        const { path = void 0, encoding, ...args } = options;
        if (Object.keys(args).length >= 1) {
          throw new Error('BiDi only supports "encoding" and "path" options');
        }
        const { result } = await __classPrivateFieldGet(this, _Page_context, "f").connection.send("browsingContext.captureScreenshot", {
          context: __classPrivateFieldGet(this, _Page_context, "f")._contextId
        });
        if (encoding === "base64") {
          return result.data;
        }
        const buffer = Buffer.from(result.data, "base64");
        await this._maybeWriteBufferToFile(path, buffer);
        return buffer;
      }
    };
    exports2.Page = Page;
    _Page_context = /* @__PURE__ */ new WeakMap(), _Page_subscribedEvents = /* @__PURE__ */ new WeakMap(), _Page_viewport = /* @__PURE__ */ new WeakMap(), _Page_instances = /* @__PURE__ */ new WeakSet(), _Page_onLogEntryAdded = function _Page_onLogEntryAdded2(event) {
      var _a;
      if (isConsoleLogEntry(event)) {
        const args = event.args.map((arg) => {
          return (0, Context_js_1.getBidiHandle)(__classPrivateFieldGet(this, _Page_context, "f"), arg);
        });
        const text = args.reduce((value, arg) => {
          const parsedValue = arg.isPrimitiveValue ? Serializer_js_1.BidiSerializer.deserialize(arg.remoteValue()) : arg.toString();
          return `${value} ${parsedValue}`;
        }, "").slice(1);
        this.emit("console", new ConsoleMessage_js_1.ConsoleMessage(event.method, text, args, getStackTraceLocations(event.stackTrace)));
      } else if (isJavaScriptLogEntry(event)) {
        let message = (_a = event.text) !== null && _a !== void 0 ? _a : "";
        if (event.stackTrace) {
          for (const callFrame of event.stackTrace.callFrames) {
            const location = callFrame.url + ":" + callFrame.lineNumber + ":" + callFrame.columnNumber;
            const functionName = callFrame.functionName || "<anonymous>";
            message += `
    at ${functionName} (${location})`;
          }
        }
        const error = new Error(message);
        error.stack = "";
        this.emit("pageerror", error);
      } else {
        (0, util_js_1.debugError)(`Unhandled LogEntry with type "${event.type}", text "${event.text}" and level "${event.level}"`);
      }
    }, _Page_onLoad = function _Page_onLoad2(_event) {
      this.emit(
        "load"
        /* PageEmittedEvents.Load */
      );
    }, _Page_onDOMLoad = function _Page_onDOMLoad2(_event) {
      this.emit(
        "domcontentloaded"
        /* PageEmittedEvents.DOMContentLoaded */
      );
    };
    function isConsoleLogEntry(event) {
      return event.type === "console";
    }
    function isJavaScriptLogEntry(event) {
      return event.type === "javascript";
    }
    function getStackTraceLocations(stackTrace) {
      const stackTraceLocations = [];
      if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
          stackTraceLocations.push({
            url: callFrame.url,
            lineNumber: callFrame.lineNumber,
            columnNumber: callFrame.columnNumber
          });
        }
      }
      return stackTraceLocations;
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/BrowserContext.js
var require_BrowserContext2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/BrowserContext.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _BrowserContext_connection;
    var _BrowserContext_defaultViewport;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowserContext = void 0;
    var BrowserContext_js_1 = require_BrowserContext();
    var Page_js_1 = require_Page3();
    var BrowserContext = class extends BrowserContext_js_1.BrowserContext {
      constructor(connection, options) {
        super();
        _BrowserContext_connection.set(this, void 0);
        _BrowserContext_defaultViewport.set(this, void 0);
        __classPrivateFieldSet(this, _BrowserContext_connection, connection, "f");
        __classPrivateFieldSet(this, _BrowserContext_defaultViewport, options.defaultViewport, "f");
      }
      async newPage() {
        const { result } = await __classPrivateFieldGet(this, _BrowserContext_connection, "f").send("browsingContext.create", {
          type: "tab"
        });
        const context = __classPrivateFieldGet(this, _BrowserContext_connection, "f").context(result.context);
        const page = new Page_js_1.Page(context);
        if (__classPrivateFieldGet(this, _BrowserContext_defaultViewport, "f")) {
          try {
            await page.setViewport(__classPrivateFieldGet(this, _BrowserContext_defaultViewport, "f"));
          } catch {
          }
        }
        return page;
      }
      async close() {
      }
    };
    exports2.BrowserContext = BrowserContext;
    _BrowserContext_connection = /* @__PURE__ */ new WeakMap(), _BrowserContext_defaultViewport = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Browser.js
var require_Browser3 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Browser.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Browser_process;
    var _Browser_closeCallback;
    var _Browser_connection;
    var _Browser_defaultViewport;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Browser = void 0;
    var Browser_js_1 = require_Browser();
    var BrowserContext_js_1 = require_BrowserContext2();
    var Browser = class extends Browser_js_1.Browser {
      static async create(opts) {
        try {
          await opts.connection.send("session.new", {});
        } catch {
        }
        await opts.connection.send("session.subscribe", {
          events: [
            "browsingContext.contextCreated"
          ]
        });
        return new Browser(opts);
      }
      constructor(opts) {
        super();
        _Browser_process.set(this, void 0);
        _Browser_closeCallback.set(this, void 0);
        _Browser_connection.set(this, void 0);
        _Browser_defaultViewport.set(this, void 0);
        __classPrivateFieldSet(this, _Browser_process, opts.process, "f");
        __classPrivateFieldSet(this, _Browser_closeCallback, opts.closeCallback, "f");
        __classPrivateFieldSet(this, _Browser_connection, opts.connection, "f");
        __classPrivateFieldSet(this, _Browser_defaultViewport, opts.defaultViewport, "f");
      }
      async close() {
        var _a;
        __classPrivateFieldGet(this, _Browser_connection, "f").dispose();
        await ((_a = __classPrivateFieldGet(this, _Browser_closeCallback, "f")) === null || _a === void 0 ? void 0 : _a.call(null));
      }
      isConnected() {
        return !__classPrivateFieldGet(this, _Browser_connection, "f").closed;
      }
      process() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _Browser_process, "f")) !== null && _a !== void 0 ? _a : null;
      }
      async createIncognitoBrowserContext(_options) {
        return new BrowserContext_js_1.BrowserContext(__classPrivateFieldGet(this, _Browser_connection, "f"), {
          defaultViewport: __classPrivateFieldGet(this, _Browser_defaultViewport, "f")
        });
      }
    };
    exports2.Browser = Browser;
    _Browser_process = /* @__PURE__ */ new WeakMap(), _Browser_closeCallback = /* @__PURE__ */ new WeakMap(), _Browser_connection = /* @__PURE__ */ new WeakMap(), _Browser_defaultViewport = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Connection.js
var require_Connection2 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/Connection.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Connection_instances;
    var _Connection_transport;
    var _Connection_delay;
    var _Connection_timeout;
    var _Connection_closed;
    var _Connection_callbacks;
    var _Connection_contexts;
    var _Connection_maybeEmitOnContext;
    var _Connection_handleSpecialEvents;
    var _Connection_onClose;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Connection = void 0;
    var Connection_js_1 = require_Connection();
    var Debug_js_1 = require_Debug();
    var EventEmitter_js_1 = require_EventEmitter();
    var Context_js_1 = require_Context();
    var debugProtocolSend = (0, Debug_js_1.debug)("puppeteer:webDriverBiDi:SEND \u25BA");
    var debugProtocolReceive = (0, Debug_js_1.debug)("puppeteer:webDriverBiDi:RECV \u25C0");
    var Connection = class extends EventEmitter_js_1.EventEmitter {
      constructor(transport, delay = 0, timeout) {
        super();
        _Connection_instances.add(this);
        _Connection_transport.set(this, void 0);
        _Connection_delay.set(this, void 0);
        _Connection_timeout.set(this, 0);
        _Connection_closed.set(this, false);
        _Connection_callbacks.set(this, new Connection_js_1.CallbackRegistry());
        _Connection_contexts.set(this, /* @__PURE__ */ new Map());
        __classPrivateFieldSet(this, _Connection_delay, delay, "f");
        __classPrivateFieldSet(this, _Connection_timeout, timeout !== null && timeout !== void 0 ? timeout : 18e4, "f");
        __classPrivateFieldSet(this, _Connection_transport, transport, "f");
        __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = this.onMessage.bind(this);
        __classPrivateFieldGet(this, _Connection_transport, "f").onclose = __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).bind(this);
      }
      get closed() {
        return __classPrivateFieldGet(this, _Connection_closed, "f");
      }
      context(contextId) {
        return __classPrivateFieldGet(this, _Connection_contexts, "f").get(contextId) || null;
      }
      send(method, params) {
        return __classPrivateFieldGet(this, _Connection_callbacks, "f").create(method, __classPrivateFieldGet(this, _Connection_timeout, "f"), (id) => {
          const stringifiedMessage = JSON.stringify({
            id,
            method,
            params
          });
          debugProtocolSend(stringifiedMessage);
          __classPrivateFieldGet(this, _Connection_transport, "f").send(stringifiedMessage);
        });
      }
      /**
       * @internal
       */
      async onMessage(message) {
        if (__classPrivateFieldGet(this, _Connection_delay, "f")) {
          await new Promise((f) => {
            return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, "f"));
          });
        }
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if ("id" in object) {
          if ("error" in object) {
            __classPrivateFieldGet(this, _Connection_callbacks, "f").reject(object.id, createProtocolError(object), object.message);
          } else {
            __classPrivateFieldGet(this, _Connection_callbacks, "f").resolve(object.id, object);
          }
        } else {
          __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_handleSpecialEvents).call(this, object);
          __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_maybeEmitOnContext).call(this, object);
          this.emit(object.method, object.params);
        }
      }
      dispose() {
        __classPrivateFieldGet(this, _Connection_instances, "m", _Connection_onClose).call(this);
        __classPrivateFieldGet(this, _Connection_transport, "f").close();
      }
    };
    exports2.Connection = Connection;
    _Connection_transport = /* @__PURE__ */ new WeakMap(), _Connection_delay = /* @__PURE__ */ new WeakMap(), _Connection_timeout = /* @__PURE__ */ new WeakMap(), _Connection_closed = /* @__PURE__ */ new WeakMap(), _Connection_callbacks = /* @__PURE__ */ new WeakMap(), _Connection_contexts = /* @__PURE__ */ new WeakMap(), _Connection_instances = /* @__PURE__ */ new WeakSet(), _Connection_maybeEmitOnContext = function _Connection_maybeEmitOnContext2(event) {
      let context;
      if ("context" in event.params && event.params.context) {
        context = __classPrivateFieldGet(this, _Connection_contexts, "f").get(event.params.context);
      } else if ("source" in event.params && event.params.source.context) {
        context = __classPrivateFieldGet(this, _Connection_contexts, "f").get(event.params.source.context);
      }
      context === null || context === void 0 ? void 0 : context.emit(event.method, event.params);
    }, _Connection_handleSpecialEvents = function _Connection_handleSpecialEvents2(event) {
      switch (event.method) {
        case "browsingContext.contextCreated":
          __classPrivateFieldGet(this, _Connection_contexts, "f").set(event.params.context, new Context_js_1.Context(this, event.params));
      }
    }, _Connection_onClose = function _Connection_onClose2() {
      if (__classPrivateFieldGet(this, _Connection_closed, "f")) {
        return;
      }
      __classPrivateFieldSet(this, _Connection_closed, true, "f");
      __classPrivateFieldGet(this, _Connection_transport, "f").onmessage = void 0;
      __classPrivateFieldGet(this, _Connection_transport, "f").onclose = void 0;
      __classPrivateFieldGet(this, _Connection_callbacks, "f").clear();
    };
    function createProtocolError(object) {
      let message = `${object.error} ${object.message}`;
      if (object.stacktrace) {
        message += ` ${object.stacktrace}`;
      }
      return message;
    }
  }
});

// node_modules/mitt/dist/mitt.js
var require_mitt2 = __commonJS({
  "node_modules/mitt/dist/mitt.js"(exports2, module2) {
    module2.exports = function(n) {
      return { all: n = n || /* @__PURE__ */ new Map(), on: function(e, t) {
        var i = n.get(e);
        i ? i.push(t) : n.set(e, [t]);
      }, off: function(e, t) {
        var i = n.get(e);
        i && (t ? i.splice(i.indexOf(t) >>> 0, 1) : n.set(e, []));
      }, emit: function(e, t) {
        var i = n.get(e);
        i && i.slice().map(function(n2) {
          n2(t);
        }), (i = n.get("*")) && i.slice().map(function(n2) {
          n2(e, t);
        });
      } };
    };
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js
var require_EventEmitter2 = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventEmitter = void 0;
    var mitt_1 = __importDefault(require_mitt2());
    var EventEmitter = class {
      #emitter = (0, mitt_1.default)();
      on(type, handler) {
        this.#emitter.on(type, handler);
        return this;
      }
      /**
       * Like `on` but the listener will only be fired once and then it will be removed.
       * @param event The event you'd like to listen to
       * @param handler The handler function to run when the event occurs
       * @return `this` to enable chaining method calls.
       */
      once(event, handler) {
        const onceHandler = (eventData) => {
          handler(eventData);
          this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
      }
      off(type, handler) {
        this.#emitter.off(type, handler);
        return this;
      }
      /**
       * Emits an event and call any associated listeners.
       *
       * @param event The event to emit.
       * @param eventData Any data to emit with the event.
       * @return `true` if there are any listeners, `false` otherwise.
       */
      emit(event, eventData) {
        this.#emitter.emit(event, eventData);
      }
    };
    exports2.EventEmitter = EventEmitter;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/log.js
var require_log = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogType = void 0;
    var LogType;
    (function(LogType2) {
      LogType2["bidi"] = "BiDi Messages";
      LogType2["browsingContexts"] = "Browsing Contexts";
      LogType2["cdp"] = "CDP";
      LogType2["system"] = "System";
    })(LogType = exports2.LogType || (exports2.LogType = {}));
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/processingQueue.js
var require_processingQueue = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/processingQueue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProcessingQueue = void 0;
    var log_js_1 = require_log();
    var ProcessingQueue = class {
      #catch;
      #logger;
      #processor;
      #queue = [];
      // Flag to keep only 1 active processor.
      #isProcessing = false;
      constructor(processor, _catch = () => Promise.resolve(), logger) {
        this.#catch = _catch;
        this.#processor = processor;
        this.#logger = logger;
      }
      add(entry) {
        this.#queue.push(entry);
        void this.#processIfNeeded();
      }
      async #processIfNeeded() {
        if (this.#isProcessing) {
          return;
        }
        this.#isProcessing = true;
        while (this.#queue.length > 0) {
          const entryPromise = this.#queue.shift();
          if (entryPromise !== void 0) {
            await entryPromise.then((entry) => this.#processor(entry)).catch((e) => {
              this.#logger?.(log_js_1.LogType.system, "Event was not processed:", e);
              this.#catch(e);
            });
          }
        }
        this.#isProcessing = false;
      }
    };
    exports2.ProcessingQueue = ProcessingQueue;
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/protocol.js
var require_protocol = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CDP = exports2.Network = exports2.Log = exports2.BrowsingContext = exports2.Script = exports2.Message = void 0;
    var Message;
    (function(Message2) {
      let ErrorCode;
      (function(ErrorCode2) {
        ErrorCode2["InvalidArgument"] = "invalid argument";
        ErrorCode2["InvalidSessionId"] = "invalid session id";
        ErrorCode2["NoSuchAlert"] = "no such alert";
        ErrorCode2["NoSuchFrame"] = "no such frame";
        ErrorCode2["NoSuchHandle"] = "no such handle";
        ErrorCode2["NoSuchNode"] = "no such node";
        ErrorCode2["NoSuchScript"] = "no such script";
        ErrorCode2["SessionNotCreated"] = "session not created";
        ErrorCode2["UnknownCommand"] = "unknown command";
        ErrorCode2["UnknownError"] = "unknown error";
        ErrorCode2["UnsupportedOperation"] = "unsupported operation";
      })(ErrorCode = Message2.ErrorCode || (Message2.ErrorCode = {}));
      class ErrorResponse {
        error;
        message;
        stacktrace;
        constructor(error, message, stacktrace) {
          this.error = error;
          this.message = message;
          this.stacktrace = stacktrace;
        }
        toErrorResponse(commandId) {
          return {
            id: commandId,
            error: this.error,
            message: this.message,
            stacktrace: this.stacktrace
          };
        }
      }
      Message2.ErrorResponse = ErrorResponse;
      class InvalidArgumentException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.InvalidArgument, message, stacktrace);
        }
      }
      Message2.InvalidArgumentException = InvalidArgumentException;
      class NoSuchHandleException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.NoSuchHandle, message, stacktrace);
        }
      }
      Message2.NoSuchHandleException = NoSuchHandleException;
      class InvalidSessionIdException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.InvalidSessionId, message, stacktrace);
        }
      }
      Message2.InvalidSessionIdException = InvalidSessionIdException;
      class NoSuchAlertException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.NoSuchAlert, message, stacktrace);
        }
      }
      Message2.NoSuchAlertException = NoSuchAlertException;
      class NoSuchFrameException extends ErrorResponse {
        constructor(message) {
          super(ErrorCode.NoSuchFrame, message);
        }
      }
      Message2.NoSuchFrameException = NoSuchFrameException;
      class NoSuchNodeException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.NoSuchNode, message, stacktrace);
        }
      }
      Message2.NoSuchNodeException = NoSuchNodeException;
      class NoSuchScriptException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.NoSuchScript, message, stacktrace);
        }
      }
      Message2.NoSuchScriptException = NoSuchScriptException;
      class SessionNotCreatedException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.SessionNotCreated, message, stacktrace);
        }
      }
      Message2.SessionNotCreatedException = SessionNotCreatedException;
      class UnknownCommandException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.UnknownCommand, message, stacktrace);
        }
      }
      Message2.UnknownCommandException = UnknownCommandException;
      class UnknownErrorException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.UnknownError, message, stacktrace);
        }
      }
      Message2.UnknownErrorException = UnknownErrorException;
      class UnsupportedOperationException extends ErrorResponse {
        constructor(message, stacktrace) {
          super(ErrorCode.UnsupportedOperation, message, stacktrace);
        }
      }
      Message2.UnsupportedOperationException = UnsupportedOperationException;
    })(Message = exports2.Message || (exports2.Message = {}));
    var Script;
    (function(Script2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["MessageEvent"] = "script.message";
      })(EventNames = Script2.EventNames || (Script2.EventNames = {}));
      Script2.AllEvents = "script";
    })(Script = exports2.Script || (exports2.Script = {}));
    var BrowsingContext;
    (function(BrowsingContext2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["LoadEvent"] = "browsingContext.load";
        EventNames2["DomContentLoadedEvent"] = "browsingContext.domContentLoaded";
        EventNames2["ContextCreatedEvent"] = "browsingContext.contextCreated";
        EventNames2["ContextDestroyedEvent"] = "browsingContext.contextDestroyed";
      })(EventNames = BrowsingContext2.EventNames || (BrowsingContext2.EventNames = {}));
      BrowsingContext2.AllEvents = "browsingContext";
    })(BrowsingContext = exports2.BrowsingContext || (exports2.BrowsingContext = {}));
    var Log;
    (function(Log2) {
      Log2.AllEvents = "log";
      let EventNames;
      (function(EventNames2) {
        EventNames2["LogEntryAddedEvent"] = "log.entryAdded";
      })(EventNames = Log2.EventNames || (Log2.EventNames = {}));
    })(Log = exports2.Log || (exports2.Log = {}));
    var Network;
    (function(Network2) {
      Network2.AllEvents = "network";
      let EventNames;
      (function(EventNames2) {
        EventNames2["BeforeRequestSentEvent"] = "network.beforeRequestSent";
        EventNames2["ResponseCompletedEvent"] = "network.responseCompleted";
        EventNames2["FetchErrorEvent"] = "network.fetchError";
      })(EventNames = Network2.EventNames || (Network2.EventNames = {}));
    })(Network = exports2.Network || (exports2.Network = {}));
    var CDP;
    (function(CDP2) {
      CDP2.AllEvents = "cdp";
      let EventNames;
      (function(EventNames2) {
        EventNames2["EventReceivedEvent"] = "cdp.eventReceived";
      })(EventNames = CDP2.EventNames || (CDP2.EventNames = {}));
    })(CDP = exports2.CDP || (exports2.CDP = {}));
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js
var require_unitConversions = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inchesFromCm = void 0;
    function inchesFromCm(cm) {
      return cm / 2.54;
    }
    exports2.inchesFromCm = inchesFromCm;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/deferred.js
var require_deferred = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/deferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      #isFinished = false;
      #promise;
      #resolve = () => {
      };
      #reject = () => {
      };
      get isFinished() {
        return this.#isFinished;
      }
      constructor() {
        this.#promise = new Promise((resolve, reject) => {
          this.#resolve = resolve;
          this.#reject = reject;
        });
        this.#promise.catch(() => {
        });
      }
      then(onFulfilled, onRejected) {
        return this.#promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.#promise.catch(onRejected);
      }
      resolve(value) {
        this.#isFinished = true;
        this.#resolve(value);
      }
      reject(reason) {
        this.#isFinished = true;
        this.#reject(reason);
      }
      finally(onFinally) {
        return this.#promise.finally(onFinally);
      }
      [Symbol.toStringTag] = "Promise";
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/scriptEvaluator.js
var require_scriptEvaluator = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/scriptEvaluator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ScriptEvaluator = exports2.SHARED_ID_DIVIDER = void 0;
    var protocol_js_1 = require_protocol();
    var CALL_FUNCTION_STACKTRACE_LINE_OFFSET = 1;
    var EVALUATE_STACKTRACE_LINE_OFFSET = 0;
    exports2.SHARED_ID_DIVIDER = "_element_";
    var _eventManager, _cdpRemoteObjectToCallArgument, cdpRemoteObjectToCallArgument_fn, _deserializeToCdpArg, deserializeToCdpArg_fn, _flattenKeyValuePairs, flattenKeyValuePairs_fn, _flattenValueList, flattenValueList_fn, _initChannelListener, initChannelListener_fn, _serializeCdpExceptionDetails, serializeCdpExceptionDetails_fn;
    var _ScriptEvaluator = class {
      constructor(eventManager) {
        __privateAdd(this, _deserializeToCdpArg);
        __privateAdd(this, _flattenKeyValuePairs);
        __privateAdd(this, _flattenValueList);
        __privateAdd(this, _initChannelListener);
        __privateAdd(this, _serializeCdpExceptionDetails);
        __privateAdd(this, _eventManager, void 0);
        __privateSet(this, _eventManager, eventManager);
      }
      /**
       * Gets the string representation of an object. This is equivalent to
       * calling toString() on the object value.
       * @param cdpObject CDP remote object representing an object.
       * @param realm
       * @return string The stringified object.
       */
      static async stringifyObject(cdpObject, realm) {
        const stringifyResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String((obj) => {
            return String(obj);
          }),
          awaitPromise: false,
          arguments: [cdpObject],
          returnByValue: true,
          executionContextId: realm.executionContextId
        });
        return stringifyResult.result.value;
      }
      /**
       * Serializes a given CDP object into BiDi, keeping references in the
       * target's `globalThis`.
       * @param cdpRemoteObject CDP remote object to be serialized.
       * @param resultOwnership Indicates desired ResultOwnership.
       * @param realm
       */
      async serializeCdpObject(cdpRemoteObject, resultOwnership, realm) {
        var _a;
        const arg = __privateMethod(_a = _ScriptEvaluator, _cdpRemoteObjectToCallArgument, cdpRemoteObjectToCallArgument_fn).call(_a, cdpRemoteObject);
        const cdpWebDriverValue = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String((obj) => obj),
          awaitPromise: false,
          arguments: [arg],
          generateWebDriverValue: true,
          executionContextId: realm.executionContextId
        });
        return realm.cdpToBidiValue(cdpWebDriverValue, resultOwnership);
      }
      async scriptEvaluate(realm, expression, awaitPromise, resultOwnership) {
        const cdpEvaluateResult = await realm.cdpClient.sendCommand("Runtime.evaluate", {
          contextId: realm.executionContextId,
          expression,
          awaitPromise,
          generateWebDriverValue: true
        });
        if (cdpEvaluateResult.exceptionDetails) {
          return {
            exceptionDetails: await __privateMethod(this, _serializeCdpExceptionDetails, serializeCdpExceptionDetails_fn).call(this, cdpEvaluateResult.exceptionDetails, EVALUATE_STACKTRACE_LINE_OFFSET, resultOwnership, realm),
            type: "exception",
            realm: realm.realmId
          };
        }
        return {
          type: "success",
          result: realm.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
          realm: realm.realmId
        };
      }
      async callFunction(realm, functionDeclaration, _this, _arguments, awaitPromise, resultOwnership) {
        const callFunctionAndSerializeScript = `(...args)=>{ return _callFunction((
${functionDeclaration}
), args);
      function _callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }}`;
        const thisAndArgumentsList = [
          await __privateMethod(this, _deserializeToCdpArg, deserializeToCdpArg_fn).call(this, _this, realm)
        ];
        thisAndArgumentsList.push(...await Promise.all(_arguments.map(async (a) => {
          return __privateMethod(this, _deserializeToCdpArg, deserializeToCdpArg_fn).call(this, a, realm);
        })));
        let cdpCallFunctionResult;
        try {
          cdpCallFunctionResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: callFunctionAndSerializeScript,
            awaitPromise,
            arguments: thisAndArgumentsList,
            generateWebDriverValue: true,
            executionContextId: realm.executionContextId
          });
        } catch (e) {
          if (e.code === -32e3 && [
            "Could not find object with given id",
            "Argument should belong to the same JavaScript world as target object",
            "Invalid remote object id"
          ].includes(e.message)) {
            throw new protocol_js_1.Message.NoSuchHandleException("Handle was not found.");
          }
          throw e;
        }
        if (cdpCallFunctionResult.exceptionDetails) {
          return {
            exceptionDetails: await __privateMethod(this, _serializeCdpExceptionDetails, serializeCdpExceptionDetails_fn).call(this, cdpCallFunctionResult.exceptionDetails, CALL_FUNCTION_STACKTRACE_LINE_OFFSET, resultOwnership, realm),
            type: "exception",
            realm: realm.realmId
          };
        }
        return {
          type: "success",
          result: realm.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
          realm: realm.realmId
        };
      }
    };
    var ScriptEvaluator = _ScriptEvaluator;
    _eventManager = new WeakMap();
    _cdpRemoteObjectToCallArgument = new WeakSet();
    cdpRemoteObjectToCallArgument_fn = function(cdpRemoteObject) {
      if (cdpRemoteObject.objectId !== void 0) {
        return { objectId: cdpRemoteObject.objectId };
      }
      if (cdpRemoteObject.unserializableValue !== void 0) {
        return { unserializableValue: cdpRemoteObject.unserializableValue };
      }
      return { value: cdpRemoteObject.value };
    };
    _deserializeToCdpArg = new WeakSet();
    deserializeToCdpArg_fn = async function(argumentValue, realm) {
      if ("sharedId" in argumentValue) {
        const [navigableId, rawBackendNodeId] = argumentValue.sharedId.split(exports2.SHARED_ID_DIVIDER);
        const backendNodeId = parseInt(rawBackendNodeId ?? "");
        if (isNaN(backendNodeId) || backendNodeId === void 0 || navigableId === void 0) {
          throw new protocol_js_1.Message.InvalidArgumentException(`SharedId "${argumentValue.sharedId}" should have format "{navigableId}${exports2.SHARED_ID_DIVIDER}{backendNodeId}".`);
        }
        if (realm.navigableId !== navigableId) {
          throw new protocol_js_1.Message.NoSuchNodeException(`SharedId "${argumentValue.sharedId}" belongs to different document. Current document is ${realm.navigableId}.`);
        }
        try {
          const obj = await realm.cdpClient.sendCommand("DOM.resolveNode", {
            backendNodeId,
            executionContextId: realm.executionContextId
          });
          return { objectId: obj.object.objectId };
        } catch (e) {
          if (e.code === -32e3 && e.message === "No node with given id found") {
            throw new protocol_js_1.Message.NoSuchNodeException(`SharedId "${argumentValue.sharedId}" was not found.`);
          }
          throw e;
        }
      }
      if ("handle" in argumentValue) {
        return { objectId: argumentValue.handle };
      }
      switch (argumentValue.type) {
        case "undefined":
          return { unserializableValue: "undefined" };
        case "null":
          return { unserializableValue: "null" };
        case "string":
          return { value: argumentValue.value };
        case "number":
          if (argumentValue.value === "NaN") {
            return { unserializableValue: "NaN" };
          } else if (argumentValue.value === "-0") {
            return { unserializableValue: "-0" };
          } else if (argumentValue.value === "Infinity") {
            return { unserializableValue: "Infinity" };
          } else if (argumentValue.value === "-Infinity") {
            return { unserializableValue: "-Infinity" };
          }
          return {
            value: argumentValue.value
          };
        case "boolean":
          return { value: Boolean(argumentValue.value) };
        case "bigint":
          return {
            unserializableValue: `BigInt(${JSON.stringify(argumentValue.value)})`
          };
        case "date":
          return {
            unserializableValue: `new Date(Date.parse(${JSON.stringify(argumentValue.value)}))`
          };
        case "regexp":
          return {
            unserializableValue: `new RegExp(${JSON.stringify(argumentValue.value.pattern)}, ${JSON.stringify(argumentValue.value.flags)})`
          };
        case "map": {
          const keyValueArray = await __privateMethod(this, _flattenKeyValuePairs, flattenKeyValuePairs_fn).call(this, argumentValue.value, realm);
          const argEvalResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((...args) => {
              const result = /* @__PURE__ */ new Map();
              for (let i = 0; i < args.length; i += 2) {
                result.set(args[i], args[i + 1]);
              }
              return result;
            }),
            awaitPromise: false,
            arguments: keyValueArray,
            returnByValue: false,
            executionContextId: realm.executionContextId
          });
          return { objectId: argEvalResult.result.objectId };
        }
        case "object": {
          const keyValueArray = await __privateMethod(this, _flattenKeyValuePairs, flattenKeyValuePairs_fn).call(this, argumentValue.value, realm);
          const argEvalResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((...args) => {
              const result = {};
              for (let i = 0; i < args.length; i += 2) {
                const key = args[i];
                result[key] = args[i + 1];
              }
              return result;
            }),
            awaitPromise: false,
            arguments: keyValueArray,
            returnByValue: false,
            executionContextId: realm.executionContextId
          });
          return { objectId: argEvalResult.result.objectId };
        }
        case "array": {
          const args = await __privateMethod(this, _flattenValueList, flattenValueList_fn).call(this, argumentValue.value, realm);
          const argEvalResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((...args2) => {
              return args2;
            }),
            awaitPromise: false,
            arguments: args,
            returnByValue: false,
            executionContextId: realm.executionContextId
          });
          return { objectId: argEvalResult.result.objectId };
        }
        case "set": {
          const args = await __privateMethod(this, _flattenValueList, flattenValueList_fn).call(this, argumentValue.value, realm);
          const argEvalResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((...args2) => {
              return new Set(args2);
            }),
            awaitPromise: false,
            arguments: args,
            returnByValue: false,
            executionContextId: realm.executionContextId
          });
          return { objectId: argEvalResult.result.objectId };
        }
        case "channel": {
          const createChannelHandleResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String(() => {
              const queue = [];
              let queueNonEmptyResolver = null;
              return {
                /**
                 * Gets a promise, which is resolved as soon as a message occurs
                 * in the queue.
                 */
                async getMessage() {
                  const onMessage = queue.length > 0 ? Promise.resolve() : new Promise((resolve) => {
                    queueNonEmptyResolver = resolve;
                  });
                  await onMessage;
                  return queue.shift();
                },
                /**
                 * Adds a message to the queue.
                 * Resolves the pending promise if needed.
                 */
                sendMessage(message) {
                  queue.push(message);
                  if (queueNonEmptyResolver !== null) {
                    queueNonEmptyResolver();
                    queueNonEmptyResolver = null;
                  }
                }
              };
            }),
            returnByValue: false,
            executionContextId: realm.executionContextId,
            generateWebDriverValue: false
          });
          const channelHandle = createChannelHandleResult.result.objectId;
          void __privateMethod(this, _initChannelListener, initChannelListener_fn).call(this, argumentValue, channelHandle, realm);
          const sendMessageArgResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((channelHandle2) => {
              return channelHandle2.sendMessage;
            }),
            arguments: [
              {
                objectId: channelHandle
              }
            ],
            returnByValue: false,
            executionContextId: realm.executionContextId,
            generateWebDriverValue: false
          });
          return { objectId: sendMessageArgResult.result.objectId };
        }
        default:
          throw new Error(`Value ${JSON.stringify(argumentValue)} is not deserializable.`);
      }
    };
    _flattenKeyValuePairs = new WeakSet();
    flattenKeyValuePairs_fn = async function(mapping, realm) {
      const keyValueArray = [];
      for (const [key, value] of mapping) {
        let keyArg;
        if (typeof key === "string") {
          keyArg = { value: key };
        } else {
          keyArg = await __privateMethod(this, _deserializeToCdpArg, deserializeToCdpArg_fn).call(this, key, realm);
        }
        const valueArg = await __privateMethod(this, _deserializeToCdpArg, deserializeToCdpArg_fn).call(this, value, realm);
        keyValueArray.push(keyArg);
        keyValueArray.push(valueArg);
      }
      return keyValueArray;
    };
    _flattenValueList = new WeakSet();
    flattenValueList_fn = async function(list, realm) {
      return Promise.all(list.map((value) => __privateMethod(this, _deserializeToCdpArg, deserializeToCdpArg_fn).call(this, value, realm)));
    };
    _initChannelListener = new WeakSet();
    initChannelListener_fn = async function(channel, channelHandle, realm) {
      const channelId = channel.value.channel;
      for (; ; ) {
        const message = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String(async (channelHandle2) => channelHandle2.getMessage()),
          arguments: [
            {
              objectId: channelHandle
            }
          ],
          awaitPromise: true,
          executionContextId: realm.executionContextId,
          generateWebDriverValue: true
        });
        __privateGet(this, _eventManager).registerEvent({
          method: protocol_js_1.Script.EventNames.MessageEvent,
          params: {
            channel: channelId,
            data: realm.cdpToBidiValue(message, channel.value.ownership ?? "none"),
            source: {
              realm: realm.realmId,
              context: realm.browsingContextId
            }
          }
        }, realm.browsingContextId);
      }
    };
    _serializeCdpExceptionDetails = new WeakSet();
    serializeCdpExceptionDetails_fn = async function(cdpExceptionDetails, lineOffset, resultOwnership, realm) {
      const callFrames = cdpExceptionDetails.stackTrace?.callFrames.map((frame) => ({
        url: frame.url,
        functionName: frame.functionName,
        // As `script.evaluate` wraps call into serialization script, so
        // `lineNumber` should be adjusted.
        lineNumber: frame.lineNumber - lineOffset,
        columnNumber: frame.columnNumber
      }));
      const exception = await this.serializeCdpObject(
        // Exception should always be there.
        cdpExceptionDetails.exception,
        resultOwnership,
        realm
      );
      const text = await _ScriptEvaluator.stringifyObject(cdpExceptionDetails.exception, realm);
      return {
        exception,
        columnNumber: cdpExceptionDetails.columnNumber,
        // As `script.evaluate` wraps call into serialization script, so
        // `lineNumber` should be adjusted.
        lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
        stackTrace: {
          callFrames: callFrames || []
        },
        text: text || cdpExceptionDetails.text
      };
    };
    __privateAdd(ScriptEvaluator, _cdpRemoteObjectToCallArgument);
    exports2.ScriptEvaluator = ScriptEvaluator;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/realm.js
var require_realm = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/realm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Realm = void 0;
    var scriptEvaluator_js_1 = require_scriptEvaluator();
    var Realm = class {
      #realmStorage;
      #browsingContextStorage;
      #realmId;
      #browsingContextId;
      #executionContextId;
      #origin;
      #type;
      #cdpClient;
      #eventManager;
      #scriptEvaluator;
      sandbox;
      cdpSessionId;
      constructor(realmStorage, browsingContextStorage, realmId, browsingContextId, executionContextId, origin, type, sandbox, cdpSessionId, cdpClient, eventManager) {
        this.#realmId = realmId;
        this.#browsingContextId = browsingContextId;
        this.#executionContextId = executionContextId;
        this.sandbox = sandbox;
        this.#origin = origin;
        this.#type = type;
        this.cdpSessionId = cdpSessionId;
        this.#cdpClient = cdpClient;
        this.#realmStorage = realmStorage;
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        this.#scriptEvaluator = new scriptEvaluator_js_1.ScriptEvaluator(this.#eventManager);
        this.#realmStorage.realmMap.set(this.#realmId, this);
      }
      async disown(handle) {
        if (this.#realmStorage.knownHandlesToRealm.get(handle) !== this.realmId) {
          return;
        }
        try {
          await this.cdpClient.sendCommand("Runtime.releaseObject", {
            objectId: handle
          });
        } catch (e) {
          if (!(e.code === -32e3 && e.message === "Invalid remote object id")) {
            throw e;
          }
        }
        this.#realmStorage.knownHandlesToRealm.delete(handle);
      }
      cdpToBidiValue(cdpValue, resultOwnership) {
        const cdpWebDriverValue = cdpValue.result.webDriverValue;
        const bidiValue = this.webDriverValueToBiDi(cdpWebDriverValue);
        if (cdpValue.result.objectId) {
          const objectId = cdpValue.result.objectId;
          if (resultOwnership === "root") {
            bidiValue.handle = objectId;
            this.#realmStorage.knownHandlesToRealm.set(objectId, this.realmId);
          } else {
            void this.cdpClient.sendCommand("Runtime.releaseObject", { objectId });
          }
        }
        return bidiValue;
      }
      webDriverValueToBiDi(webDriverValue) {
        const result = webDriverValue;
        if (result.type === "platformobject") {
          return { type: "object" };
        }
        const bidiValue = result.value;
        if (bidiValue === void 0) {
          return result;
        }
        if (result.type === "node") {
          if (Object.hasOwn(bidiValue, "backendNodeId")) {
            bidiValue.sharedId = `${this.navigableId}${scriptEvaluator_js_1.SHARED_ID_DIVIDER}${bidiValue.backendNodeId}`;
            delete bidiValue["backendNodeId"];
          }
          if (Object.hasOwn(bidiValue, "children")) {
            for (const i in bidiValue.children) {
              bidiValue.children[i] = this.webDriverValueToBiDi(bidiValue.children[i]);
            }
          }
        }
        if (["array", "set"].includes(webDriverValue.type)) {
          for (const i in bidiValue) {
            bidiValue[i] = this.webDriverValueToBiDi(bidiValue[i]);
          }
        }
        if (["object", "map"].includes(webDriverValue.type)) {
          for (const i in bidiValue) {
            bidiValue[i] = [
              this.webDriverValueToBiDi(bidiValue[i][0]),
              this.webDriverValueToBiDi(bidiValue[i][1])
            ];
          }
        }
        return result;
      }
      toBiDi() {
        return {
          realm: this.realmId,
          origin: this.origin,
          type: this.type,
          context: this.browsingContextId,
          ...this.sandbox === void 0 ? {} : { sandbox: this.sandbox }
        };
      }
      get realmId() {
        return this.#realmId;
      }
      get navigableId() {
        return this.#browsingContextStorage.findContext(this.#browsingContextId)?.navigableId ?? "UNKNOWN";
      }
      get browsingContextId() {
        return this.#browsingContextId;
      }
      get executionContextId() {
        return this.#executionContextId;
      }
      get origin() {
        return this.#origin;
      }
      get type() {
        return this.#type;
      }
      get cdpClient() {
        return this.#cdpClient;
      }
      async callFunction(functionDeclaration, _this, _arguments, awaitPromise, resultOwnership) {
        const context = this.#browsingContextStorage.getContext(this.browsingContextId);
        await context.awaitUnblocked();
        return {
          result: await this.#scriptEvaluator.callFunction(this, functionDeclaration, _this, _arguments, awaitPromise, resultOwnership)
        };
      }
      async scriptEvaluate(expression, awaitPromise, resultOwnership) {
        const context = this.#browsingContextStorage.getContext(this.browsingContextId);
        await context.awaitUnblocked();
        return {
          result: await this.#scriptEvaluator.scriptEvaluate(this, expression, awaitPromise, resultOwnership)
        };
      }
      /**
       * Serializes a given CDP object into BiDi, keeping references in the
       * target's `globalThis`.
       * @param cdpObject CDP remote object to be serialized.
       * @param resultOwnership Indicates desired ResultOwnership.
       */
      async serializeCdpObject(cdpObject, resultOwnership) {
        return this.#scriptEvaluator.serializeCdpObject(cdpObject, resultOwnership, this);
      }
      /**
       * Gets the string representation of an object. This is equivalent to
       * calling toString() on the object value.
       * @param cdpObject CDP remote object representing an object.
       * @return string The stringified object.
       */
      async stringifyObject(cdpObject) {
        return scriptEvaluator_js_1.ScriptEvaluator.stringifyObject(cdpObject, this);
      }
    };
    exports2.Realm = Realm;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextImpl.js
var require_browsingContextImpl = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowsingContextImpl = void 0;
    var unitConversions_js_1 = require_unitConversions();
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var deferred_js_1 = require_deferred();
    var realm_js_1 = require_realm();
    var BrowsingContextImpl = class {
      /** The ID of the current context. */
      #contextId;
      /**
       * The ID of the parent context.
       * If null, this is a top-level context.
       */
      #parentId;
      /**
       * Children contexts.
       * Map from children context ID to context implementation.
       */
      #children = /* @__PURE__ */ new Map();
      #browsingContextStorage;
      #defers = {
        documentInitialized: new deferred_js_1.Deferred(),
        Page: {
          navigatedWithinDocument: new deferred_js_1.Deferred(),
          lifecycleEvent: {
            DOMContentLoaded: new deferred_js_1.Deferred(),
            load: new deferred_js_1.Deferred()
          }
        }
      };
      #url = "about:blank";
      #eventManager;
      #realmStorage;
      #loaderId = null;
      #cdpTarget;
      #maybeDefaultRealm;
      #logger;
      constructor(cdpTarget, realmStorage, contextId, parentId, eventManager, browsingContextStorage, logger) {
        this.#cdpTarget = cdpTarget;
        this.#realmStorage = realmStorage;
        this.#contextId = contextId;
        this.#parentId = parentId;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#logger = logger;
        this.#initListeners();
      }
      static create(cdpTarget, realmStorage, contextId, parentId, eventManager, browsingContextStorage, logger) {
        const context = new BrowsingContextImpl(cdpTarget, realmStorage, contextId, parentId, eventManager, browsingContextStorage, logger);
        browsingContextStorage.addContext(context);
        eventManager.registerEvent({
          method: protocol_js_1.BrowsingContext.EventNames.ContextCreatedEvent,
          params: context.serializeToBidiValue()
        }, context.contextId);
        return context;
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
       */
      get navigableId() {
        return this.#loaderId;
      }
      delete() {
        this.#deleteChildren();
        this.#realmStorage.deleteRealms({
          browsingContextId: this.contextId
        });
        if (this.parentId !== null) {
          const parent = this.#browsingContextStorage.getContext(this.parentId);
          parent.#children.delete(this.contextId);
        }
        this.#eventManager.registerEvent({
          method: protocol_js_1.BrowsingContext.EventNames.ContextDestroyedEvent,
          params: this.serializeToBidiValue()
        }, this.contextId);
        this.#browsingContextStorage.deleteContext(this.contextId);
      }
      /** Returns the ID of this context. */
      get contextId() {
        return this.#contextId;
      }
      /** Returns the parent context ID. */
      get parentId() {
        return this.#parentId;
      }
      /** Returns all children contexts. */
      get children() {
        return Array.from(this.#children.values());
      }
      /**
       * Returns true if this is a top-level context.
       * This is the case whenever the parent context ID is null.
       */
      isTopLevelContext() {
        return this.#parentId === null;
      }
      addChild(child) {
        this.#children.set(child.contextId, child);
      }
      #deleteChildren() {
        this.children.map((child) => child.delete());
      }
      get #defaultRealm() {
        if (this.#maybeDefaultRealm === void 0) {
          throw new Error(`No default realm for browsing context ${this.#contextId}`);
        }
        return this.#maybeDefaultRealm;
      }
      get cdpTarget() {
        return this.#cdpTarget;
      }
      updateCdpTarget(cdpTarget) {
        this.#cdpTarget = cdpTarget;
        this.#initListeners();
      }
      get url() {
        return this.#url;
      }
      async awaitLoaded() {
        await this.#defers.Page.lifecycleEvent.load;
      }
      awaitUnblocked() {
        return this.#cdpTarget.targetUnblocked;
      }
      async getOrCreateSandbox(sandbox) {
        if (sandbox === void 0 || sandbox === "") {
          return this.#defaultRealm;
        }
        let maybeSandboxes = this.#realmStorage.findRealms({
          browsingContextId: this.contextId,
          sandbox
        });
        if (maybeSandboxes.length === 0) {
          await this.#cdpTarget.cdpClient.sendCommand("Page.createIsolatedWorld", {
            frameId: this.contextId,
            worldName: sandbox
          });
          maybeSandboxes = this.#realmStorage.findRealms({
            browsingContextId: this.contextId,
            sandbox
          });
        }
        if (maybeSandboxes.length !== 1) {
          throw Error(`Sandbox ${sandbox} wasn't created.`);
        }
        return maybeSandboxes[0];
      }
      serializeToBidiValue(maxDepth = 0, addParentFiled = true) {
        return {
          context: this.#contextId,
          url: this.url,
          children: maxDepth > 0 ? this.children.map((c) => c.serializeToBidiValue(maxDepth - 1, false)) : null,
          ...addParentFiled ? { parent: this.#parentId } : {}
        };
      }
      #initListeners() {
        this.#cdpTarget.cdpClient.on("Target.targetInfoChanged", (params) => {
          if (this.contextId !== params.targetInfo.targetId) {
            return;
          }
          this.#url = params.targetInfo.url;
        });
        this.#cdpTarget.cdpClient.on("Page.frameNavigated", (params) => {
          if (this.contextId !== params.frame.id) {
            return;
          }
          this.#url = params.frame.url + (params.frame.urlFragment ?? "");
          this.#deleteChildren();
        });
        this.#cdpTarget.cdpClient.on("Page.navigatedWithinDocument", (params) => {
          if (this.contextId !== params.frameId) {
            return;
          }
          this.#url = params.url;
          this.#defers.Page.navigatedWithinDocument.resolve(params);
        });
        this.#cdpTarget.cdpClient.on("Page.lifecycleEvent", (params) => {
          if (this.contextId !== params.frameId) {
            return;
          }
          const timestamp = (/* @__PURE__ */ new Date()).getTime();
          if (params.name === "init") {
            this.#documentChanged(params.loaderId);
            this.#defers.documentInitialized.resolve();
          }
          if (params.name === "commit") {
            this.#loaderId = params.loaderId;
            return;
          }
          if (params.loaderId !== this.#loaderId) {
            return;
          }
          switch (params.name) {
            case "DOMContentLoaded":
              this.#defers.Page.lifecycleEvent.DOMContentLoaded.resolve(params);
              this.#eventManager.registerEvent({
                method: protocol_js_1.BrowsingContext.EventNames.DomContentLoadedEvent,
                params: {
                  context: this.contextId,
                  navigation: this.#loaderId,
                  timestamp,
                  url: this.#url
                }
              }, this.contextId);
              break;
            case "load":
              this.#defers.Page.lifecycleEvent.load.resolve(params);
              this.#eventManager.registerEvent({
                method: protocol_js_1.BrowsingContext.EventNames.LoadEvent,
                params: {
                  context: this.contextId,
                  navigation: this.#loaderId,
                  timestamp,
                  url: this.#url
                }
              }, this.contextId);
              break;
          }
        });
        this.#cdpTarget.cdpClient.on("Runtime.executionContextCreated", (params) => {
          if (params.context.auxData.frameId !== this.contextId) {
            return;
          }
          if (!["default", "isolated"].includes(params.context.auxData.type)) {
            return;
          }
          const realm = new realm_js_1.Realm(
            this.#realmStorage,
            this.#browsingContextStorage,
            params.context.uniqueId,
            this.contextId,
            params.context.id,
            this.#getOrigin(params),
            // TODO: differentiate types.
            "window",
            // Sandbox name for isolated world.
            params.context.auxData.type === "isolated" ? params.context.name : void 0,
            this.#cdpTarget.cdpSessionId,
            this.#cdpTarget.cdpClient,
            this.#eventManager
          );
          if (params.context.auxData.isDefault) {
            this.#maybeDefaultRealm = realm;
          }
        });
        this.#cdpTarget.cdpClient.on("Runtime.executionContextDestroyed", (params) => {
          this.#realmStorage.deleteRealms({
            cdpSessionId: this.#cdpTarget.cdpSessionId,
            executionContextId: params.executionContextId
          });
        });
        this.#cdpTarget.cdpClient.on("Runtime.executionContextsCleared", () => {
          this.#realmStorage.deleteRealms({
            cdpSessionId: this.#cdpTarget.cdpSessionId
          });
        });
      }
      #getOrigin(params) {
        if (params.context.auxData.type === "isolated") {
          return this.#defaultRealm.origin;
        }
        return ["://", ""].includes(params.context.origin) ? "null" : params.context.origin;
      }
      #documentChanged(loaderId) {
        if (loaderId === void 0 || this.#loaderId === loaderId) {
          if (this.#defers.Page.navigatedWithinDocument.isFinished) {
            this.#defers.Page.navigatedWithinDocument = new deferred_js_1.Deferred();
          }
          return;
        }
        if (this.#defers.documentInitialized.isFinished) {
          this.#defers.documentInitialized = new deferred_js_1.Deferred();
        } else {
          this.#logger?.(log_js_1.LogType.browsingContexts, "Document changed");
        }
        if (this.#defers.Page.lifecycleEvent.DOMContentLoaded.isFinished) {
          this.#defers.Page.lifecycleEvent.DOMContentLoaded = new deferred_js_1.Deferred();
        } else {
          this.#logger?.(log_js_1.LogType.browsingContexts, "Document changed");
        }
        if (this.#defers.Page.lifecycleEvent.load.isFinished) {
          this.#defers.Page.lifecycleEvent.load = new deferred_js_1.Deferred();
        } else {
          this.#logger?.(log_js_1.LogType.browsingContexts, "Document changed");
        }
        this.#loaderId = loaderId;
      }
      async navigate(url, wait) {
        await this.awaitUnblocked();
        const cdpNavigateResult = await this.#cdpTarget.cdpClient.sendCommand("Page.navigate", {
          url,
          frameId: this.contextId
        });
        if (cdpNavigateResult.errorText) {
          throw new protocol_js_1.Message.UnknownErrorException(cdpNavigateResult.errorText);
        }
        this.#documentChanged(cdpNavigateResult.loaderId);
        switch (wait) {
          case "none":
            break;
          case "interactive":
            if (cdpNavigateResult.loaderId === void 0) {
              await this.#defers.Page.navigatedWithinDocument;
            } else {
              await this.#defers.Page.lifecycleEvent.DOMContentLoaded;
            }
            break;
          case "complete":
            if (cdpNavigateResult.loaderId === void 0) {
              await this.#defers.Page.navigatedWithinDocument;
            } else {
              await this.#defers.Page.lifecycleEvent.load;
            }
            break;
        }
        return {
          result: {
            navigation: cdpNavigateResult.loaderId || null,
            url
          }
        };
      }
      async captureScreenshot() {
        const [, result] = await Promise.all([
          // TODO: Either make this a proposal in the BiDi spec, or focus the
          // original tab right after the screenshot is taken.
          // The screenshot command gets blocked until we focus the active tab.
          this.#cdpTarget.cdpClient.sendCommand("Page.bringToFront"),
          this.#cdpTarget.cdpClient.sendCommand("Page.captureScreenshot", {})
        ]);
        return {
          result: {
            data: result.data
          }
        };
      }
      async print(params) {
        const printToPdfCdpParams = {
          printBackground: params.background,
          landscape: params.orientation === "landscape",
          pageRanges: params.pageRanges?.join(",") ?? "",
          scale: params.scale,
          preferCSSPageSize: !params.shrinkToFit
        };
        if (params.margin?.bottom) {
          printToPdfCdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
        }
        if (params.margin?.left) {
          printToPdfCdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
        }
        if (params.margin?.right) {
          printToPdfCdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
        }
        if (params.margin?.top) {
          printToPdfCdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
        }
        if (params.page?.height) {
          printToPdfCdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
        }
        if (params.page?.width) {
          printToPdfCdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
        }
        const result = await this.#cdpTarget.cdpClient.sendCommand("Page.printToPDF", printToPdfCdpParams);
        return {
          result: {
            data: result.data
          }
        };
      }
      async addPreloadScript(params) {
        const result = await this.#cdpTarget.cdpClient.sendCommand("Page.addScriptToEvaluateOnNewDocument", {
          // The spec provides a function, and CDP expects an evaluation.
          source: `(${params.expression})();`,
          worldName: params.sandbox
        });
        return {
          result: {
            script: result.identifier
          }
        };
      }
    };
    exports2.BrowsingContextImpl = BrowsingContextImpl;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logHelper.js
var require_logHelper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRemoteValuesText = exports2.logMessageFormatter = void 0;
    var specifiers = ["%s", "%d", "%i", "%f", "%o", "%O", "%c"];
    function isFormmatSpecifier(str) {
      return specifiers.some((spec) => str.includes(spec));
    }
    function logMessageFormatter(args) {
      let output = "";
      const argFormat = args[0].value.toString();
      const argValues = args.slice(1, void 0);
      const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join("|"), "g"));
      for (const token of tokens) {
        if (token === void 0 || token === "") {
          continue;
        }
        if (isFormmatSpecifier(token)) {
          const arg = argValues.shift();
          if (arg === void 0) {
            throw new Error(`Less value is provided: "${getRemoteValuesText(args, false)}"`);
          }
          if (token === "%s") {
            output += stringFromArg(arg);
          } else if (token === "%d" || token === "%i") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseInt(arg.value.toString(), 10);
            } else {
              output += "NaN";
            }
          } else if (token === "%f") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseFloat(arg.value.toString());
            } else {
              output += "NaN";
            }
          } else {
            output += toJson(arg);
          }
        } else {
          output += token;
        }
      }
      if (argValues.length > 0) {
        throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
      }
      return output;
    }
    exports2.logMessageFormatter = logMessageFormatter;
    function toJson(arg) {
      if (arg.type !== "array" && arg.type !== "bigint" && arg.type !== "date" && arg.type !== "number" && arg.type !== "object" && arg.type !== "string") {
        return stringFromArg(arg);
      }
      if (arg.type === "bigint") {
        return `${arg.value.toString()}n`;
      }
      if (arg.type === "number") {
        return arg.value.toString();
      }
      if (["date", "string"].includes(arg.type)) {
        return JSON.stringify(arg.value);
      }
      if (arg.type === "object") {
        return `{${arg.value.map((pair) => {
          return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
        }).join(",")}}`;
      }
      if (arg.type === "array") {
        return `[${arg.value?.map((val) => toJson(val)).join(",") ?? ""}]`;
      }
      throw Error(`Invalid value type: ${arg.toString()}`);
    }
    function stringFromArg(arg) {
      if (!Object.hasOwn(arg, "value")) {
        return arg.type;
      }
      switch (arg.type) {
        case "string":
        case "number":
        case "boolean":
        case "bigint":
          return String(arg.value);
        case "regexp":
          return `/${arg.value.pattern}/${arg.value.flags ?? ""}`;
        case "date":
          return new Date(arg.value).toString();
        case "object":
          return `Object(${arg.value?.length ?? ""})`;
        case "array":
          return `Array(${arg.value?.length ?? ""})`;
        case "map":
          return `Map(${arg.value.length})`;
        case "set":
          return `Set(${arg.value.length})`;
        case "node":
          return "node";
        default:
          return arg.type;
      }
    }
    function getRemoteValuesText(args, formatText) {
      const arg = args[0];
      if (!arg) {
        return "";
      }
      if (arg.type === "string" && isFormmatSpecifier(arg.value.toString()) && formatText) {
        return logMessageFormatter(args);
      }
      return args.map((arg2) => {
        return stringFromArg(arg2);
      }).join(" ");
    }
    exports2.getRemoteValuesText = getRemoteValuesText;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logManager.js
var require_logManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogManager = void 0;
    var protocol_js_1 = require_protocol();
    var logHelper_js_1 = require_logHelper();
    function getBidiStackTrace(cdpStackTrace) {
      const stackFrames = cdpStackTrace?.callFrames.map((callFrame) => {
        return {
          columnNumber: callFrame.columnNumber,
          functionName: callFrame.functionName,
          lineNumber: callFrame.lineNumber,
          url: callFrame.url
        };
      });
      return stackFrames ? { callFrames: stackFrames } : void 0;
    }
    function getLogLevel(consoleApiType) {
      if (["assert", "error"].includes(consoleApiType)) {
        return "error";
      }
      if (["debug", "trace"].includes(consoleApiType)) {
        return "debug";
      }
      if (["warn", "warning"].includes(consoleApiType)) {
        return "warn";
      }
      return "info";
    }
    var LogManager = class {
      #eventManager;
      #realmStorage;
      #cdpTarget;
      constructor(cdpTarget, realmStorage, eventManager) {
        this.#cdpTarget = cdpTarget;
        this.#realmStorage = realmStorage;
        this.#eventManager = eventManager;
      }
      static create(cdpTarget, realmStorage, eventManager) {
        const logManager = new LogManager(cdpTarget, realmStorage, eventManager);
        logManager.#initialize();
        return logManager;
      }
      #initialize() {
        this.#initializeLogEntryAddedEventListener();
      }
      #initializeLogEntryAddedEventListener() {
        this.#cdpTarget.cdpClient.on("Runtime.consoleAPICalled", (params) => {
          const realm = this.#realmStorage.findRealm({
            cdpSessionId: this.#cdpTarget.cdpSessionId,
            executionContextId: params.executionContextId
          });
          const argsPromise = realm === void 0 ? Promise.resolve(params.args) : (
            // Properly serialize arguments if possible.
            Promise.all(params.args.map((arg) => {
              return realm.serializeCdpObject(arg, "none");
            }))
          );
          this.#eventManager.registerPromiseEvent(argsPromise.then((args) => ({
            method: protocol_js_1.Log.EventNames.LogEntryAddedEvent,
            params: {
              level: getLogLevel(params.type),
              source: {
                realm: realm?.realmId ?? "UNKNOWN",
                context: realm?.browsingContextId ?? "UNKNOWN"
              },
              text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
              timestamp: Math.round(params.timestamp),
              stackTrace: getBidiStackTrace(params.stackTrace),
              type: "console",
              // Console method is `warn`, not `warning`.
              method: params.type === "warning" ? "warn" : params.type,
              args
            }
          })), realm?.browsingContextId ?? "UNKNOWN", protocol_js_1.Log.EventNames.LogEntryAddedEvent);
        });
        this.#cdpTarget.cdpClient.on("Runtime.exceptionThrown", (params) => {
          const realm = this.#realmStorage.findRealm({
            cdpSessionId: this.#cdpTarget.cdpSessionId,
            executionContextId: params.exceptionDetails.executionContextId
          });
          const textPromise = (async () => {
            if (!params.exceptionDetails.exception) {
              return params.exceptionDetails.text;
            }
            if (realm === void 0) {
              return JSON.stringify(params.exceptionDetails.exception);
            }
            return realm.stringifyObject(params.exceptionDetails.exception);
          })();
          this.#eventManager.registerPromiseEvent(textPromise.then((text) => ({
            method: protocol_js_1.Log.EventNames.LogEntryAddedEvent,
            params: {
              level: "error",
              source: {
                realm: realm?.realmId ?? "UNKNOWN",
                context: realm?.browsingContextId ?? "UNKNOWN"
              },
              text,
              timestamp: Math.round(params.timestamp),
              stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
              type: "javascript"
            }
          })), realm?.browsingContextId ?? "UNKNOWN", protocol_js_1.Log.EventNames.LogEntryAddedEvent);
        });
      }
    };
    exports2.LogManager = LogManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js
var require_DefaultMap = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultMap = void 0;
    var DefaultMap = class extends Map {
      /** The default value to return whenever a key is not present in the map. */
      #getDefaultValue;
      constructor(getDefaultValue, entries) {
        super(entries);
        this.#getDefaultValue = getDefaultValue;
      }
      get(key) {
        if (!this.has(key)) {
          this.set(key, this.#getDefaultValue(key));
        }
        return super.get(key);
      }
    };
    exports2.DefaultMap = DefaultMap;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/networkRequest.js
var require_networkRequest = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/networkRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NetworkRequest = void 0;
    var deferred_1 = require_deferred();
    var protocol_1 = require_protocol();
    var _unknown, _eventManager, _requestWillBeSentEvent, _requestWillBeSentExtraInfoEvent, _responseReceivedEvent, _responseReceivedExtraInfoEvent, _beforeRequestSentDeferred, _responseReceivedDeferred, _sendBeforeRequestEvent, sendBeforeRequestEvent_fn, _getBeforeRequestEvent, getBeforeRequestEvent_fn, _getBaseEventParams, getBaseEventParams_fn, _getRequestData, getRequestData_fn, _getInitiatorType, getInitiatorType_fn, _getCookiesSameSite, getCookiesSameSite_fn, _getCookies, getCookies_fn, _sendResponseReceivedEvent, sendResponseReceivedEvent_fn, _getResponseReceivedEvent, getResponseReceivedEvent_fn, _getHeaders, getHeaders_fn, _isIgnoredEvent, isIgnoredEvent_fn;
    var _NetworkRequest = class {
      constructor(requestId, eventManager) {
        __privateAdd(this, _sendBeforeRequestEvent);
        __privateAdd(this, _getBeforeRequestEvent);
        __privateAdd(this, _getBaseEventParams);
        __privateAdd(this, _getRequestData);
        __privateAdd(this, _getInitiatorType);
        __privateAdd(this, _sendResponseReceivedEvent);
        __privateAdd(this, _getResponseReceivedEvent);
        __privateAdd(this, _getHeaders);
        __privateAdd(this, _isIgnoredEvent);
        __publicField(this, "requestId");
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _requestWillBeSentEvent, void 0);
        __privateAdd(this, _requestWillBeSentExtraInfoEvent, void 0);
        __privateAdd(this, _responseReceivedEvent, void 0);
        __privateAdd(this, _responseReceivedExtraInfoEvent, void 0);
        __privateAdd(this, _beforeRequestSentDeferred, void 0);
        __privateAdd(this, _responseReceivedDeferred, void 0);
        this.requestId = requestId;
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _beforeRequestSentDeferred, new deferred_1.Deferred());
        __privateSet(this, _responseReceivedDeferred, new deferred_1.Deferred());
      }
      onRequestWillBeSentEvent(requestWillBeSentEvent) {
        if (__privateGet(this, _requestWillBeSentEvent) !== void 0) {
          throw new Error("RequestWillBeSentEvent is already set");
        }
        __privateSet(this, _requestWillBeSentEvent, requestWillBeSentEvent);
        if (__privateGet(this, _requestWillBeSentExtraInfoEvent) !== void 0) {
          __privateGet(this, _beforeRequestSentDeferred).resolve();
        }
        __privateMethod(this, _sendBeforeRequestEvent, sendBeforeRequestEvent_fn).call(this);
      }
      onRequestWillBeSentExtraInfoEvent(requestWillBeSentExtraInfoEvent) {
        if (__privateGet(this, _requestWillBeSentExtraInfoEvent) !== void 0) {
          throw new Error("RequestWillBeSentExtraInfoEvent is already set");
        }
        __privateSet(this, _requestWillBeSentExtraInfoEvent, requestWillBeSentExtraInfoEvent);
        if (__privateGet(this, _requestWillBeSentEvent) !== void 0) {
          __privateGet(this, _beforeRequestSentDeferred).resolve();
        }
      }
      onResponseReceivedEvent(responseReceivedEvent) {
        if (__privateGet(this, _responseReceivedEvent) !== void 0) {
          throw new Error("ResponseReceivedEvent is already set");
        }
        __privateSet(this, _responseReceivedEvent, responseReceivedEvent);
        if (__privateGet(this, _responseReceivedExtraInfoEvent) !== void 0) {
          __privateGet(this, _responseReceivedDeferred).resolve();
        }
        __privateMethod(this, _sendResponseReceivedEvent, sendResponseReceivedEvent_fn).call(this);
      }
      onResponseReceivedEventExtraInfo(responseReceivedExtraInfoEvent) {
        if (__privateGet(this, _responseReceivedExtraInfoEvent) !== void 0) {
          throw new Error("ResponseReceivedExtraInfoEvent is already set");
        }
        __privateSet(this, _responseReceivedExtraInfoEvent, responseReceivedExtraInfoEvent);
        if (__privateGet(this, _responseReceivedEvent) !== void 0) {
          __privateGet(this, _responseReceivedDeferred).resolve();
        }
      }
      onLoadingFailedEvent(loadingFailedEvent) {
        __privateGet(this, _beforeRequestSentDeferred).resolve();
        __privateGet(this, _responseReceivedDeferred).reject(loadingFailedEvent);
        const params = {
          ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this),
          errorText: loadingFailedEvent.errorText
        };
        __privateGet(this, _eventManager).registerEvent({
          method: protocol_1.Network.EventNames.FetchErrorEvent,
          params
        }, __privateGet(this, _requestWillBeSentEvent)?.frameId ?? null);
      }
    };
    var NetworkRequest = _NetworkRequest;
    _unknown = new WeakMap();
    _eventManager = new WeakMap();
    _requestWillBeSentEvent = new WeakMap();
    _requestWillBeSentExtraInfoEvent = new WeakMap();
    _responseReceivedEvent = new WeakMap();
    _responseReceivedExtraInfoEvent = new WeakMap();
    _beforeRequestSentDeferred = new WeakMap();
    _responseReceivedDeferred = new WeakMap();
    _sendBeforeRequestEvent = new WeakSet();
    sendBeforeRequestEvent_fn = function() {
      if (!__privateMethod(this, _isIgnoredEvent, isIgnoredEvent_fn).call(this)) {
        __privateGet(this, _eventManager).registerPromiseEvent(__privateGet(this, _beforeRequestSentDeferred).then(() => __privateMethod(this, _getBeforeRequestEvent, getBeforeRequestEvent_fn).call(this)), __privateGet(this, _requestWillBeSentEvent)?.frameId ?? null, protocol_1.Network.EventNames.BeforeRequestSentEvent);
      }
    };
    _getBeforeRequestEvent = new WeakSet();
    getBeforeRequestEvent_fn = function() {
      if (__privateGet(this, _requestWillBeSentEvent) === void 0) {
        throw new Error("RequestWillBeSentEvent is not set");
      }
      const params = {
        ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this),
        initiator: { type: __privateMethod(this, _getInitiatorType, getInitiatorType_fn).call(this) }
      };
      return {
        method: protocol_1.Network.EventNames.BeforeRequestSentEvent,
        params
      };
    };
    _getBaseEventParams = new WeakSet();
    getBaseEventParams_fn = function() {
      return {
        context: __privateGet(this, _requestWillBeSentEvent)?.frameId ?? null,
        navigation: __privateGet(this, _requestWillBeSentEvent)?.loaderId ?? null,
        // TODO: implement.
        redirectCount: 0,
        request: __privateMethod(this, _getRequestData, getRequestData_fn).call(this),
        // Timestamp should be in milliseconds, while CDP provides it in seconds.
        timestamp: Math.round((__privateGet(this, _requestWillBeSentEvent)?.wallTime ?? 0) * 1e3)
      };
    };
    _getRequestData = new WeakSet();
    getRequestData_fn = function() {
      var _a;
      const cookies = __privateGet(this, _requestWillBeSentExtraInfoEvent) === void 0 ? [] : __privateMethod(_a = _NetworkRequest, _getCookies, getCookies_fn).call(_a, __privateGet(this, _requestWillBeSentExtraInfoEvent).associatedCookies);
      return {
        request: __privateGet(this, _requestWillBeSentEvent)?.requestId ?? __privateGet(_NetworkRequest, _unknown),
        url: __privateGet(this, _requestWillBeSentEvent)?.request.url ?? __privateGet(_NetworkRequest, _unknown),
        method: __privateGet(this, _requestWillBeSentEvent)?.request.method ?? __privateGet(_NetworkRequest, _unknown),
        headers: Object.keys(__privateGet(this, _requestWillBeSentEvent)?.request.headers ?? []).map((key) => ({
          name: key,
          value: __privateGet(this, _requestWillBeSentEvent)?.request.headers[key]
        })),
        cookies,
        // TODO: implement.
        headersSize: -1,
        // TODO: implement.
        bodySize: 0,
        timings: {
          // TODO: implement.
          timeOrigin: 0,
          // TODO: implement.
          requestTime: 0,
          // TODO: implement.
          redirectStart: 0,
          // TODO: implement.
          redirectEnd: 0,
          // TODO: implement.
          fetchStart: 0,
          // TODO: implement.
          dnsStart: 0,
          // TODO: implement.
          dnsEnd: 0,
          // TODO: implement.
          connectStart: 0,
          // TODO: implement.
          connectEnd: 0,
          // TODO: implement.
          tlsStart: 0,
          // TODO: implement.
          tlsEnd: 0,
          // TODO: implement.
          requestStart: 0,
          // TODO: implement.
          responseStart: 0,
          // TODO: implement.
          responseEnd: 0
        }
      };
    };
    _getInitiatorType = new WeakSet();
    getInitiatorType_fn = function() {
      switch (__privateGet(this, _requestWillBeSentEvent)?.initiator.type) {
        case "parser":
        case "script":
        case "preflight":
          return __privateGet(this, _requestWillBeSentEvent).initiator.type;
        default:
          return "other";
      }
    };
    _getCookiesSameSite = new WeakSet();
    getCookiesSameSite_fn = function(cdpSameSiteValue) {
      switch (cdpSameSiteValue) {
        case "Strict":
          return "strict";
        case "Lax":
          return "lax";
        default:
          return "none";
      }
    };
    _getCookies = new WeakSet();
    getCookies_fn = function(associatedCookies) {
      return associatedCookies.map((cookieInfo) => {
        var _a;
        return {
          name: cookieInfo.cookie.name,
          value: cookieInfo.cookie.value,
          domain: cookieInfo.cookie.domain,
          path: cookieInfo.cookie.path,
          expires: cookieInfo.cookie.expires,
          size: cookieInfo.cookie.size,
          httpOnly: cookieInfo.cookie.httpOnly,
          secure: cookieInfo.cookie.secure,
          sameSite: __privateMethod(_a = _NetworkRequest, _getCookiesSameSite, getCookiesSameSite_fn).call(_a, cookieInfo.cookie.sameSite)
        };
      });
    };
    _sendResponseReceivedEvent = new WeakSet();
    sendResponseReceivedEvent_fn = function() {
      if (!__privateMethod(this, _isIgnoredEvent, isIgnoredEvent_fn).call(this)) {
        __privateGet(this, _eventManager).registerPromiseEvent(__privateGet(this, _responseReceivedDeferred).then(() => __privateMethod(this, _getResponseReceivedEvent, getResponseReceivedEvent_fn).call(this)), __privateGet(this, _responseReceivedEvent)?.frameId ?? null, protocol_1.Network.EventNames.ResponseCompletedEvent);
      }
    };
    _getResponseReceivedEvent = new WeakSet();
    getResponseReceivedEvent_fn = function() {
      if (__privateGet(this, _responseReceivedEvent) === void 0) {
        throw new Error("ResponseReceivedEvent is not set");
      }
      if (__privateGet(this, _requestWillBeSentEvent) === void 0) {
        throw new Error("RequestWillBeSentEvent is not set");
      }
      return {
        method: protocol_1.Network.EventNames.ResponseCompletedEvent,
        params: {
          ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this),
          response: {
            url: __privateGet(this, _responseReceivedEvent).response.url,
            protocol: __privateGet(this, _responseReceivedEvent).response.protocol,
            status: __privateGet(this, _responseReceivedEvent).response.status,
            statusText: __privateGet(this, _responseReceivedEvent).response.statusText,
            // Check if this is correct.
            fromCache: __privateGet(this, _responseReceivedEvent).response.fromDiskCache || __privateGet(this, _responseReceivedEvent).response.fromPrefetchCache,
            // TODO: implement.
            headers: __privateMethod(this, _getHeaders, getHeaders_fn).call(this, __privateGet(this, _responseReceivedEvent).response.headers),
            mimeType: __privateGet(this, _responseReceivedEvent).response.mimeType,
            bytesReceived: __privateGet(this, _responseReceivedEvent).response.encodedDataLength,
            headersSize: __privateGet(this, _responseReceivedExtraInfoEvent)?.headersText?.length ?? -1,
            // TODO: consider removing from spec.
            bodySize: -1,
            content: {
              // TODO: consider removing from spec.
              size: -1
            }
          }
        }
      };
    };
    _getHeaders = new WeakSet();
    getHeaders_fn = function(headers) {
      return Object.keys(headers).map((key) => ({
        name: key,
        value: headers[key]
      }));
    };
    _isIgnoredEvent = new WeakSet();
    isIgnoredEvent_fn = function() {
      return __privateGet(this, _requestWillBeSentEvent)?.request.url.endsWith("/favicon.ico") ?? false;
    };
    __privateAdd(NetworkRequest, _getCookiesSameSite);
    __privateAdd(NetworkRequest, _getCookies);
    __privateAdd(NetworkRequest, _unknown, "UNKNOWN");
    exports2.NetworkRequest = NetworkRequest;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/networkProcessor.js
var require_networkProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/networkProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NetworkProcessor = void 0;
    var DefaultMap_1 = require_DefaultMap();
    var networkRequest_1 = require_networkRequest();
    var NetworkProcessor = class {
      #eventManager;
      /**
       * Map of request ID to NetworkRequest objects. Needed as long as information
       * about requests comes from different events.
       */
      #requestMap;
      constructor(eventManager) {
        this.#eventManager = eventManager;
        this.#requestMap = new DefaultMap_1.DefaultMap((requestId) => new networkRequest_1.NetworkRequest(requestId, this.#eventManager));
      }
      static async create(cdpClient, eventManager) {
        const networkProcessor = new NetworkProcessor(eventManager);
        cdpClient.on("Network.requestWillBeSent", (params) => {
          networkProcessor.#getOrCreateNetworkRequest(params.requestId).onRequestWillBeSentEvent(params);
        });
        cdpClient.on("Network.requestWillBeSentExtraInfo", (params) => {
          networkProcessor.#getOrCreateNetworkRequest(params.requestId).onRequestWillBeSentExtraInfoEvent(params);
        });
        cdpClient.on("Network.responseReceived", (params) => {
          networkProcessor.#getOrCreateNetworkRequest(params.requestId).onResponseReceivedEvent(params);
        });
        cdpClient.on("Network.responseReceivedExtraInfo", (params) => {
          networkProcessor.#getOrCreateNetworkRequest(params.requestId).onResponseReceivedEventExtraInfo(params);
        });
        cdpClient.on("Network.loadingFailed", (params) => {
          networkProcessor.#getOrCreateNetworkRequest(params.requestId).onLoadingFailedEvent(params);
        });
        await cdpClient.sendCommand("Network.enable");
        return networkProcessor;
      }
      #getOrCreateNetworkRequest(requestId) {
        return this.#requestMap.get(requestId);
      }
    };
    exports2.NetworkProcessor = NetworkProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/cdpTarget.js
var require_cdpTarget = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/cdpTarget.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CdpTarget = void 0;
    var logManager_1 = require_logManager();
    var protocol_1 = require_protocol();
    var deferred_1 = require_deferred();
    var networkProcessor_1 = require_networkProcessor();
    var CdpTarget = class {
      #targetUnblocked;
      #targetId;
      #cdpClient;
      #eventManager;
      #cdpSessionId;
      #networkDomainActivated;
      static create(targetId, cdpClient, cdpSessionId, realmStorage, eventManager) {
        const cdpTarget = new CdpTarget(targetId, cdpClient, cdpSessionId, eventManager);
        logManager_1.LogManager.create(cdpTarget, realmStorage, eventManager);
        cdpTarget.#setEventListeners();
        void cdpTarget.#unblock();
        return cdpTarget;
      }
      constructor(targetId, cdpClient, cdpSessionId, eventManager) {
        this.#targetId = targetId;
        this.#cdpClient = cdpClient;
        this.#cdpSessionId = cdpSessionId;
        this.#eventManager = eventManager;
        this.#networkDomainActivated = false;
        this.#targetUnblocked = new deferred_1.Deferred();
      }
      /**
       * Returns a promise that resolves when the target is unblocked.
       */
      get targetUnblocked() {
        return this.#targetUnblocked;
      }
      get targetId() {
        return this.#targetId;
      }
      get cdpClient() {
        return this.#cdpClient;
      }
      /**
       * Needed for CDP escape path.
       */
      get cdpSessionId() {
        return this.#cdpSessionId;
      }
      /**
       * Enables all the required CDP domains and unblocks the target.
       */
      async #unblock() {
        if (this.#eventManager.isNetworkDomainEnabled) {
          await this.enableNetworkDomain();
        }
        await this.#cdpClient.sendCommand("Runtime.enable");
        await this.#cdpClient.sendCommand("Page.enable");
        await this.#cdpClient.sendCommand("Page.setLifecycleEventsEnabled", {
          enabled: true
        });
        await this.#cdpClient.sendCommand("Target.setAutoAttach", {
          autoAttach: true,
          waitForDebuggerOnStart: true,
          flatten: true
        });
        await this.#cdpClient.sendCommand("Runtime.runIfWaitingForDebugger");
        this.#targetUnblocked.resolve();
      }
      /**
       * Enables the Network domain (creates NetworkProcessor on the target's cdp
       * client) if it is not enabled yet.
       */
      async enableNetworkDomain() {
        if (!this.#networkDomainActivated) {
          this.#networkDomainActivated = true;
          await networkProcessor_1.NetworkProcessor.create(this.cdpClient, this.#eventManager);
        }
      }
      #setEventListeners() {
        this.#cdpClient.on("*", (method, params) => {
          this.#eventManager.registerEvent({
            method: protocol_1.CDP.EventNames.EventReceivedEvent,
            params: {
              cdpMethod: method,
              cdpParams: params || {},
              cdpSession: this.#cdpSessionId
            }
          }, null);
        });
      }
    };
    exports2.CdpTarget = CdpTarget;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextProcessor.js
var require_browsingContextProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowsingContextProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var browsingContextImpl_js_1 = require_browsingContextImpl();
    var cdpTarget_js_1 = require_cdpTarget();
    var BrowsingContextProcessor = class {
      #browsingContextStorage;
      #cdpConnection;
      #eventManager;
      #logger;
      #realmStorage;
      #selfTargetId;
      constructor(realmStorage, cdpConnection, selfTargetId, eventManager, browsingContextStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#cdpConnection = cdpConnection;
        this.#eventManager = eventManager;
        this.#logger = logger;
        this.#realmStorage = realmStorage;
        this.#selfTargetId = selfTargetId;
        this.#setEventListeners(this.#cdpConnection.browserClient());
      }
      /**
       * This method is called for each CDP session, since this class is responsible
       * for creating and destroying all targets and browsing contexts.
       */
      #setEventListeners(cdpClient) {
        cdpClient.on("Target.attachedToTarget", (params) => {
          this.#handleAttachedToTargetEvent(params, cdpClient);
        });
        cdpClient.on("Target.detachedFromTarget", (params) => {
          this.#handleDetachedFromTargetEvent(params);
        });
        cdpClient.on("Page.frameAttached", (params) => {
          this.#handleFrameAttachedEvent(params);
        });
        cdpClient.on("Page.frameDetached", (params) => {
          this.#handleFrameDetachedEvent(params);
        });
      }
      // { "method": "Page.frameAttached",
      //   "params": {
      //     "frameId": "0A639AB1D9A392DF2CE02C53CC4ED3A6",
      //     "parentFrameId": "722BB0526C73B067A479BED6D0DB1156" } }
      #handleFrameAttachedEvent(params) {
        const parentBrowsingContext = this.#browsingContextStorage.findContext(params.parentFrameId);
        if (parentBrowsingContext !== void 0) {
          browsingContextImpl_js_1.BrowsingContextImpl.create(parentBrowsingContext.cdpTarget, this.#realmStorage, params.frameId, params.parentFrameId, this.#eventManager, this.#browsingContextStorage, this.#logger);
        }
      }
      // { "method": "Page.frameDetached",
      //   "params": {
      //     "frameId": "0A639AB1D9A392DF2CE02C53CC4ED3A6",
      //     "reason": "swap" } }
      #handleFrameDetachedEvent(params) {
        if (params.reason === "swap") {
          return;
        }
        this.#browsingContextStorage.findContext(params.frameId)?.delete();
      }
      // { "method": "Target.attachedToTarget",
      //   "params": {
      //     "sessionId": "EA999F39BDCABD7D45C9FEB787413BBA",
      //     "targetInfo": {
      //       "targetId": "722BB0526C73B067A479BED6D0DB1156",
      //       "type": "page",
      //       "title": "about:blank",
      //       "url": "about:blank",
      //       "attached": true,
      //       "canAccessOpener": false,
      //       "browserContextId": "1B5244080EC3FF28D03BBDA73138C0E2" },
      //     "waitingForDebugger": false } }
      #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
        const { sessionId, targetInfo } = params;
        const targetCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        if (!this.#isValidTarget(targetInfo)) {
          void targetCdpClient.sendCommand("Runtime.runIfWaitingForDebugger").then(() => parentSessionCdpClient.sendCommand("Target.detachFromTarget", params));
          return;
        }
        this.#logger?.(log_js_1.LogType.browsingContexts, "AttachedToTarget event received:", JSON.stringify(params, null, 2));
        this.#setEventListeners(targetCdpClient);
        const cdpTarget = cdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, sessionId, this.#realmStorage, this.#eventManager);
        if (this.#browsingContextStorage.hasContext(targetInfo.targetId)) {
          this.#browsingContextStorage.getContext(targetInfo.targetId).updateCdpTarget(cdpTarget);
        } else {
          browsingContextImpl_js_1.BrowsingContextImpl.create(cdpTarget, this.#realmStorage, targetInfo.targetId, null, this.#eventManager, this.#browsingContextStorage, this.#logger);
        }
      }
      // { "method": "Target.detachedFromTarget",
      //   "params": {
      //     "sessionId": "7EFBFB2A4942A8989B3EADC561BC46E9",
      //     "targetId": "19416886405CBA4E03DBB59FA67FF4E8" } }
      #handleDetachedFromTargetEvent(params) {
        const contextId = params.targetId;
        this.#browsingContextStorage.findContext(contextId)?.delete();
      }
      async #getRealm(target) {
        if ("realm" in target) {
          return this.#realmStorage.getRealm({
            realmId: target.realm
          });
        }
        const context = this.#browsingContextStorage.getContext(target.context);
        return context.getOrCreateSandbox(target.sandbox);
      }
      process_browsingContext_getTree(params) {
        const resultContexts = params.root === void 0 ? this.#browsingContextStorage.getTopLevelContexts() : [this.#browsingContextStorage.getContext(params.root)];
        return {
          result: {
            contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE))
          }
        };
      }
      async process_browsingContext_create(params) {
        const browserCdpClient = this.#cdpConnection.browserClient();
        let referenceContext = void 0;
        if (params.referenceContext !== void 0) {
          referenceContext = this.#browsingContextStorage.getContext(params.referenceContext);
          if (!referenceContext.isTopLevelContext()) {
            throw new protocol_js_1.Message.InvalidArgumentException(`referenceContext should be a top-level context`);
          }
        }
        const result = await browserCdpClient.sendCommand("Target.createTarget", {
          url: "about:blank",
          newWindow: params.type === "window"
        });
        const contextId = result.targetId;
        const context = this.#browsingContextStorage.getContext(contextId);
        await context.awaitLoaded();
        return {
          result: context.serializeToBidiValue(1)
        };
      }
      process_browsingContext_navigate(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.navigate(params.url, params.wait === void 0 ? "none" : params.wait);
      }
      async process_browsingContext_captureScreenshot(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.captureScreenshot();
      }
      async process_browsingContext_print(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.print(params);
      }
      async process_script_addPreloadScript(params) {
        const contexts = [];
        const scripts = [];
        if (params.context) {
          contexts.push(this.#browsingContextStorage.getContext(params.context));
        } else {
          contexts.push(...this.#browsingContextStorage.getAllContexts());
        }
        scripts.push(...await Promise.all(contexts.map((context) => context.addPreloadScript(params))));
        return scripts[0];
      }
      // eslint-disable-next-line @typescript-eslint/require-await
      async process_script_removePreloadScript(_params) {
        throw new protocol_js_1.Message.UnknownErrorException("Not implemented.");
        return {};
      }
      async process_script_evaluate(params) {
        const realm = await this.#getRealm(params.target);
        return realm.scriptEvaluate(params.expression, params.awaitPromise, params.resultOwnership ?? "none");
      }
      process_script_getRealms(params) {
        if (params.context !== void 0) {
          this.#browsingContextStorage.getContext(params.context);
        }
        const realms = this.#realmStorage.findRealms({
          browsingContextId: params.context,
          type: params.type
        }).map((realm) => realm.toBiDi());
        return { result: { realms } };
      }
      async process_script_callFunction(params) {
        const realm = await this.#getRealm(params.target);
        return realm.callFunction(
          params.functionDeclaration,
          params.this || {
            type: "undefined"
          },
          // `this` is `undefined` by default.
          params.arguments || [],
          // `arguments` is `[]` by default.
          params.awaitPromise,
          params.resultOwnership ?? "none"
        );
      }
      async process_script_disown(params) {
        const realm = await this.#getRealm(params.target);
        await Promise.all(params.handles.map(async (h) => realm.disown(h)));
        return { result: {} };
      }
      async process_browsingContext_close(commandParams) {
        const browserCdpClient = this.#cdpConnection.browserClient();
        const context = this.#browsingContextStorage.getContext(commandParams.context);
        if (!context.isTopLevelContext()) {
          throw new protocol_js_1.Message.InvalidArgumentException("A top-level browsing context cannot be closed.");
        }
        const detachedFromTargetPromise = new Promise((resolve) => {
          const onContextDestroyed = (eventParams) => {
            if (eventParams.targetId === commandParams.context) {
              browserCdpClient.off("Target.detachedFromTarget", onContextDestroyed);
              resolve();
            }
          };
          browserCdpClient.on("Target.detachedFromTarget", onContextDestroyed);
        });
        await browserCdpClient.sendCommand("Target.closeTarget", {
          targetId: commandParams.context
        });
        await detachedFromTargetPromise;
        return { result: {} };
      }
      #isValidTarget(target) {
        if (target.targetId === this.#selfTargetId) {
          return false;
        }
        return ["page", "iframe"].includes(target.type);
      }
      async process_cdp_sendCommand(params) {
        const client = params.cdpSession ? this.#cdpConnection.getCdpClient(params.cdpSession) : this.#cdpConnection.browserClient();
        const sendCdpCommandResult = await client.sendCommand(params.cdpMethod, params.cdpParams);
        return {
          result: sendCdpCommandResult,
          cdpSession: params.cdpSession
        };
      }
      process_cdp_getSession(params) {
        const context = params.context;
        const sessionId = this.#browsingContextStorage.getContext(context).cdpTarget.cdpSessionId;
        if (sessionId === void 0) {
          return { result: { cdpSession: null } };
        }
        return { result: { cdpSession: sessionId } };
      }
    };
    exports2.BrowsingContextProcessor = BrowsingContextProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingBidiMessage.js
var require_OutgoingBidiMessage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingBidiMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OutgoingBidiMessage = void 0;
    var OutgoingBidiMessage = class {
      #message;
      #channel;
      constructor(message, channel) {
        this.#message = message;
        this.#channel = channel;
      }
      static async createFromPromise(messagePromise, channel) {
        return messagePromise.then((message) => new OutgoingBidiMessage(message, channel));
      }
      static createResolved(message, channel) {
        return Promise.resolve(new OutgoingBidiMessage(message, channel));
      }
      get message() {
        return this.#message;
      }
      get channel() {
        return this.#channel;
      }
    };
    exports2.OutgoingBidiMessage = OutgoingBidiMessage;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js
var require_CommandProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var EventEmitter_js_1 = require_EventEmitter2();
    var browsingContextProcessor_js_1 = require_browsingContextProcessor();
    var OutgoingBidiMessage_js_1 = require_OutgoingBidiMessage();
    var BidiNoOpParser = class {
      parseAddPreloadScriptParams(params) {
        return params;
      }
      parseRemovePreloadScriptParams(params) {
        return params;
      }
      parseGetRealmsParams(params) {
        return params;
      }
      parseCallFunctionParams(params) {
        return params;
      }
      parseEvaluateParams(params) {
        return params;
      }
      parseDisownParams(params) {
        return params;
      }
      parseSendCommandParams(params) {
        return params;
      }
      parseGetSessionParams(params) {
        return params;
      }
      parseSubscribeParams(params) {
        return params;
      }
      parseNavigateParams(params) {
        return params;
      }
      parseGetTreeParams(params) {
        return params;
      }
      parseCreateParams(params) {
        return params;
      }
      parseCloseParams(params) {
        return params;
      }
      parseCaptureScreenshotParams(params) {
        return params;
      }
      parsePrintParams(params) {
        return params;
      }
    };
    var _contextProcessor, _eventManager, _parser, _logger, _process_session_status, process_session_status_fn, _process_session_subscribe, process_session_subscribe_fn, _process_session_unsubscribe, process_session_unsubscribe_fn, _processCommand, processCommand_fn;
    var _CommandProcessor = class extends EventEmitter_js_1.EventEmitter {
      constructor(realmStorage, cdpConnection, eventManager, selfTargetId, parser = new BidiNoOpParser(), browsingContextStorage, logger) {
        super();
        __privateAdd(this, _process_session_subscribe);
        __privateAdd(this, _process_session_unsubscribe);
        __privateAdd(this, _processCommand);
        __privateAdd(this, _contextProcessor, void 0);
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _parser, void 0);
        __privateAdd(this, _logger, void 0);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _logger, logger);
        __privateSet(this, _contextProcessor, new browsingContextProcessor_js_1.BrowsingContextProcessor(realmStorage, cdpConnection, selfTargetId, eventManager, browsingContextStorage, logger));
        __privateSet(this, _parser, parser);
      }
      async processCommand(command) {
        var _a;
        try {
          const result = await __privateMethod(this, _processCommand, processCommand_fn).call(this, command);
          const response = {
            id: command.id,
            ...result
          };
          this.emit("response", OutgoingBidiMessage_js_1.OutgoingBidiMessage.createResolved(response, command.channel ?? null));
        } catch (e) {
          if (e instanceof protocol_js_1.Message.ErrorResponse) {
            const errorResponse = e;
            this.emit("response", OutgoingBidiMessage_js_1.OutgoingBidiMessage.createResolved(errorResponse.toErrorResponse(command.id), command.channel ?? null));
          } else {
            const error = e;
            (_a = __privateGet(this, _logger)) == null ? void 0 : _a.call(this, log_js_1.LogType.bidi, error);
            this.emit("response", OutgoingBidiMessage_js_1.OutgoingBidiMessage.createResolved(new protocol_js_1.Message.ErrorResponse(protocol_js_1.Message.ErrorCode.UnknownError, error.message).toErrorResponse(command.id), command.channel ?? null));
          }
        }
      }
    };
    var CommandProcessor = _CommandProcessor;
    _contextProcessor = new WeakMap();
    _eventManager = new WeakMap();
    _parser = new WeakMap();
    _logger = new WeakMap();
    _process_session_status = new WeakSet();
    process_session_status_fn = function() {
      return { result: { ready: false, message: "already connected" } };
    };
    _process_session_subscribe = new WeakSet();
    process_session_subscribe_fn = async function(params, channel) {
      await __privateGet(this, _eventManager).subscribe(params.events, params.contexts ?? [null], channel);
      return { result: {} };
    };
    _process_session_unsubscribe = new WeakSet();
    process_session_unsubscribe_fn = async function(params, channel) {
      await __privateGet(this, _eventManager).unsubscribe(params.events, params.contexts ?? [null], channel);
      return { result: {} };
    };
    _processCommand = new WeakSet();
    processCommand_fn = async function(commandData) {
      var _a;
      switch (commandData.method) {
        case "session.status":
          return __privateMethod(_a = _CommandProcessor, _process_session_status, process_session_status_fn).call(_a);
        case "session.subscribe":
          return __privateMethod(this, _process_session_subscribe, process_session_subscribe_fn).call(this, __privateGet(this, _parser).parseSubscribeParams(commandData.params), commandData.channel ?? null);
        case "session.unsubscribe":
          return __privateMethod(this, _process_session_unsubscribe, process_session_unsubscribe_fn).call(this, __privateGet(this, _parser).parseSubscribeParams(commandData.params), commandData.channel ?? null);
        case "browsingContext.create":
          return __privateGet(this, _contextProcessor).process_browsingContext_create(__privateGet(this, _parser).parseCreateParams(commandData.params));
        case "browsingContext.close":
          return __privateGet(this, _contextProcessor).process_browsingContext_close(__privateGet(this, _parser).parseCloseParams(commandData.params));
        case "browsingContext.getTree":
          return __privateGet(this, _contextProcessor).process_browsingContext_getTree(__privateGet(this, _parser).parseGetTreeParams(commandData.params));
        case "browsingContext.navigate":
          return __privateGet(this, _contextProcessor).process_browsingContext_navigate(__privateGet(this, _parser).parseNavigateParams(commandData.params));
        case "browsingContext.captureScreenshot":
          return __privateGet(this, _contextProcessor).process_browsingContext_captureScreenshot(__privateGet(this, _parser).parseCaptureScreenshotParams(commandData.params));
        case "browsingContext.print":
          return __privateGet(this, _contextProcessor).process_browsingContext_print(__privateGet(this, _parser).parsePrintParams(commandData.params));
        case "script.addPreloadScript":
          return __privateGet(this, _contextProcessor).process_script_addPreloadScript(__privateGet(this, _parser).parseAddPreloadScriptParams(commandData.params));
        case "script.removePreloadScript":
          return __privateGet(this, _contextProcessor).process_script_removePreloadScript(__privateGet(this, _parser).parseRemovePreloadScriptParams(commandData.params));
        case "script.getRealms":
          return __privateGet(this, _contextProcessor).process_script_getRealms(__privateGet(this, _parser).parseGetRealmsParams(commandData.params));
        case "script.callFunction":
          return __privateGet(this, _contextProcessor).process_script_callFunction(__privateGet(this, _parser).parseCallFunctionParams(commandData.params));
        case "script.evaluate":
          return __privateGet(this, _contextProcessor).process_script_evaluate(__privateGet(this, _parser).parseEvaluateParams(commandData.params));
        case "script.disown":
          return __privateGet(this, _contextProcessor).process_script_disown(__privateGet(this, _parser).parseDisownParams(commandData.params));
        case "cdp.sendCommand":
          return __privateGet(this, _contextProcessor).process_cdp_sendCommand(__privateGet(this, _parser).parseSendCommandParams(commandData.params));
        case "cdp.getSession":
          return __privateGet(this, _contextProcessor).process_cdp_getSession(__privateGet(this, _parser).parseGetSessionParams(commandData.params));
        default:
          throw new protocol_js_1.Message.UnknownCommandException(`Unknown command '${commandData.method}'.`);
      }
    };
    __privateAdd(CommandProcessor, _process_session_status);
    exports2.CommandProcessor = CommandProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextStorage.js
var require_browsingContextStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/browsingContextStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrowsingContextStorage = void 0;
    var protocol_js_1 = require_protocol();
    var BrowsingContextStorage = class {
      /** Map from context ID to context implementation. */
      #contexts = /* @__PURE__ */ new Map();
      /** Gets all top-level contexts, i.e. those with no parent. */
      getTopLevelContexts() {
        return this.getAllContexts().filter((c) => c.isTopLevelContext());
      }
      /** Gets all contexts. */
      getAllContexts() {
        return Array.from(this.#contexts.values());
      }
      /** Deletes the context with the given ID. */
      deleteContext(contextId) {
        this.#contexts.delete(contextId);
      }
      /** Adds the given context. */
      addContext(context) {
        this.#contexts.set(context.contextId, context);
        if (!context.isTopLevelContext()) {
          this.getContext(context.parentId).addChild(context);
        }
      }
      /** Returns true whether there is an existing context with the given ID. */
      hasContext(contextId) {
        return this.#contexts.has(contextId);
      }
      /** Gets the context with the given ID, if any. */
      findContext(contextId) {
        return this.#contexts.get(contextId);
      }
      /** Returns the top-level context ID of the given context, if any. */
      findTopLevelContextId(contextId) {
        if (contextId === null) {
          return null;
        }
        const maybeContext = this.findContext(contextId);
        const parentId = maybeContext?.parentId ?? null;
        if (parentId === null) {
          return contextId;
        }
        return this.findTopLevelContextId(parentId);
      }
      /** Gets the context with the given ID, if any, otherwise throws. */
      getContext(contextId) {
        const result = this.findContext(contextId);
        if (result === void 0) {
          throw new protocol_js_1.Message.NoSuchFrameException(`Context ${contextId} not found`);
        }
        return result;
      }
    };
    exports2.BrowsingContextStorage = BrowsingContextStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/buffer.js
var require_buffer = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var Buffer2 = class {
      #capacity;
      #entries = [];
      #onItemRemoved;
      /**
       * @param capacity
       * @param onItemRemoved optional delegate called for each removed element.
       */
      constructor(capacity, onItemRemoved = () => {
      }) {
        this.#capacity = capacity;
        this.#onItemRemoved = onItemRemoved;
      }
      get() {
        return this.#entries;
      }
      add(value) {
        this.#entries.push(value);
        while (this.#entries.length > this.#capacity) {
          const item = this.#entries.shift();
          if (item !== void 0) {
            this.#onItemRemoved(item);
          }
        }
      }
    };
    exports2.Buffer = Buffer2;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/idWrapper.js
var require_idWrapper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/idWrapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdWrapper = void 0;
    var _counter, _id;
    var _IdWrapper = class {
      constructor() {
        __privateAdd(this, _id, void 0);
        __privateSet(this, _id, ++__privateWrapper(_IdWrapper, _counter)._);
      }
      get id() {
        return __privateGet(this, _id);
      }
    };
    var IdWrapper = _IdWrapper;
    _counter = new WeakMap();
    _id = new WeakMap();
    __privateAdd(IdWrapper, _counter, 0);
    exports2.IdWrapper = IdWrapper;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/SubscriptionManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubscriptionManager = exports2.unrollEvents = exports2.cartesianProduct = void 0;
    var protocol_js_1 = require_protocol();
    function cartesianProduct(...a) {
      return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
    }
    exports2.cartesianProduct = cartesianProduct;
    function unrollEvents(events) {
      const allEvents = [];
      for (const event of events) {
        switch (event) {
          case protocol_js_1.BrowsingContext.AllEvents:
            allEvents.push(...Object.values(protocol_js_1.BrowsingContext.EventNames));
            break;
          case protocol_js_1.CDP.AllEvents:
            allEvents.push(...Object.values(protocol_js_1.CDP.EventNames));
            break;
          case protocol_js_1.Log.AllEvents:
            allEvents.push(...Object.values(protocol_js_1.Log.EventNames));
            break;
          case protocol_js_1.Network.AllEvents:
            allEvents.push(...Object.values(protocol_js_1.Network.EventNames));
            break;
          case protocol_js_1.Script.AllEvents:
            allEvents.push(...Object.values(protocol_js_1.Script.EventNames));
            break;
          default:
            allEvents.push(event);
        }
      }
      return allEvents;
    }
    exports2.unrollEvents = unrollEvents;
    var SubscriptionManager = class {
      #subscriptionPriority = 0;
      // BrowsingContext `null` means the event has subscription across all the
      // browsing contexts.
      // Channel `null` means no `channel` should be added.
      #channelToContextToEventMap = /* @__PURE__ */ new Map();
      #browsingContextStorage;
      constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
      }
      getChannelsSubscribedToEvent(eventMethod, contextId) {
        const prioritiesAndChannels = Array.from(this.#channelToContextToEventMap.keys()).map((channel) => ({
          priority: this.#getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel),
          channel
        })).filter(({ priority }) => priority !== null);
        return prioritiesAndChannels.sort((a, b) => a.priority - b.priority).map(({ channel }) => channel);
      }
      #getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel) {
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (contextToEventMap === void 0) {
          return null;
        }
        const maybeTopLevelContextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        const relevantContexts = [.../* @__PURE__ */ new Set([null, maybeTopLevelContextId])];
        const priorities = relevantContexts.map((c) => contextToEventMap.get(c)?.get(eventMethod)).filter((p) => p !== void 0);
        if (priorities.length === 0) {
          return null;
        }
        return Math.min(...priorities);
      }
      subscribe(event, contextId, channel) {
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        if (event === protocol_js_1.BrowsingContext.AllEvents) {
          Object.values(protocol_js_1.BrowsingContext.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
          return;
        }
        if (event === protocol_js_1.CDP.AllEvents) {
          Object.values(protocol_js_1.CDP.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
          return;
        }
        if (event === protocol_js_1.Log.AllEvents) {
          Object.values(protocol_js_1.Log.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
          return;
        }
        if (event === protocol_js_1.Network.AllEvents) {
          Object.values(protocol_js_1.Network.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
          return;
        }
        if (event === protocol_js_1.Script.AllEvents) {
          Object.values(protocol_js_1.Script.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
          return;
        }
        if (!this.#channelToContextToEventMap.has(channel)) {
          this.#channelToContextToEventMap.set(channel, /* @__PURE__ */ new Map());
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
          contextToEventMap.set(contextId, /* @__PURE__ */ new Map());
        }
        const eventMap = contextToEventMap.get(contextId);
        if (eventMap.has(event)) {
          return;
        }
        eventMap.set(event, this.#subscriptionPriority++);
      }
      /**
       * Unsubscribes atomically from all events in the given contexts and channel.
       */
      unsubscribeAll(events, contextIds, channel) {
        for (const contextId of contextIds) {
          if (contextId !== null) {
            this.#browsingContextStorage.getContext(contextId);
          }
        }
        const eventContextPairs = cartesianProduct(unrollEvents(events), contextIds);
        eventContextPairs.map(([event, contextId]) => this.#checkUnsubscribe(event, contextId, channel)).forEach((unsubscribe) => unsubscribe());
      }
      /**
       * Unsubscribes from the event in the given context and channel.
       * Syntactic sugar for "unsubscribeAll".
       */
      unsubscribe(eventName, contextId, channel) {
        this.unsubscribeAll([eventName], [contextId], channel);
      }
      #checkUnsubscribe(event, contextId, channel) {
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        if (!this.#channelToContextToEventMap.has(channel)) {
          throw new protocol_js_1.Message.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
          throw new protocol_js_1.Message.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
        }
        const eventMap = contextToEventMap.get(contextId);
        if (!eventMap.has(event)) {
          throw new protocol_js_1.Message.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
        }
        return () => {
          eventMap.delete(event);
          if (eventMap.size === 0) {
            contextToEventMap.delete(event);
          }
          if (contextToEventMap.size === 0) {
            this.#channelToContextToEventMap.delete(channel);
          }
        };
      }
    };
    exports2.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/EventManager.js
var require_EventManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/EventManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var protocol_js_1 = require_protocol();
    var buffer_js_1 = require_buffer();
    var idWrapper_js_1 = require_idWrapper();
    var OutgoingBidiMessage_js_1 = require_OutgoingBidiMessage();
    var DefaultMap_js_1 = require_DefaultMap();
    var SubscriptionManager_js_1 = require_SubscriptionManager();
    var EventWrapper = class {
      #idWrapper;
      #contextId;
      #event;
      constructor(event, contextId) {
        this.#idWrapper = new idWrapper_js_1.IdWrapper();
        this.#contextId = contextId;
        this.#event = event;
      }
      get id() {
        return this.#idWrapper.id;
      }
      get contextId() {
        return this.#contextId;
      }
      get event() {
        return this.#event;
      }
    };
    var eventBufferLength = /* @__PURE__ */ new Map([
      [protocol_js_1.Log.EventNames.LogEntryAddedEvent, 100]
    ]);
    var _NETWORK_DOMAIN_PREFIX, _eventToContextsMap, _eventBuffers, _lastMessageSent, _subscriptionManager, _bidiServer, _isNetworkDomainEnabled, _getMapKey, getMapKey_fn, _handleDomains, handleDomains_fn, _bufferEvent, bufferEvent_fn, _markEventSent, markEventSent_fn, _getBufferedEvents, getBufferedEvents_fn;
    var _EventManager = class {
      constructor(bidiServer) {
        /**
         * Enables domains for the subscribed event in the required contexts or
         * globally.
         */
        __privateAdd(this, _handleDomains);
        /**
         * If the event is buffer-able, put it in the buffer.
         */
        __privateAdd(this, _bufferEvent);
        /**
         * If the event is buffer-able, mark it as sent to the given contextId and channel.
         */
        __privateAdd(this, _markEventSent);
        /**
         * Returns events which are buffered and not yet sent to the given channel events.
         */
        __privateAdd(this, _getBufferedEvents);
        /**
         * Maps event name to a set of contexts where this event already happened.
         * Needed for getting buffered events from all the contexts in case of
         * subscripting to all contexts.
         */
        __privateAdd(this, _eventToContextsMap, new DefaultMap_js_1.DefaultMap(() => /* @__PURE__ */ new Set()));
        /**
         * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
         * during subscription. Channel-agnostic.
         */
        __privateAdd(this, _eventBuffers, /* @__PURE__ */ new Map());
        /**
         * Maps `eventName` + `browsingContext` + `channel` to last sent event id.
         * Used to avoid sending duplicated events when user
         * subscribes -> unsubscribes -> subscribes.
         */
        __privateAdd(this, _lastMessageSent, /* @__PURE__ */ new Map());
        __privateAdd(this, _subscriptionManager, void 0);
        __privateAdd(this, _bidiServer, void 0);
        __privateAdd(this, _isNetworkDomainEnabled, void 0);
        __privateSet(this, _bidiServer, bidiServer);
        __privateSet(this, _subscriptionManager, new SubscriptionManager_js_1.SubscriptionManager(bidiServer.getBrowsingContextStorage()));
        __privateSet(this, _isNetworkDomainEnabled, false);
      }
      get isNetworkDomainEnabled() {
        return __privateGet(this, _isNetworkDomainEnabled);
      }
      registerEvent(event, contextId) {
        this.registerPromiseEvent(Promise.resolve(event), contextId, event.method);
      }
      registerPromiseEvent(event, contextId, eventName) {
        const eventWrapper = new EventWrapper(event, contextId);
        const sortedChannels = __privateGet(this, _subscriptionManager).getChannelsSubscribedToEvent(eventName, contextId);
        __privateMethod(this, _bufferEvent, bufferEvent_fn).call(this, eventWrapper, eventName);
        for (const channel of sortedChannels) {
          __privateGet(this, _bidiServer).emitOutgoingMessage(OutgoingBidiMessage_js_1.OutgoingBidiMessage.createFromPromise(event, channel));
          __privateMethod(this, _markEventSent, markEventSent_fn).call(this, eventWrapper, channel, eventName);
        }
      }
      async subscribe(eventNames, contextIds, channel) {
        for (const contextId of contextIds) {
          if (contextId !== null) {
            __privateGet(this, _bidiServer).getBrowsingContextStorage().getContext(contextId);
          }
        }
        for (const eventName of eventNames) {
          for (const contextId of contextIds) {
            await __privateMethod(this, _handleDomains, handleDomains_fn).call(this, eventName, contextId);
            __privateGet(this, _subscriptionManager).subscribe(eventName, contextId, channel);
            for (const eventWrapper of __privateMethod(this, _getBufferedEvents, getBufferedEvents_fn).call(this, eventName, contextId, channel)) {
              __privateGet(this, _bidiServer).emitOutgoingMessage(OutgoingBidiMessage_js_1.OutgoingBidiMessage.createFromPromise(eventWrapper.event, channel));
              __privateMethod(this, _markEventSent, markEventSent_fn).call(this, eventWrapper, channel, eventName);
            }
          }
        }
      }
      unsubscribe(eventNames, contextIds, channel) {
        __privateGet(this, _subscriptionManager).unsubscribeAll(eventNames, contextIds, channel);
      }
    };
    var EventManager = _EventManager;
    _NETWORK_DOMAIN_PREFIX = new WeakMap();
    _eventToContextsMap = new WeakMap();
    _eventBuffers = new WeakMap();
    _lastMessageSent = new WeakMap();
    _subscriptionManager = new WeakMap();
    _bidiServer = new WeakMap();
    _isNetworkDomainEnabled = new WeakMap();
    _getMapKey = new WeakSet();
    getMapKey_fn = function(eventName, browsingContext, channel) {
      return JSON.stringify({ eventName, browsingContext, channel });
    };
    _handleDomains = new WeakSet();
    handleDomains_fn = async function(eventName, contextId) {
      if (eventName.startsWith(__privateGet(_EventManager, _NETWORK_DOMAIN_PREFIX))) {
        if (contextId === null) {
          __privateSet(this, _isNetworkDomainEnabled, true);
          await Promise.all(__privateGet(this, _bidiServer).getBrowsingContextStorage().getAllContexts().map((context) => context.cdpTarget.enableNetworkDomain()));
        } else {
          await __privateGet(this, _bidiServer).getBrowsingContextStorage().getContext(contextId).cdpTarget.enableNetworkDomain();
        }
      }
    };
    _bufferEvent = new WeakSet();
    bufferEvent_fn = function(eventWrapper, eventName) {
      var _a;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const bufferMapKey = __privateMethod(_a = _EventManager, _getMapKey, getMapKey_fn).call(_a, eventName, eventWrapper.contextId);
      if (!__privateGet(this, _eventBuffers).has(bufferMapKey)) {
        __privateGet(this, _eventBuffers).set(bufferMapKey, new buffer_js_1.Buffer(eventBufferLength.get(eventName)));
      }
      __privateGet(this, _eventBuffers).get(bufferMapKey).add(eventWrapper);
      __privateGet(this, _eventToContextsMap).get(eventName).add(eventWrapper.contextId);
    };
    _markEventSent = new WeakSet();
    markEventSent_fn = function(eventWrapper, channel, eventName) {
      var _a;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const lastSentMapKey = __privateMethod(_a = _EventManager, _getMapKey, getMapKey_fn).call(_a, eventName, eventWrapper.contextId, channel);
      __privateGet(this, _lastMessageSent).set(lastSentMapKey, Math.max(__privateGet(this, _lastMessageSent).get(lastSentMapKey) ?? 0, eventWrapper.id));
    };
    _getBufferedEvents = new WeakSet();
    getBufferedEvents_fn = function(eventName, contextId, channel) {
      var _a, _b;
      const bufferMapKey = __privateMethod(_a = _EventManager, _getMapKey, getMapKey_fn).call(_a, eventName, contextId);
      const lastSentMapKey = __privateMethod(_b = _EventManager, _getMapKey, getMapKey_fn).call(_b, eventName, contextId, channel);
      const lastSentMessageId = __privateGet(this, _lastMessageSent).get(lastSentMapKey) ?? -Infinity;
      const result = __privateGet(this, _eventBuffers).get(bufferMapKey)?.get().filter((wrapper) => wrapper.id > lastSentMessageId) ?? [];
      if (contextId === null) {
        Array.from(__privateGet(this, _eventToContextsMap).get(eventName).keys()).filter((_contextId) => (
          // Events without context are already in the result.
          _contextId !== null && // Events from deleted contexts should not be sent.
          __privateGet(this, _bidiServer).getBrowsingContextStorage().hasContext(_contextId)
        )).map((_contextId) => __privateMethod(this, _getBufferedEvents, getBufferedEvents_fn).call(this, eventName, _contextId, channel)).forEach((events) => result.push(...events));
      }
      return result.sort((e1, e2) => e1.id - e2.id);
    };
    /**
     * Returns consistent key to be used to access value maps.
     */
    __privateAdd(EventManager, _getMapKey);
    __privateAdd(EventManager, _NETWORK_DOMAIN_PREFIX, "network");
    exports2.EventManager = EventManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/realmStorage.js
var require_realmStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/realmStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RealmStorage = void 0;
    var protocol_js_1 = require_protocol();
    var RealmStorage = class {
      /** Tracks handles and their realms sent to the client. */
      #knownHandlesToRealm = /* @__PURE__ */ new Map();
      /** Map from realm ID to Realm. */
      #realmMap = /* @__PURE__ */ new Map();
      get knownHandlesToRealm() {
        return this.#knownHandlesToRealm;
      }
      get realmMap() {
        return this.#realmMap;
      }
      findRealms(filter) {
        return Array.from(this.#realmMap.values()).filter((realm) => {
          if (filter.realmId !== void 0 && filter.realmId !== realm.realmId) {
            return false;
          }
          if (filter.browsingContextId !== void 0 && filter.browsingContextId !== realm.browsingContextId) {
            return false;
          }
          if (filter.navigableId !== void 0 && filter.navigableId !== realm.navigableId) {
            return false;
          }
          if (filter.executionContextId !== void 0 && filter.executionContextId !== realm.executionContextId) {
            return false;
          }
          if (filter.origin !== void 0 && filter.origin !== realm.origin) {
            return false;
          }
          if (filter.type !== void 0 && filter.type !== realm.type) {
            return false;
          }
          if (filter.sandbox !== void 0 && filter.sandbox !== realm.sandbox) {
            return false;
          }
          if (filter.cdpSessionId !== void 0 && filter.cdpSessionId !== realm.cdpSessionId) {
            return false;
          }
          return true;
        });
      }
      findRealm(filter) {
        const maybeRealms = this.findRealms(filter);
        if (maybeRealms.length !== 1) {
          return void 0;
        }
        return maybeRealms[0];
      }
      getRealm(filter) {
        const maybeRealm = this.findRealm(filter);
        if (maybeRealm === void 0) {
          throw new protocol_js_1.Message.NoSuchFrameException(`Realm ${JSON.stringify(filter)} not found`);
        }
        return maybeRealm;
      }
      deleteRealms(filter) {
        this.findRealms(filter).map((realm) => {
          this.#realmMap.delete(realm.realmId);
          Array.from(this.#knownHandlesToRealm.entries()).filter(([, r]) => r === realm.realmId).map(([h]) => this.#knownHandlesToRealm.delete(h));
        });
      }
    };
    exports2.RealmStorage = RealmStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js
var require_BidiServer = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BidiServer = void 0;
    var EventEmitter_js_1 = require_EventEmitter2();
    var processingQueue_js_1 = require_processingQueue();
    var CommandProcessor_js_1 = require_CommandProcessor();
    var browsingContextStorage_js_1 = require_browsingContextStorage();
    var EventManager_js_1 = require_EventManager();
    var realmStorage_js_1 = require_realmStorage();
    var BidiServer = class extends EventEmitter_js_1.EventEmitter {
      #messageQueue;
      #transport;
      #commandProcessor;
      #browsingContextStorage;
      #realmStorage;
      #logger;
      #handleIncomingMessage = (message) => {
        this.#commandProcessor.processCommand(message);
      };
      #processOutgoingMessage = async (messageEntry) => {
        const message = messageEntry.message;
        if (messageEntry.channel !== null) {
          message["channel"] = messageEntry.channel;
        }
        await this.#transport.sendMessage(message);
      };
      constructor(bidiTransport, cdpConnection, selfTargetId, parser, logger) {
        super();
        this.#logger = logger;
        this.#browsingContextStorage = new browsingContextStorage_js_1.BrowsingContextStorage();
        this.#realmStorage = new realmStorage_js_1.RealmStorage();
        this.#messageQueue = new processingQueue_js_1.ProcessingQueue(this.#processOutgoingMessage, () => Promise.resolve(), this.#logger);
        this.#transport = bidiTransport;
        this.#transport.setOnMessage(this.#handleIncomingMessage);
        this.#commandProcessor = new CommandProcessor_js_1.CommandProcessor(this.#realmStorage, cdpConnection, new EventManager_js_1.EventManager(this), selfTargetId, parser, this.#browsingContextStorage, this.#logger);
        this.#commandProcessor.on("response", (response) => {
          this.emitOutgoingMessage(response);
        });
      }
      static async createAndStart(bidiTransport, cdpConnection, selfTargetId, parser, logger) {
        const server = new BidiServer(bidiTransport, cdpConnection, selfTargetId, parser, logger);
        const cdpClient = cdpConnection.browserClient();
        await cdpClient.sendCommand("Target.setDiscoverTargets", { discover: true });
        await cdpClient.sendCommand("Target.setAutoAttach", {
          autoAttach: true,
          waitForDebuggerOnStart: true,
          flatten: true
        });
        await server.topLevelContextsLoaded();
        return server;
      }
      async topLevelContextsLoaded() {
        await Promise.all(this.#browsingContextStorage.getTopLevelContexts().map((c) => c.awaitLoaded()));
      }
      /**
       * Sends BiDi message.
       */
      emitOutgoingMessage(messageEntry) {
        this.#messageQueue.add(messageEntry);
      }
      close() {
        this.#transport.close();
      }
      getBrowsingContextStorage() {
        return this.#browsingContextStorage;
      }
    };
    exports2.BidiServer = BidiServer;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/bidiMapper.js
var require_bidiMapper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/bidiMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventEmitter = exports2.BidiServer = void 0;
    var BidiServer_js_1 = require_BidiServer();
    Object.defineProperty(exports2, "BidiServer", { enumerable: true, get: function() {
      return BidiServer_js_1.BidiServer;
    } });
    var EventEmitter_js_1 = require_EventEmitter2();
    Object.defineProperty(exports2, "EventEmitter", { enumerable: true, get: function() {
      return EventEmitter_js_1.EventEmitter;
    } });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/BidiOverCDP.js
var require_BidiOverCDP = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/BidiOverCDP.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _CDPConnectionAdapter_cdp;
    var _CDPConnectionAdapter_adapters;
    var _CDPConnectionAdapter_browser;
    var _CDPClientAdapter_closed;
    var _CDPClientAdapter_client;
    var _CDPClientAdapter_forwardMessage;
    var _NoOpTransport_onMessage;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectBidiOverCDP = void 0;
    var BidiMapper = __importStar(require_bidiMapper());
    var Connection_js_1 = require_Connection2();
    async function connectBidiOverCDP(cdp) {
      const transportBiDi = new NoOpTransport();
      const cdpConnectionAdapter = new CDPConnectionAdapter(cdp);
      const pptrTransport = {
        send(message) {
          transportBiDi.emitMessage(JSON.parse(message));
        },
        close() {
          bidiServer.close();
          cdpConnectionAdapter.close();
        },
        onmessage(_message) {
        }
      };
      transportBiDi.on("bidiResponse", (message) => {
        pptrTransport.onmessage(JSON.stringify(message));
      });
      const pptrBiDiConnection = new Connection_js_1.Connection(pptrTransport);
      const bidiServer = await BidiMapper.BidiServer.createAndStart(transportBiDi, cdpConnectionAdapter, "");
      return pptrBiDiConnection;
    }
    exports2.connectBidiOverCDP = connectBidiOverCDP;
    var CDPConnectionAdapter = class {
      constructor(cdp) {
        _CDPConnectionAdapter_cdp.set(this, void 0);
        _CDPConnectionAdapter_adapters.set(this, /* @__PURE__ */ new Map());
        _CDPConnectionAdapter_browser.set(this, void 0);
        __classPrivateFieldSet(this, _CDPConnectionAdapter_cdp, cdp, "f");
        __classPrivateFieldSet(this, _CDPConnectionAdapter_browser, new CDPClientAdapter(cdp), "f");
      }
      browserClient() {
        return __classPrivateFieldGet(this, _CDPConnectionAdapter_browser, "f");
      }
      getCdpClient(id) {
        const session = __classPrivateFieldGet(this, _CDPConnectionAdapter_cdp, "f").session(id);
        if (!session) {
          throw new Error("Unknown CDP session with id" + id);
        }
        if (!__classPrivateFieldGet(this, _CDPConnectionAdapter_adapters, "f").has(session)) {
          const adapter = new CDPClientAdapter(session);
          __classPrivateFieldGet(this, _CDPConnectionAdapter_adapters, "f").set(session, adapter);
          return adapter;
        }
        return __classPrivateFieldGet(this, _CDPConnectionAdapter_adapters, "f").get(session);
      }
      close() {
        __classPrivateFieldGet(this, _CDPConnectionAdapter_browser, "f").close();
        for (const adapter of __classPrivateFieldGet(this, _CDPConnectionAdapter_adapters, "f").values()) {
          adapter.close();
        }
      }
    };
    _CDPConnectionAdapter_cdp = /* @__PURE__ */ new WeakMap(), _CDPConnectionAdapter_adapters = /* @__PURE__ */ new WeakMap(), _CDPConnectionAdapter_browser = /* @__PURE__ */ new WeakMap();
    var CDPClientAdapter = class extends BidiMapper.EventEmitter {
      constructor(client) {
        super();
        _CDPClientAdapter_closed.set(this, false);
        _CDPClientAdapter_client.set(this, void 0);
        _CDPClientAdapter_forwardMessage.set(this, (method, event) => {
          this.emit(method, event);
        });
        __classPrivateFieldSet(this, _CDPClientAdapter_client, client, "f");
        __classPrivateFieldGet(this, _CDPClientAdapter_client, "f").on("*", __classPrivateFieldGet(this, _CDPClientAdapter_forwardMessage, "f"));
      }
      async sendCommand(method, ...params) {
        if (__classPrivateFieldGet(this, _CDPClientAdapter_closed, "f")) {
          return;
        }
        try {
          return await __classPrivateFieldGet(this, _CDPClientAdapter_client, "f").send(method, ...params);
        } catch (err) {
          if (__classPrivateFieldGet(this, _CDPClientAdapter_closed, "f")) {
            return;
          }
          throw err;
        }
      }
      close() {
        __classPrivateFieldGet(this, _CDPClientAdapter_client, "f").off("*", __classPrivateFieldGet(this, _CDPClientAdapter_forwardMessage, "f"));
        __classPrivateFieldSet(this, _CDPClientAdapter_closed, true, "f");
      }
    };
    _CDPClientAdapter_closed = /* @__PURE__ */ new WeakMap(), _CDPClientAdapter_client = /* @__PURE__ */ new WeakMap(), _CDPClientAdapter_forwardMessage = /* @__PURE__ */ new WeakMap();
    var NoOpTransport = class extends BidiMapper.EventEmitter {
      constructor() {
        super(...arguments);
        _NoOpTransport_onMessage.set(this, async (_m) => {
          return;
        });
      }
      emitMessage(message) {
        void __classPrivateFieldGet(this, _NoOpTransport_onMessage, "f").call(this, message);
      }
      setOnMessage(onMessage) {
        __classPrivateFieldSet(this, _NoOpTransport_onMessage, onMessage, "f");
      }
      async sendMessage(message) {
        this.emit("bidiResponse", message);
      }
      close() {
        __classPrivateFieldSet(this, _NoOpTransport_onMessage, async (_m) => {
          return;
        }, "f");
      }
    };
    _NoOpTransport_onMessage = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/bidi.js
var require_bidi = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/common/bidi/bidi.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Browser3(), exports2);
    __exportStar(require_BrowserContext2(), exports2);
    __exportStar(require_Page3(), exports2);
    __exportStar(require_Connection2(), exports2);
    __exportStar(require_BidiOverCDP(), exports2);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/ProductLauncher.js
var require_ProductLauncher = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/ProductLauncher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ProductLauncher_product;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProductLauncher = void 0;
    var fs_1 = require("fs");
    var os_1 = require("os");
    var path_1 = require("path");
    var browsers_1 = require_main();
    var Browser_js_1 = require_Browser2();
    var Connection_js_1 = require_Connection();
    var Errors_js_1 = require_Errors();
    var NodeWebSocketTransport_js_1 = require_NodeWebSocketTransport();
    var util_js_1 = require_util2();
    var PipeTransport_js_1 = require_PipeTransport();
    var ProductLauncher = class {
      /**
       * @internal
       */
      constructor(puppeteer, product) {
        _ProductLauncher_product.set(this, void 0);
        this.puppeteer = puppeteer;
        __classPrivateFieldSet(this, _ProductLauncher_product, product, "f");
      }
      get product() {
        return __classPrivateFieldGet(this, _ProductLauncher_product, "f");
      }
      async launch(options = {}) {
        const { dumpio = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 3e4, waitForInitialPage = true, protocol, protocolTimeout } = options;
        const launchArgs = await this.computeLaunchArguments(options);
        const usePipe = launchArgs.args.includes("--remote-debugging-pipe");
        const onProcessExit = async () => {
          await this.cleanUserDataDir(launchArgs.userDataDir, {
            isTemp: launchArgs.isTempUserDataDir
          });
        };
        const browserProcess = (0, browsers_1.launch)({
          executablePath: launchArgs.executablePath,
          args: launchArgs.args,
          handleSIGHUP,
          handleSIGTERM,
          handleSIGINT,
          dumpio,
          env,
          pipe: usePipe,
          onExit: onProcessExit
        });
        let browser;
        let connection;
        let closing = false;
        const browserCloseCallback = async () => {
          if (closing) {
            return;
          }
          closing = true;
          await this.closeBrowser(browserProcess, connection);
        };
        try {
          if (__classPrivateFieldGet(this, _ProductLauncher_product, "f") === "firefox" && protocol === "webDriverBiDi") {
            browser = await this.createBiDiBrowser(browserProcess, browserCloseCallback, {
              timeout,
              protocolTimeout,
              slowMo,
              defaultViewport
            });
          } else {
            if (usePipe) {
              connection = await this.createCDPPipeConnection(browserProcess, {
                timeout,
                protocolTimeout,
                slowMo
              });
            } else {
              connection = await this.createCDPSocketConnection(browserProcess, {
                timeout,
                protocolTimeout,
                slowMo
              });
            }
            if (protocol === "webDriverBiDi") {
              browser = await this.createBiDiOverCDPBrowser(browserProcess, connection, browserCloseCallback, {
                timeout,
                protocolTimeout,
                slowMo,
                defaultViewport
              });
            } else {
              browser = await Browser_js_1.CDPBrowser._create(this.product, connection, [], ignoreHTTPSErrors, defaultViewport, browserProcess.nodeProcess, browserCloseCallback, options.targetFilter);
            }
          }
        } catch (error) {
          void browserCloseCallback();
          if (error instanceof browsers_1.TimeoutError) {
            throw new Errors_js_1.TimeoutError(error.message);
          }
          throw error;
        }
        if (waitForInitialPage && protocol !== "webDriverBiDi") {
          await this.waitForPageTarget(browser, timeout);
        }
        return browser;
      }
      executablePath() {
        throw new Error("Not implemented");
      }
      defaultArgs() {
        throw new Error("Not implemented");
      }
      /**
       * Set only for Firefox, after the launcher resolves the `latest` revision to
       * the actual revision.
       * @internal
       */
      getActualBrowserRevision() {
        return this.actualBrowserRevision;
      }
      async computeLaunchArguments() {
        throw new Error("Not implemented");
      }
      async cleanUserDataDir() {
        throw new Error("Not implemented");
      }
      /**
       * @internal
       */
      async closeBrowser(browserProcess, connection) {
        if (connection) {
          try {
            await connection.closeBrowser();
            await browserProcess.hasClosed();
          } catch (error) {
            (0, util_js_1.debugError)(error);
            await browserProcess.close();
          }
        } else {
          await browserProcess.close();
        }
      }
      /**
       * @internal
       */
      async waitForPageTarget(browser, timeout) {
        try {
          await browser.waitForTarget((t) => {
            return t.type() === "page";
          }, { timeout });
        } catch (error) {
          await browser.close();
          throw error;
        }
      }
      /**
       * @internal
       */
      async createCDPSocketConnection(browserProcess, opts) {
        const browserWSEndpoint = await browserProcess.waitForLineOutput(browsers_1.CDP_WEBSOCKET_ENDPOINT_REGEX, opts.timeout);
        const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
        return new Connection_js_1.Connection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
      }
      /**
       * @internal
       */
      async createCDPPipeConnection(browserProcess, opts) {
        const { 3: pipeWrite, 4: pipeRead } = browserProcess.nodeProcess.stdio;
        const transport = new PipeTransport_js_1.PipeTransport(pipeWrite, pipeRead);
        return new Connection_js_1.Connection("", transport, opts.slowMo, opts.protocolTimeout);
      }
      /**
       * @internal
       */
      async createBiDiOverCDPBrowser(browserProcess, connection, closeCallback, opts) {
        const BiDi = await Promise.resolve().then(() => __importStar(require_bidi()));
        const bidiConnection = await BiDi.connectBidiOverCDP(connection);
        return await BiDi.Browser.create({
          connection: bidiConnection,
          closeCallback,
          process: browserProcess.nodeProcess,
          defaultViewport: opts.defaultViewport
        });
      }
      /**
       * @internal
       */
      async createBiDiBrowser(browserProcess, closeCallback, opts) {
        const browserWSEndpoint = await browserProcess.waitForLineOutput(browsers_1.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX, opts.timeout) + "/session";
        const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
        const BiDi = await Promise.resolve().then(() => __importStar(require_bidi()));
        const bidiConnection = new BiDi.Connection(transport, opts.slowMo, opts.protocolTimeout);
        return await BiDi.Browser.create({
          connection: bidiConnection,
          closeCallback,
          process: browserProcess.nodeProcess,
          defaultViewport: opts.defaultViewport
        });
      }
      /**
       * @internal
       */
      getProfilePath() {
        var _a;
        return (0, path_1.join)((_a = this.puppeteer.configuration.temporaryDirectory) !== null && _a !== void 0 ? _a : (0, os_1.tmpdir)(), `puppeteer_dev_${this.product}_profile-`);
      }
      /**
       * @internal
       */
      resolveExecutablePath() {
        let executablePath = this.puppeteer.configuration.executablePath;
        if (executablePath) {
          if (!(0, fs_1.existsSync)(executablePath)) {
            throw new Error(`Tried to find the browser at the configured path (${executablePath}), but no executable was found.`);
          }
          return executablePath;
        }
        function productToBrowser(product) {
          switch (product) {
            case "chrome":
              return browsers_1.Browser.CHROME;
            case "firefox":
              return browsers_1.Browser.FIREFOX;
          }
          return browsers_1.Browser.CHROME;
        }
        executablePath = (0, browsers_1.computeExecutablePath)({
          cacheDir: this.puppeteer.defaultDownloadPath,
          browser: productToBrowser(this.product),
          buildId: this.puppeteer.browserRevision
        });
        if (!(0, fs_1.existsSync)(executablePath)) {
          if (this.puppeteer.configuration.browserRevision) {
            throw new Error(`Tried to find the browser at the configured path (${executablePath}) for revision ${this.puppeteer.browserRevision}, but no executable was found.`);
          }
          switch (this.product) {
            case "chrome":
              throw new Error(`Could not find Chrome (ver. ${this.puppeteer.browserRevision}). This can occur if either
 1. you did not perform an installation before running the script (e.g. \`npm install\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
            case "firefox":
              throw new Error(`Could not find Firefox (rev. ${this.puppeteer.browserRevision}). This can occur if either
 1. you did not perform an installation for Firefox before running the script (e.g. \`PUPPETEER_PRODUCT=firefox npm install\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
          }
        }
        return executablePath;
      }
    };
    exports2.ProductLauncher = ProductLauncher;
    _ProductLauncher_product = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/util/fs.js
var require_fs = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/util/fs.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rmSync = exports2.rm = void 0;
    var fs_1 = __importDefault(require("fs"));
    var rmOptions = {
      force: true,
      recursive: true,
      maxRetries: 5
    };
    async function rm(path) {
      await fs_1.default.promises.rm(path, rmOptions);
    }
    exports2.rm = rm;
    function rmSync(path) {
      fs_1.default.rmSync(path, rmOptions);
    }
    exports2.rmSync = rmSync;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/ChromeLauncher.js
var require_ChromeLauncher = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/ChromeLauncher.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChromeLauncher = void 0;
    var promises_1 = require("fs/promises");
    var path_1 = __importDefault(require("path"));
    var browsers_1 = require_main();
    var util_js_1 = require_util2();
    var assert_js_1 = require_assert();
    var ProductLauncher_js_1 = require_ProductLauncher();
    var fs_js_1 = require_fs();
    var ChromeLauncher = class extends ProductLauncher_js_1.ProductLauncher {
      constructor(puppeteer) {
        super(puppeteer, "chrome");
      }
      launch(options = {}) {
        var _a;
        const headless = (_a = options.headless) !== null && _a !== void 0 ? _a : true;
        if (headless === true && (!this.puppeteer.configuration.logLevel || this.puppeteer.configuration.logLevel === "warn") && !Boolean(process.env["PUPPETEER_DISABLE_HEADLESS_WARNING"])) {
          console.warn([
            "\x1B[1m\x1B[43m\x1B[30m",
            "Puppeteer old Headless deprecation warning:\x1B[0m\x1B[33m",
            "  In the near feature `headless: true` will default to the new Headless mode",
            "  for Chrome instead of the old Headless implementation. For more",
            "  information, please see https://developer.chrome.com/articles/new-headless/.",
            '  Consider opting in early by passing `headless: "new"` to `puppeteer.launch()`',
            "  If you encounter any bugs, please report them to https://github.com/puppeteer/puppeteer/issues/new/choose.\x1B[0m\n"
          ].join("\n  "));
        }
        return super.launch(options);
      }
      /**
       * @internal
       */
      async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], pipe = false, debuggingPort, channel, executablePath } = options;
        const chromeArguments = [];
        if (!ignoreDefaultArgs) {
          chromeArguments.push(...this.defaultArgs(options));
        } else if (Array.isArray(ignoreDefaultArgs)) {
          chromeArguments.push(...this.defaultArgs(options).filter((arg) => {
            return !ignoreDefaultArgs.includes(arg);
          }));
        } else {
          chromeArguments.push(...args);
        }
        if (!chromeArguments.some((argument) => {
          return argument.startsWith("--remote-debugging-");
        })) {
          if (pipe) {
            (0, assert_js_1.assert)(!debuggingPort, "Browser should be launched with either pipe or debugging port - not both.");
            chromeArguments.push("--remote-debugging-pipe");
          } else {
            chromeArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
          }
        }
        let isTempUserDataDir = false;
        let userDataDirIndex = chromeArguments.findIndex((arg) => {
          return arg.startsWith("--user-data-dir");
        });
        if (userDataDirIndex < 0) {
          isTempUserDataDir = true;
          chromeArguments.push(`--user-data-dir=${await (0, promises_1.mkdtemp)(this.getProfilePath())}`);
          userDataDirIndex = chromeArguments.length - 1;
        }
        const userDataDir = chromeArguments[userDataDirIndex].split("=", 2)[1];
        (0, assert_js_1.assert)(typeof userDataDir === "string", "`--user-data-dir` is malformed");
        let chromeExecutable = executablePath;
        if (!chromeExecutable) {
          (0, assert_js_1.assert)(channel || !this.puppeteer._isPuppeteerCore, `An \`executablePath\` or \`channel\` must be specified for \`puppeteer-core\``);
          chromeExecutable = this.executablePath(channel);
        }
        return {
          executablePath: chromeExecutable,
          args: chromeArguments,
          isTempUserDataDir,
          userDataDir
        };
      }
      /**
       * @internal
       */
      async cleanUserDataDir(path, opts) {
        if (opts.isTemp) {
          try {
            await (0, fs_js_1.rm)(path);
          } catch (error) {
            (0, util_js_1.debugError)(error);
            throw error;
          }
        }
      }
      defaultArgs(options = {}) {
        const chromeArguments = [
          "--allow-pre-commit-input",
          "--disable-background-networking",
          "--disable-background-timer-throttling",
          "--disable-backgrounding-occluded-windows",
          "--disable-breakpad",
          "--disable-client-side-phishing-detection",
          "--disable-component-extensions-with-background-pages",
          "--disable-component-update",
          "--disable-default-apps",
          "--disable-dev-shm-usage",
          "--disable-extensions",
          // AcceptCHFrame disabled because of crbug.com/1348106.
          // DIPS is disabled because of crbug.com/1439578. TODO: enable after M115.
          "--disable-features=Translate,BackForwardCache,AcceptCHFrame,MediaRouter,OptimizationHints,DIPS",
          "--disable-hang-monitor",
          "--disable-ipc-flooding-protection",
          "--disable-popup-blocking",
          "--disable-prompt-on-repost",
          "--disable-renderer-backgrounding",
          "--disable-sync",
          "--enable-automation",
          // TODO(sadym): remove '--enable-blink-features=IdleDetection' once
          // IdleDetection is turned on by default.
          "--enable-blink-features=IdleDetection",
          "--enable-features=NetworkServiceInProcess2",
          "--export-tagged-pdf",
          "--force-color-profile=srgb",
          "--metrics-recording-only",
          "--no-first-run",
          "--password-store=basic",
          "--use-mock-keychain"
        ];
        const { devtools = false, headless = !devtools, args = [], userDataDir } = options;
        if (userDataDir) {
          chromeArguments.push(`--user-data-dir=${path_1.default.resolve(userDataDir)}`);
        }
        if (devtools) {
          chromeArguments.push("--auto-open-devtools-for-tabs");
        }
        if (headless) {
          chromeArguments.push(headless === "new" ? "--headless=new" : "--headless", "--hide-scrollbars", "--mute-audio");
        }
        if (args.every((arg) => {
          return arg.startsWith("-");
        })) {
          chromeArguments.push("about:blank");
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
      executablePath(channel) {
        if (channel) {
          return (0, browsers_1.computeSystemExecutablePath)({
            browser: browsers_1.Browser.CHROME,
            channel: convertPuppeteerChannelToBrowsersChannel(channel)
          });
        } else {
          return this.resolveExecutablePath();
        }
      }
    };
    exports2.ChromeLauncher = ChromeLauncher;
    function convertPuppeteerChannelToBrowsersChannel(channel) {
      switch (channel) {
        case "chrome":
          return browsers_1.ChromeReleaseChannel.STABLE;
        case "chrome-dev":
          return browsers_1.ChromeReleaseChannel.DEV;
        case "chrome-beta":
          return browsers_1.ChromeReleaseChannel.BETA;
        case "chrome-canary":
          return browsers_1.ChromeReleaseChannel.CANARY;
      }
    }
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/FirefoxLauncher.js
var require_FirefoxLauncher = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/FirefoxLauncher.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FirefoxLauncher = void 0;
    var fs_1 = __importDefault(require("fs"));
    var promises_1 = require("fs/promises");
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var browsers_1 = require_main();
    var util_js_1 = require_util2();
    var assert_js_1 = require_assert();
    var ProductLauncher_js_1 = require_ProductLauncher();
    var fs_js_1 = require_fs();
    var FirefoxLauncher = class extends ProductLauncher_js_1.ProductLauncher {
      constructor(puppeteer) {
        super(puppeteer, "firefox");
      }
      /**
       * @internal
       */
      async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], executablePath, pipe = false, extraPrefsFirefox = {}, debuggingPort = null } = options;
        const firefoxArguments = [];
        if (!ignoreDefaultArgs) {
          firefoxArguments.push(...this.defaultArgs(options));
        } else if (Array.isArray(ignoreDefaultArgs)) {
          firefoxArguments.push(...this.defaultArgs(options).filter((arg) => {
            return !ignoreDefaultArgs.includes(arg);
          }));
        } else {
          firefoxArguments.push(...args);
        }
        if (!firefoxArguments.some((argument) => {
          return argument.startsWith("--remote-debugging-");
        })) {
          if (pipe) {
            (0, assert_js_1.assert)(debuggingPort === null, "Browser should be launched with either pipe or debugging port - not both.");
          }
          firefoxArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
        }
        let userDataDir;
        let isTempUserDataDir = true;
        const profileArgIndex = firefoxArguments.findIndex((arg) => {
          return ["-profile", "--profile"].includes(arg);
        });
        if (profileArgIndex !== -1) {
          userDataDir = firefoxArguments[profileArgIndex + 1];
          if (!userDataDir || !fs_1.default.existsSync(userDataDir)) {
            throw new Error(`Firefox profile not found at '${userDataDir}'`);
          }
          isTempUserDataDir = false;
        } else {
          userDataDir = await (0, promises_1.mkdtemp)(this.getProfilePath());
          firefoxArguments.push("--profile");
          firefoxArguments.push(userDataDir);
        }
        await (0, browsers_1.createProfile)(browsers_1.Browser.FIREFOX, {
          path: userDataDir,
          preferences: extraPrefsFirefox
        });
        let firefoxExecutable;
        if (this.puppeteer._isPuppeteerCore || executablePath) {
          (0, assert_js_1.assert)(executablePath, `An \`executablePath\` must be specified for \`puppeteer-core\``);
          firefoxExecutable = executablePath;
        } else {
          firefoxExecutable = this.executablePath();
        }
        return {
          isTempUserDataDir,
          userDataDir,
          args: firefoxArguments,
          executablePath: firefoxExecutable
        };
      }
      /**
       * @internal
       */
      async cleanUserDataDir(userDataDir, opts) {
        if (opts.isTemp) {
          try {
            await (0, fs_js_1.rm)(userDataDir);
          } catch (error) {
            (0, util_js_1.debugError)(error);
            throw error;
          }
        } else {
          try {
            await (0, promises_1.unlink)(path_1.default.join(userDataDir, "user.js"));
            const prefsBackupPath = path_1.default.join(userDataDir, "prefs.js.puppeteer");
            if (fs_1.default.existsSync(prefsBackupPath)) {
              const prefsPath = path_1.default.join(userDataDir, "prefs.js");
              await (0, promises_1.unlink)(prefsPath);
              await (0, promises_1.rename)(prefsBackupPath, prefsPath);
            }
          } catch (error) {
            (0, util_js_1.debugError)(error);
          }
        }
      }
      executablePath() {
        if (this.puppeteer.browserRevision === "latest") {
          const cache = new browsers_1.Cache(this.puppeteer.defaultDownloadPath);
          const installedFirefox = cache.getInstalledBrowsers().find((browser) => {
            return browser.platform === (0, browsers_1.detectBrowserPlatform)() && browser.browser === browsers_1.Browser.FIREFOX;
          });
          if (installedFirefox) {
            this.actualBrowserRevision = installedFirefox.buildId;
          }
        }
        return this.resolveExecutablePath();
      }
      defaultArgs(options = {}) {
        const { devtools = false, headless = !devtools, args = [], userDataDir = null } = options;
        const firefoxArguments = ["--no-remote"];
        switch (os_1.default.platform()) {
          case "darwin":
            firefoxArguments.push("--foreground");
            break;
          case "win32":
            firefoxArguments.push("--wait-for-browser");
            break;
        }
        if (userDataDir) {
          firefoxArguments.push("--profile");
          firefoxArguments.push(userDataDir);
        }
        if (headless) {
          firefoxArguments.push("--headless");
        }
        if (devtools) {
          firefoxArguments.push("--devtools");
        }
        if (args.every((arg) => {
          return arg.startsWith("-");
        })) {
          firefoxArguments.push("about:blank");
        }
        firefoxArguments.push(...args);
        return firefoxArguments;
      }
    };
    exports2.FirefoxLauncher = FirefoxLauncher;
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/LaunchOptions.js
var require_LaunchOptions = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/LaunchOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/revisions.js
var require_revisions = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/revisions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PUPPETEER_REVISIONS = void 0;
    exports2.PUPPETEER_REVISIONS = Object.freeze({
      chrome: "113.0.5672.63",
      firefox: "latest"
    });
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/PuppeteerNode.js
var require_PuppeteerNode = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/PuppeteerNode.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _PuppeteerNode_instances;
    var _PuppeteerNode__launcher;
    var _PuppeteerNode_lastLaunchedProduct;
    var _PuppeteerNode_launcher_get;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PuppeteerNode = void 0;
    var Puppeteer_js_1 = require_Puppeteer();
    var revisions_js_1 = require_revisions();
    var ChromeLauncher_js_1 = require_ChromeLauncher();
    var FirefoxLauncher_js_1 = require_FirefoxLauncher();
    var PuppeteerNode = class extends Puppeteer_js_1.Puppeteer {
      /**
       * @internal
       */
      constructor(settings) {
        const { configuration, ...commonSettings } = settings;
        super(commonSettings);
        _PuppeteerNode_instances.add(this);
        _PuppeteerNode__launcher.set(this, void 0);
        _PuppeteerNode_lastLaunchedProduct.set(this, void 0);
        this.configuration = {};
        if (configuration) {
          this.configuration = configuration;
        }
        switch (this.configuration.defaultProduct) {
          case "firefox":
            this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
            break;
          default:
            this.configuration.defaultProduct = "chrome";
            this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.chrome;
            break;
        }
        this.connect = this.connect.bind(this);
        this.launch = this.launch.bind(this);
        this.executablePath = this.executablePath.bind(this);
        this.defaultArgs = this.defaultArgs.bind(this);
      }
      /**
       * This method attaches Puppeteer to an existing browser instance.
       *
       * @param options - Set of configurable options to set on the browser.
       * @returns Promise which resolves to browser instance.
       */
      connect(options) {
        return super.connect(options);
      }
      /**
       * Launches a browser instance with given arguments and options when
       * specified.
       *
       * When using with `puppeteer-core`,
       * {@link LaunchOptions | options.executablePath} or
       * {@link LaunchOptions | options.channel} must be provided.
       *
       * @example
       * You can use {@link LaunchOptions | options.ignoreDefaultArgs}
       * to filter out `--mute-audio` from default arguments:
       *
       * ```ts
       * const browser = await puppeteer.launch({
       *   ignoreDefaultArgs: ['--mute-audio'],
       * });
       * ```
       *
       * @remarks
       * Puppeteer can also be used to control the Chrome browser, but it works best
       * with the version of Chrome for Testing downloaded by default.
       * There is no guarantee it will work with any other version. If Google Chrome
       * (rather than Chrome for Testing) is preferred, a
       * {@link https://www.google.com/chrome/browser/canary.html | Chrome Canary}
       * or
       * {@link https://www.chromium.org/getting-involved/dev-channel | Dev Channel}
       * build is suggested. See
       * {@link https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/ | this article}
       * for a description of the differences between Chromium and Chrome.
       * {@link https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md | This article}
       * describes some differences for Linux users. See
       * {@link https://goo.gle/chrome-for-testing | this doc} for the description
       * of Chrome for Testing.
       *
       * @param options - Options to configure launching behavior.
       */
      launch(options = {}) {
        const { product = this.defaultProduct } = options;
        __classPrivateFieldSet(this, _PuppeteerNode_lastLaunchedProduct, product, "f");
        return __classPrivateFieldGet(this, _PuppeteerNode_instances, "a", _PuppeteerNode_launcher_get).launch(options);
      }
      /**
       * The default executable path.
       */
      executablePath(channel) {
        return __classPrivateFieldGet(this, _PuppeteerNode_instances, "a", _PuppeteerNode_launcher_get).executablePath(channel);
      }
      /**
       * @internal
       */
      get browserRevision() {
        var _a, _b, _c;
        return (_c = (_b = (_a = __classPrivateFieldGet(this, _PuppeteerNode__launcher, "f")) === null || _a === void 0 ? void 0 : _a.getActualBrowserRevision()) !== null && _b !== void 0 ? _b : this.configuration.browserRevision) !== null && _c !== void 0 ? _c : this.defaultBrowserRevision;
      }
      /**
       * The default download path for puppeteer. For puppeteer-core, this
       * code should never be called as it is never defined.
       *
       * @internal
       */
      get defaultDownloadPath() {
        var _a;
        return (_a = this.configuration.downloadPath) !== null && _a !== void 0 ? _a : this.configuration.cacheDirectory;
      }
      /**
       * The name of the browser that was last launched.
       */
      get lastLaunchedProduct() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _PuppeteerNode_lastLaunchedProduct, "f")) !== null && _a !== void 0 ? _a : this.defaultProduct;
      }
      /**
       * The name of the browser that will be launched by default. For
       * `puppeteer`, this is influenced by your configuration. Otherwise, it's
       * `chrome`.
       */
      get defaultProduct() {
        var _a;
        return (_a = this.configuration.defaultProduct) !== null && _a !== void 0 ? _a : "chrome";
      }
      /**
       * @deprecated Do not use as this field as it does not take into account
       * multiple browsers of different types. Use
       * {@link PuppeteerNode.defaultProduct | defaultProduct} or
       * {@link PuppeteerNode.lastLaunchedProduct | lastLaunchedProduct}.
       *
       * @returns The name of the browser that is under automation.
       */
      get product() {
        return __classPrivateFieldGet(this, _PuppeteerNode_instances, "a", _PuppeteerNode_launcher_get).product;
      }
      /**
       * @param options - Set of configurable options to set on the browser.
       *
       * @returns The default flags that Chromium will be launched with.
       */
      defaultArgs(options = {}) {
        return __classPrivateFieldGet(this, _PuppeteerNode_instances, "a", _PuppeteerNode_launcher_get).defaultArgs(options);
      }
    };
    exports2.PuppeteerNode = PuppeteerNode;
    _PuppeteerNode__launcher = /* @__PURE__ */ new WeakMap(), _PuppeteerNode_lastLaunchedProduct = /* @__PURE__ */ new WeakMap(), _PuppeteerNode_instances = /* @__PURE__ */ new WeakSet(), _PuppeteerNode_launcher_get = function _PuppeteerNode_launcher_get2() {
      if (__classPrivateFieldGet(this, _PuppeteerNode__launcher, "f") && __classPrivateFieldGet(this, _PuppeteerNode__launcher, "f").product === this.lastLaunchedProduct) {
        return __classPrivateFieldGet(this, _PuppeteerNode__launcher, "f");
      }
      switch (this.lastLaunchedProduct) {
        case "chrome":
          this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.chrome;
          __classPrivateFieldSet(this, _PuppeteerNode__launcher, new ChromeLauncher_js_1.ChromeLauncher(this), "f");
          break;
        case "firefox":
          this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
          __classPrivateFieldSet(this, _PuppeteerNode__launcher, new FirefoxLauncher_js_1.FirefoxLauncher(this), "f");
          break;
        default:
          throw new Error(`Unknown product: ${__classPrivateFieldGet(this, _PuppeteerNode_lastLaunchedProduct, "f")}`);
      }
      return __classPrivateFieldGet(this, _PuppeteerNode__launcher, "f");
    };
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/node/node.js
var require_node7 = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/node/node.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ChromeLauncher(), exports2);
    __exportStar(require_FirefoxLauncher(), exports2);
    __exportStar(require_LaunchOptions(), exports2);
    __exportStar(require_PipeTransport(), exports2);
    __exportStar(require_ProductLauncher(), exports2);
    __exportStar(require_PuppeteerNode(), exports2);
  }
});

// node_modules/puppeteer-core/lib/cjs/puppeteer/puppeteer-core.js
var require_puppeteer_core = __commonJS({
  "node_modules/puppeteer-core/lib/cjs/puppeteer/puppeteer-core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.launch = exports2.executablePath = exports2.defaultArgs = exports2.connect = void 0;
    __exportStar(require_api(), exports2);
    __exportStar(require_common2(), exports2);
    __exportStar(require_node7(), exports2);
    __exportStar(require_revisions(), exports2);
    __exportStar(require_util3(), exports2);
    __exportStar(require_CustomQueryHandler(), exports2);
    var PuppeteerNode_js_1 = require_PuppeteerNode();
    var puppeteer = new PuppeteerNode_js_1.PuppeteerNode({
      isPuppeteerCore: true
    });
    exports2.connect = puppeteer.connect, /**
     * @public
     */
    exports2.defaultArgs = puppeteer.defaultArgs, /**
     * @public
     */
    exports2.executablePath = puppeteer.executablePath, /**
     * @public
     */
    exports2.launch = puppeteer.launch;
    exports2.default = puppeteer;
  }
});

// node_modules/cosmiconfig/dist/cacheWrapper.js
var require_cacheWrapper = __commonJS({
  "node_modules/cosmiconfig/dist/cacheWrapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.cacheWrapper = cacheWrapper;
    exports2.cacheWrapperSync = cacheWrapperSync;
    async function cacheWrapper(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = await fn();
      cache.set(key, result);
      return result;
    }
    function cacheWrapperSync(cache, key, fn) {
      const cached = cache.get(key);
      if (cached !== void 0) {
        return cached;
      }
      const result = fn();
      cache.set(key, result);
      return result;
    }
  }
});

// node_modules/cosmiconfig/dist/getPropertyByPath.js
var require_getPropertyByPath = __commonJS({
  "node_modules/cosmiconfig/dist/getPropertyByPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getPropertyByPath = getPropertyByPath;
    function getPropertyByPath(source, path) {
      if (typeof path === "string" && Object.prototype.hasOwnProperty.call(source, path)) {
        return source[path];
      }
      const parsedPath = typeof path === "string" ? path.split(".") : path;
      return parsedPath.reduce((previous, key) => {
        if (previous === void 0) {
          return previous;
        }
        return previous[key];
      }, source);
    }
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var Module = require("module");
    var fs = require("fs");
    var resolveFrom = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
    module2.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);
  }
});

// node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/callsites/index.js"(exports2, module2) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module2.exports = callsites;
    module2.exports.default = callsites;
  }
});

// node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "node_modules/parent-module/index.js"(exports2, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "node_modules/import-fresh/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var resolveFrom = require_resolve_from();
    var parentModule = require_parent_module();
    module2.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path.dirname(parentPath) : __dirname;
      const filePath = resolveFrom(cwd, moduleId);
      const oldModule = require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete require.cache[filePath];
      const parent = require.cache[parentPath];
      return parent === void 0 ? require(filePath) : parent.require(filePath);
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isArrayish(obj) {
      if (!obj) {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
    };
  }
});

// node_modules/error-ex/index.js
var require_error_ex = __commonJS({
  "node_modules/error-ex/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var isArrayish = require_is_arrayish();
    var errorEx = function errorEx2(name, properties) {
      if (!name || name.constructor !== String) {
        properties = name || {};
        name = Error.name;
      }
      var errorExError = function ErrorEXError(message) {
        if (!this) {
          return new ErrorEXError(message);
        }
        message = message instanceof Error ? message.message : message || this.message;
        Error.call(this, message);
        Error.captureStackTrace(this, errorExError);
        this.name = name;
        Object.defineProperty(this, "message", {
          configurable: true,
          enumerable: false,
          get: function() {
            var newMessage = message.split(/\r?\n/g);
            for (var key in properties) {
              if (!properties.hasOwnProperty(key)) {
                continue;
              }
              var modifier = properties[key];
              if ("message" in modifier) {
                newMessage = modifier.message(this[key], newMessage) || newMessage;
                if (!isArrayish(newMessage)) {
                  newMessage = [newMessage];
                }
              }
            }
            return newMessage.join("\n");
          },
          set: function(v) {
            message = v;
          }
        });
        var overwrittenStack = null;
        var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
        var stackGetter = stackDescriptor.get;
        var stackValue = stackDescriptor.value;
        delete stackDescriptor.value;
        delete stackDescriptor.writable;
        stackDescriptor.set = function(newstack) {
          overwrittenStack = newstack;
        };
        stackDescriptor.get = function() {
          var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
          if (!overwrittenStack) {
            stack[0] = this.name + ": " + this.message;
          }
          var lineCount = 1;
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ("line" in modifier) {
              var line = modifier.line(this[key]);
              if (line) {
                stack.splice(lineCount++, 0, "    " + line);
              }
            }
            if ("stack" in modifier) {
              modifier.stack(this[key], stack);
            }
          }
          return stack.join("\n");
        };
        Object.defineProperty(this, "stack", stackDescriptor);
      };
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(errorExError.prototype, Error.prototype);
        Object.setPrototypeOf(errorExError, Error);
      } else {
        util.inherits(errorExError, Error);
      }
      return errorExError;
    };
    errorEx.append = function(str, def) {
      return {
        message: function(v, message) {
          v = v || def;
          if (v) {
            message[0] += " " + str.replace("%s", v.toString());
          }
          return message;
        }
      };
    };
    errorEx.line = function(str, def) {
      return {
        line: function(v) {
          v = v || def;
          if (v) {
            return str.replace("%s", v.toString());
          }
          return null;
        }
      };
    };
    module2.exports = errorEx;
  }
});

// node_modules/json-parse-even-better-errors/index.js
var require_json_parse_even_better_errors = __commonJS({
  "node_modules/json-parse-even-better-errors/index.js"(exports2, module2) {
    "use strict";
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return "0x" + (h.length % 2 ? "0" : "") + h;
    };
    var parseError = (e, txt, context) => {
      if (!txt) {
        return {
          message: e.message + " while parsing empty string",
          position: 0
        };
      }
      const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
      const errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`) : e.message;
      if (errIdx !== null && errIdx !== void 0) {
        const start = errIdx <= context ? 0 : errIdx - context;
        const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        const slice = (start === 0 ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
        const near = txt === slice ? "" : "near ";
        return {
          message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,
          position: errIdx
        };
      } else {
        return {
          message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,
          position: 0
        };
      }
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        context = context || 20;
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var kIndent = Symbol.for("indent");
    var kNewline = Symbol.for("newline");
    var formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
    var emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var parseJson = (txt, reviver, context) => {
      const parseText = stripBOM(txt);
      context = context || 20;
      try {
        const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [, "", ""];
        const result = JSON.parse(parseText, reviver);
        if (result && typeof result === "object") {
          result[kNewline] = newline;
          result[kIndent] = indent;
        }
        return result;
      } catch (e) {
        if (typeof txt !== "string" && !Buffer.isBuffer(txt)) {
          const isEmptyArray = Array.isArray(txt) && txt.length === 0;
          throw Object.assign(new TypeError(
            `Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`
          ), {
            code: "EJSONPARSE",
            systemError: e
          });
        }
        throw new JSONParseError(e, parseText, context, parseJson);
      }
    };
    var stripBOM = (txt) => String(txt).replace(/^\uFEFF/, "");
    module2.exports = parseJson;
    parseJson.JSONParseError = JSONParseError;
    parseJson.noExceptions = (txt, reviver) => {
      try {
        return JSON.parse(stripBOM(txt), reviver);
      } catch (e) {
      }
    };
  }
});

// node_modules/lines-and-columns/build/index.js
var require_build5 = __commonJS({
  "node_modules/lines-and-columns/build/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.LinesAndColumns = void 0;
    var LF = "\n";
    var CR = "\r";
    var LinesAndColumns = (
      /** @class */
      function() {
        function LinesAndColumns2(string) {
          this.string = string;
          var offsets = [0];
          for (var offset = 0; offset < string.length; ) {
            switch (string[offset]) {
              case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
              case CR:
                offset += CR.length;
                if (string[offset] === LF) {
                  offset += LF.length;
                }
                offsets.push(offset);
                break;
              default:
                offset++;
                break;
            }
          }
          this.offsets = offsets;
        }
        LinesAndColumns2.prototype.locationForIndex = function(index) {
          if (index < 0 || index > this.string.length) {
            return null;
          }
          var line = 0;
          var offsets = this.offsets;
          while (offsets[line + 1] <= index) {
            line++;
          }
          var column = index - offsets[line];
          return { line, column };
        };
        LinesAndColumns2.prototype.indexForLocation = function(location) {
          var line = location.line, column = location.column;
          if (line < 0 || line >= this.offsets.length) {
            return null;
          }
          if (column < 0 || column > this.lengthOfLine(line)) {
            return null;
          }
          return this.offsets[line] + column;
        };
        LinesAndColumns2.prototype.lengthOfLine = function(line) {
          var offset = this.offsets[line];
          var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
          return nextOffset - offset;
        };
        return LinesAndColumns2;
      }()
    );
    exports2.LinesAndColumns = LinesAndColumns;
    exports2["default"] = LinesAndColumns;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert2();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles2();
    var stdoutColor = require_supports_color().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = highlight;
    exports2.getChalk = getChalk;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib3();
    var _chalk = require_chalk();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const chalk = getChalk(options);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = require_lib4();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});

// node_modules/parse-json/index.js
var require_parse_json = __commonJS({
  "node_modules/parse-json/index.js"(exports2, module2) {
    "use strict";
    var errorEx = require_error_ex();
    var fallback = require_json_parse_even_better_errors();
    var { default: LinesAndColumns } = require_build5();
    var { codeFrameColumns } = require_lib5();
    var JSONError = errorEx("JSONError", {
      fileName: errorEx.append("in %s"),
      codeFrame: errorEx.append("\n\n%s\n")
    });
    var parseJson = (string, reviver, filename) => {
      if (typeof reviver === "string") {
        filename = reviver;
        reviver = null;
      }
      try {
        try {
          return JSON.parse(string, reviver);
        } catch (error) {
          fallback(string, reviver);
          throw error;
        }
      } catch (error) {
        error.message = error.message.replace(/\n/g, "");
        const indexMatch = error.message.match(/in JSON at position (\d+) while parsing/);
        const jsonError = new JSONError(error);
        if (filename) {
          jsonError.fileName = filename;
        }
        if (indexMatch && indexMatch.length > 0) {
          const lines = new LinesAndColumns(string);
          const index = Number(indexMatch[1]);
          const location = lines.locationForIndex(index);
          const codeFrame = codeFrameColumns(
            string,
            { start: { line: location.line + 1, column: location.column + 1 } },
            { highlightCode: true }
          );
          jsonError.codeFrame = codeFrame;
        }
        throw jsonError;
      }
    };
    parseJson.JSONError = JSONError;
    module2.exports = parseJson;
  }
});

// node_modules/js-yaml/lib/common.js
var require_common7 = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports2, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports2, module2) {
    "use strict";
    var common = require_common7();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length)
          break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports2, module2) {
    "use strict";
    var common = require_common7();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports2, module2) {
    "use strict";
    var common = require_common7();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports2, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports2, module2) {
    "use strict";
    module2.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports2, module2) {
    "use strict";
    var common = require_common7();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports2, module2) {
    "use strict";
    var common = require_common7();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string[i];
          if (char >= 65536)
            result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/cosmiconfig/dist/loaders.js
var require_loaders = __commonJS({
  "node_modules/cosmiconfig/dist/loaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.loaders = void 0;
    var importFresh;
    var loadJs = function loadJs2(filepath) {
      if (importFresh === void 0) {
        importFresh = require_import_fresh();
      }
      const result = importFresh(filepath);
      return result;
    };
    var parseJson;
    var loadJson = function loadJson2(filepath, content) {
      if (parseJson === void 0) {
        parseJson = require_parse_json();
      }
      try {
        const result = parseJson(content);
        return result;
      } catch (error) {
        error.message = `JSON Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var yaml;
    var loadYaml = function loadYaml2(filepath, content) {
      if (yaml === void 0) {
        yaml = require_js_yaml();
      }
      try {
        const result = yaml.load(content);
        return result;
      } catch (error) {
        error.message = `YAML Error in ${filepath}:
${error.message}`;
        throw error;
      }
    };
    var loaders = {
      loadJs,
      loadJson,
      loadYaml
    };
    exports2.loaders = loaders;
  }
});

// node_modules/cosmiconfig/dist/ExplorerBase.js
var require_ExplorerBase = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExplorerBase = void 0;
    exports2.getExtensionDescription = getExtensionDescription;
    var _path = _interopRequireDefault(require("path"));
    var _getPropertyByPath = require_getPropertyByPath();
    var _loaders = require_loaders();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerBase = class {
      constructor(options) {
        if (options.cache) {
          this.loadCache = /* @__PURE__ */ new Map();
          this.searchCache = /* @__PURE__ */ new Map();
        }
        this.config = options;
        this.validateConfig();
      }
      clearLoadCache() {
        if (this.loadCache) {
          this.loadCache.clear();
        }
      }
      clearSearchCache() {
        if (this.searchCache) {
          this.searchCache.clear();
        }
      }
      clearCaches() {
        this.clearLoadCache();
        this.clearSearchCache();
      }
      validateConfig() {
        const config = this.config;
        config.searchPlaces.forEach((place) => {
          const loaderKey = _path.default.extname(place) || "noExt";
          const loader = config.loaders[loaderKey];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
      }
      shouldSearchStopWithResult(result) {
        if (result === null)
          return false;
        return !(result.isEmpty && this.config.ignoreEmptySearchPlaces);
      }
      nextDirectoryToSearch(currentDir, currentResult) {
        if (this.shouldSearchStopWithResult(currentResult)) {
          return null;
        }
        const nextDir = nextDirUp(currentDir);
        if (nextDir === currentDir || currentDir === this.config.stopDir) {
          return null;
        }
        return nextDir;
      }
      loadPackageProp(filepath, content) {
        const parsedContent = _loaders.loaders.loadJson(filepath, content);
        const packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);
        return packagePropValue || null;
      }
      getLoaderEntryForFile(filepath) {
        if (_path.default.basename(filepath) === "package.json") {
          return this.loadPackageProp.bind(this);
        }
        const loaderKey = _path.default.extname(filepath) || "noExt";
        const loader = this.config.loaders[loaderKey];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);
        }
        return loader;
      }
      loadedContentToCosmiconfigResult(filepath, loadedContent, forceProp) {
        if (loadedContent === null) {
          return null;
        }
        if (loadedContent === void 0) {
          return {
            filepath,
            config: void 0,
            isEmpty: true
          };
        }
        if (this.config.usePackagePropInConfigFiles || forceProp) {
          loadedContent = (0, _getPropertyByPath.getPropertyByPath)(loadedContent, this.config.packageProp);
        }
        if (loadedContent === void 0) {
          return {
            filepath,
            config: void 0,
            isEmpty: true
          };
        }
        return {
          config: loadedContent,
          filepath
        };
      }
      validateFilePath(filepath) {
        if (!filepath) {
          throw new Error("load must pass a non-empty string");
        }
      }
    };
    exports2.ExplorerBase = ExplorerBase;
    function nextDirUp(dir) {
      return _path.default.dirname(dir);
    }
    function getExtensionDescription(filepath) {
      const ext = _path.default.extname(filepath);
      return ext ? `extension "${ext}"` : "files without extensions";
    }
  }
});

// node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify } = require("util");
    var fs = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/cosmiconfig/dist/getDirectory.js
var require_getDirectory = __commonJS({
  "node_modules/cosmiconfig/dist/getDirectory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getDirectory = getDirectory;
    exports2.getDirectorySync = getDirectorySync;
    var _path = _interopRequireDefault(require("path"));
    var _pathType = require_path_type();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function getDirectory(filepath) {
      const filePathIsDirectory = await (0, _pathType.isDirectory)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
    function getDirectorySync(filepath) {
      const filePathIsDirectory = (0, _pathType.isDirectorySync)(filepath);
      if (filePathIsDirectory === true) {
        return filepath;
      }
      const directory = _path.default.dirname(filepath);
      return directory;
    }
  }
});

// node_modules/cosmiconfig/dist/readFile.js
var require_readFile = __commonJS({
  "node_modules/cosmiconfig/dist/readFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readFile = readFile;
    exports2.readFileSync = readFileSync;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function fsReadFileAsync(pathname, encoding) {
      return new Promise((resolve, reject) => {
        _fs.default.readFile(pathname, encoding, (error, contents) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(contents);
        });
      });
    }
    async function readFile(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = await fsReadFileAsync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
    function readFileSync(filepath, options = {}) {
      const throwNotFound = options.throwNotFound === true;
      try {
        const content = _fs.default.readFileSync(filepath, "utf8");
        return content;
      } catch (error) {
        if (throwNotFound === false && (error.code === "ENOENT" || error.code === "EISDIR")) {
          return null;
        }
        throw error;
      }
    }
  }
});

// node_modules/cosmiconfig/dist/Explorer.js
var require_Explorer = __commonJS({
  "node_modules/cosmiconfig/dist/Explorer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Explorer = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _cacheWrapper = require_cacheWrapper();
    var _ExplorerBase = require_ExplorerBase();
    var _getDirectory = require_getDirectory();
    var _readFile = require_readFile();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Explorer = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      async search(searchFrom = process.cwd()) {
        if (this.config.metaConfigFilePath) {
          const config = await this._loadFile(this.config.metaConfigFilePath, true);
          if (config && !config.isEmpty) {
            return config;
          }
        }
        return await this.searchFromDirectory(await (0, _getDirectory.getDirectory)(searchFrom));
      }
      async searchFromDirectory(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = async () => {
          const result = await this.searchDirectory(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectory(nextDir);
          }
          return await this.config.transform(result);
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      async searchDirectory(dir) {
        for await (const place of this.config.searchPlaces) {
          const placeResult = await this.loadSearchPlace(dir, place);
          if (this.shouldSearchStopWithResult(placeResult)) {
            return placeResult;
          }
        }
        return null;
      }
      async loadSearchPlace(dir, place) {
        const filepath = _path.default.join(dir, place);
        const fileContents = await (0, _readFile.readFile)(filepath);
        return await this.createCosmiconfigResult(filepath, fileContents, false);
      }
      async loadFileContent(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        try {
          return await loader(filepath, content);
        } catch (e) {
          e.filepath = filepath;
          throw e;
        }
      }
      async createCosmiconfigResult(filepath, content, forceProp) {
        const fileContent = await this.loadFileContent(filepath, content);
        return this.loadedContentToCosmiconfigResult(filepath, fileContent, forceProp);
      }
      async load(filepath) {
        return this._loadFile(filepath, false);
      }
      async _loadFile(filepath, forceProp) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoad = async () => {
          const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {
            throwNotFound: true
          });
          const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents, forceProp);
          return await this.config.transform(result);
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);
        }
        return runLoad();
      }
    };
    exports2.Explorer = Explorer;
  }
});

// node_modules/cosmiconfig/dist/ExplorerSync.js
var require_ExplorerSync = __commonJS({
  "node_modules/cosmiconfig/dist/ExplorerSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExplorerSync = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _cacheWrapper = require_cacheWrapper();
    var _ExplorerBase = require_ExplorerBase();
    var _getDirectory = require_getDirectory();
    var _readFile = require_readFile();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ExplorerSync = class extends _ExplorerBase.ExplorerBase {
      constructor(options) {
        super(options);
      }
      searchSync(searchFrom = process.cwd()) {
        if (this.config.metaConfigFilePath) {
          const config = this._loadFileSync(this.config.metaConfigFilePath, true);
          if (config && !config.isEmpty) {
            return config;
          }
        }
        return this.searchFromDirectorySync((0, _getDirectory.getDirectorySync)(searchFrom));
      }
      searchFromDirectorySync(dir) {
        const absoluteDir = _path.default.resolve(process.cwd(), dir);
        const run = () => {
          const result = this.searchDirectorySync(absoluteDir);
          const nextDir = this.nextDirectoryToSearch(absoluteDir, result);
          if (nextDir) {
            return this.searchFromDirectorySync(nextDir);
          }
          return this.config.transform(result);
        };
        if (this.searchCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.searchCache, absoluteDir, run);
        }
        return run();
      }
      searchDirectorySync(dir) {
        for (const place of this.config.searchPlaces) {
          const placeResult = this.loadSearchPlaceSync(dir, place);
          if (this.shouldSearchStopWithResult(placeResult)) {
            return placeResult;
          }
        }
        return null;
      }
      loadSearchPlaceSync(dir, place) {
        const filepath = _path.default.join(dir, place);
        const content = (0, _readFile.readFileSync)(filepath);
        return this.createCosmiconfigResultSync(filepath, content, false);
      }
      loadFileContentSync(filepath, content) {
        if (content === null) {
          return null;
        }
        if (content.trim() === "") {
          return void 0;
        }
        const loader = this.getLoaderEntryForFile(filepath);
        try {
          return loader(filepath, content);
        } catch (e) {
          e.filepath = filepath;
          throw e;
        }
      }
      createCosmiconfigResultSync(filepath, content, forceProp) {
        const fileContent = this.loadFileContentSync(filepath, content);
        return this.loadedContentToCosmiconfigResult(filepath, fileContent, forceProp);
      }
      loadSync(filepath) {
        return this._loadFileSync(filepath, false);
      }
      _loadFileSync(filepath, forceProp) {
        this.validateFilePath(filepath);
        const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);
        const runLoadSync = () => {
          const content = (0, _readFile.readFileSync)(absoluteFilePath, {
            throwNotFound: true
          });
          const cosmiconfigResult = this.createCosmiconfigResultSync(absoluteFilePath, content, forceProp);
          return this.config.transform(cosmiconfigResult);
        };
        if (this.loadCache) {
          return (0, _cacheWrapper.cacheWrapperSync)(this.loadCache, absoluteFilePath, runLoadSync);
        }
        return runLoadSync();
      }
    };
    exports2.ExplorerSync = ExplorerSync;
  }
});

// node_modules/cosmiconfig/dist/types.js
var require_types3 = __commonJS({
  "node_modules/cosmiconfig/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
  }
});

// node_modules/cosmiconfig/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/cosmiconfig/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.cosmiconfig = cosmiconfig;
    exports2.cosmiconfigSync = cosmiconfigSync;
    exports2.metaSearchPlaces = exports2.defaultLoaders = void 0;
    var _os = _interopRequireDefault(require("os"));
    var _Explorer = require_Explorer();
    var _ExplorerSync = require_ExplorerSync();
    var _loaders = require_loaders();
    var _types = require_types3();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var metaSearchPlaces = ["package.json", ".config.json", ".config.yaml", ".config.yml", ".config.js", ".config.cjs"];
    exports2.metaSearchPlaces = metaSearchPlaces;
    var defaultLoaders = Object.freeze({
      ".cjs": _loaders.loaders.loadJs,
      ".js": _loaders.loaders.loadJs,
      ".json": _loaders.loaders.loadJson,
      ".yaml": _loaders.loaders.loadYaml,
      ".yml": _loaders.loaders.loadYaml,
      noExt: _loaders.loaders.loadYaml
    });
    exports2.defaultLoaders = defaultLoaders;
    var identity = function identity2(x) {
      return x;
    };
    function replaceMetaPlaceholders(paths, moduleName) {
      return paths.map((path) => path.replace("{name}", moduleName));
    }
    function getExplorerOptions(moduleName, options) {
      var _metaConfig$config;
      const metaExplorer = new _ExplorerSync.ExplorerSync({
        packageProp: "cosmiconfig",
        stopDir: process.cwd(),
        searchPlaces: metaSearchPlaces,
        ignoreEmptySearchPlaces: false,
        usePackagePropInConfigFiles: true,
        loaders: defaultLoaders,
        transform: identity,
        cache: true,
        metaConfigFilePath: null
      });
      const metaConfig = metaExplorer.searchSync();
      if (!metaConfig) {
        return normalizeOptions(moduleName, options);
      }
      if ((_metaConfig$config = metaConfig.config) !== null && _metaConfig$config !== void 0 && _metaConfig$config.loaders) {
        throw new Error("Can not specify loaders in meta config file");
      }
      const overrideOptions = metaConfig.config ?? {};
      if (overrideOptions.searchPlaces) {
        overrideOptions.searchPlaces = replaceMetaPlaceholders(overrideOptions.searchPlaces, moduleName);
      }
      overrideOptions.metaConfigFilePath = metaConfig.filepath;
      const mergedOptions = {
        ...options,
        ...overrideOptions
      };
      return normalizeOptions(moduleName, mergedOptions);
    }
    function cosmiconfig(moduleName, options = {}) {
      const normalizedOptions = getExplorerOptions(moduleName, options);
      const explorer = new _Explorer.Explorer(normalizedOptions);
      return {
        search: explorer.search.bind(explorer),
        load: explorer.load.bind(explorer),
        clearLoadCache: explorer.clearLoadCache.bind(explorer),
        clearSearchCache: explorer.clearSearchCache.bind(explorer),
        clearCaches: explorer.clearCaches.bind(explorer)
      };
    }
    function cosmiconfigSync(moduleName, options = {}) {
      const normalizedOptions = getExplorerOptions(moduleName, options);
      const explorerSync = new _ExplorerSync.ExplorerSync(normalizedOptions);
      return {
        search: explorerSync.searchSync.bind(explorerSync),
        load: explorerSync.loadSync.bind(explorerSync),
        clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),
        clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),
        clearCaches: explorerSync.clearCaches.bind(explorerSync)
      };
    }
    function normalizeOptions(moduleName, options) {
      const defaults = {
        packageProp: moduleName,
        searchPlaces: ["package.json", `.${moduleName}rc`, `.${moduleName}rc.json`, `.${moduleName}rc.yaml`, `.${moduleName}rc.yml`, `.${moduleName}rc.js`, `.${moduleName}rc.cjs`, `.config/${moduleName}rc`, `.config/${moduleName}rc.json`, `.config/${moduleName}rc.yaml`, `.config/${moduleName}rc.yml`, `.config/${moduleName}rc.js`, `.config/${moduleName}rc.cjs`, `${moduleName}.config.js`, `${moduleName}.config.cjs`],
        ignoreEmptySearchPlaces: true,
        stopDir: _os.default.homedir(),
        cache: true,
        transform: identity,
        loaders: defaultLoaders,
        metaConfigFilePath: null
      };
      let loaders = {
        ...defaults.loaders
      };
      if (options.loaders) {
        Object.assign(loaders, options.loaders);
      }
      return {
        ...defaults,
        ...options,
        loaders
      };
    }
  }
});

// node_modules/puppeteer/lib/cjs/puppeteer/getConfiguration.js
var require_getConfiguration = __commonJS({
  "node_modules/puppeteer/lib/cjs/puppeteer/getConfiguration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getConfiguration = void 0;
    var os_1 = require("os");
    var path_1 = require("path");
    var cosmiconfig_1 = require_dist2();
    function isSupportedProduct(product) {
      switch (product) {
        case "chrome":
        case "firefox":
          return true;
        default:
          return false;
      }
    }
    var getConfiguration = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
      const result = (0, cosmiconfig_1.cosmiconfigSync)("puppeteer").search();
      const configuration = result ? result.config : {};
      configuration.defaultProduct = (_d = (_c = (_b = (_a = process.env["PUPPETEER_PRODUCT"]) !== null && _a !== void 0 ? _a : process.env["npm_config_puppeteer_product"]) !== null && _b !== void 0 ? _b : process.env["npm_package_config_puppeteer_product"]) !== null && _c !== void 0 ? _c : configuration.defaultProduct) !== null && _d !== void 0 ? _d : "chrome";
      configuration.executablePath = (_g = (_f = (_e = process.env["PUPPETEER_EXECUTABLE_PATH"]) !== null && _e !== void 0 ? _e : process.env["npm_config_puppeteer_executable_path"]) !== null && _f !== void 0 ? _f : process.env["npm_package_config_puppeteer_executable_path"]) !== null && _g !== void 0 ? _g : configuration.executablePath;
      if (configuration.executablePath) {
        configuration.skipDownload = true;
      }
      configuration.skipDownload = Boolean((_k = (_j = (_h = process.env["PUPPETEER_SKIP_DOWNLOAD"]) !== null && _h !== void 0 ? _h : process.env["npm_config_puppeteer_skip_download"]) !== null && _j !== void 0 ? _j : process.env["npm_package_config_puppeteer_skip_download"]) !== null && _k !== void 0 ? _k : configuration.skipDownload);
      if (!configuration.skipDownload) {
        configuration.browserRevision = (_o = (_m = (_l = process.env["PUPPETEER_BROWSER_REVISION"]) !== null && _l !== void 0 ? _l : process.env["npm_config_puppeteer_browser_revision"]) !== null && _m !== void 0 ? _m : process.env["npm_package_config_puppeteer_browser_revision"]) !== null && _o !== void 0 ? _o : configuration.browserRevision;
        configuration.downloadHost = (_r = (_q = (_p = process.env["PUPPETEER_DOWNLOAD_HOST"]) !== null && _p !== void 0 ? _p : process.env["npm_config_puppeteer_download_host"]) !== null && _q !== void 0 ? _q : process.env["npm_package_config_puppeteer_download_host"]) !== null && _r !== void 0 ? _r : configuration.downloadHost;
        configuration.downloadPath = (_u = (_t = (_s = process.env["PUPPETEER_DOWNLOAD_PATH"]) !== null && _s !== void 0 ? _s : process.env["npm_config_puppeteer_download_path"]) !== null && _t !== void 0 ? _t : process.env["npm_package_config_puppeteer_download_path"]) !== null && _u !== void 0 ? _u : configuration.downloadPath;
      }
      configuration.cacheDirectory = (_y = (_x = (_w = (_v = process.env["PUPPETEER_CACHE_DIR"]) !== null && _v !== void 0 ? _v : process.env["npm_config_puppeteer_cache_dir"]) !== null && _w !== void 0 ? _w : process.env["npm_package_config_puppeteer_cache_dir"]) !== null && _x !== void 0 ? _x : configuration.cacheDirectory) !== null && _y !== void 0 ? _y : (0, path_1.join)((0, os_1.homedir)(), ".cache", "puppeteer");
      configuration.temporaryDirectory = (_1 = (_0 = (_z = process.env["PUPPETEER_TMP_DIR"]) !== null && _z !== void 0 ? _z : process.env["npm_config_puppeteer_tmp_dir"]) !== null && _0 !== void 0 ? _0 : process.env["npm_package_config_puppeteer_tmp_dir"]) !== null && _1 !== void 0 ? _1 : configuration.temporaryDirectory;
      (_2 = configuration.experiments) !== null && _2 !== void 0 ? _2 : configuration.experiments = {};
      configuration.logLevel = (_5 = (_4 = (_3 = process.env["PUPPETEER_LOGLEVEL"]) !== null && _3 !== void 0 ? _3 : process.env["npm_config_LOGLEVEL"]) !== null && _4 !== void 0 ? _4 : process.env["npm_package_config_LOGLEVEL"]) !== null && _5 !== void 0 ? _5 : configuration.logLevel;
      if (!isSupportedProduct(configuration.defaultProduct)) {
        throw new Error(`Unsupported product ${configuration.defaultProduct}`);
      }
      return configuration;
    };
    exports2.getConfiguration = getConfiguration;
  }
});

// node_modules/puppeteer/lib/cjs/puppeteer/puppeteer.js
var require_puppeteer = __commonJS({
  "node_modules/puppeteer/lib/cjs/puppeteer/puppeteer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.launch = exports2.executablePath = exports2.defaultArgs = exports2.connect = void 0;
    __exportStar(require_puppeteer_core(), exports2);
    var PuppeteerNode_js_1 = require_PuppeteerNode();
    var getConfiguration_js_1 = require_getConfiguration();
    var configuration = (0, getConfiguration_js_1.getConfiguration)();
    var puppeteer = new PuppeteerNode_js_1.PuppeteerNode({
      isPuppeteerCore: false,
      configuration
    });
    exports2.connect = puppeteer.connect, /**
     * @public
     */
    exports2.defaultArgs = puppeteer.defaultArgs, /**
     * @public
     */
    exports2.executablePath = puppeteer.executablePath, /**
     * @public
     */
    exports2.launch = puppeteer.launch;
    exports2.default = puppeteer;
  }
});

// src/web-renderer.js
var require_web_renderer = __commonJS({
  "src/web-renderer.js"(exports2, module2) {
    var { readFileSync } = require("fs");
    var { render } = require_mustache();
    var { join, posix } = require("path");
    var { window: window2, ViewColumn, workspace, Uri } = require("vscode");
    var puppeteer = require_puppeteer();
    var {
      COMMON_CSS,
      REPORT_FILE_NAME,
      REPORT_FOLDER_NAME,
      REPORT_TITLE,
      MSGS
    } = require_constants();
    var { logMsg } = require_util();
    var WebRenderer = class {
      constructor(template, title) {
        __publicField(this, "template", null);
        __publicField(this, "title", "");
        __publicField(this, "panel", null);
        __publicField(this, "context", null);
        __publicField(this, "content", null);
        __publicField(this, "init", async (context) => {
          this.context = context;
          this.initializePanel();
          this.onClosePanel();
        });
        __publicField(this, "initializePanel", () => {
          this.panel = createPanel(this.title);
          this.panel.webview.onDidReceiveMessage(
            (message) => {
              switch (message.command) {
                case "downloadReport":
                  this.createReport();
                  return;
              }
            },
            void 0,
            this.context.subscriptions
          );
        });
        __publicField(this, "sendMessageToUI", (msg) => {
          this.panel.webview.postMessage({ command: msg });
        });
        __publicField(this, "createReport", () => {
          createReportFile(this, this.content);
        });
        __publicField(this, "onClosePanel", () => {
          this.panel.onDidDispose(() => {
            this.deleteReportFile();
          }, null);
        });
        __publicField(this, "renderContent", (content) => {
          this.content = content;
          renderContentOnPanel(this.panel, content);
        });
        __publicField(this, "renderLoader", () => {
          renderLoader(this.panel, this.title);
        });
        __publicField(this, "renderError", (meta) => {
          renderError(this.panel, meta);
        });
        __publicField(this, "deleteReportFile", () => {
          deleteReportFile();
        });
        this.title = title;
        this.template = template;
      }
    };
    var createPanel = (title) => {
      return window2.createWebviewPanel(
        title.replace(" ", "").trim(),
        title,
        ViewColumn.One,
        { localResourceRoots: [], enableScripts: true }
      );
    };
    var getTemplate = async (template) => {
      return await readFileSync(
        join(__dirname, `../assets/templates/${template}.mustache`),
        "utf-8"
      );
    };
    var renderContentOnPanel = (panel, content) => {
      panel.webview.html = content;
    };
    var renderLoader = async (panel, title) => {
      const template = await getTemplate("loader");
      const view = { commonCSS: COMMON_CSS, actionHeader: title };
      let content = render(template, view);
      renderContentOnPanel(panel, content);
    };
    var renderError = async (panel, meta) => {
      const template = await getTemplate("error");
      const { actionHeader, hasSolution, message } = meta;
      const view = {
        commonCSS: COMMON_CSS,
        actionHeader
      };
      let content = render(template, view);
      content += `<div class="text-danger b mb-2">${message || "Something went wrong, please try again after sometime."}</div>`;
      if (hasSolution) {
        content += `<div class="box box-info">${hasSolution}</div>`;
      }
      panel.webview.html = content;
    };
    var createReportFile = async (webRenderedRef, content) => {
      const folderUri = workspace.workspaceFolders[0].uri;
      const reportFileName = posix.join(
        folderUri.path,
        `${REPORT_FOLDER_NAME}/${REPORT_FILE_NAME}`
      );
      const filePDFUri = folderUri.with({ path: `${reportFileName}.pdf` });
      try {
        content += `<style>.header-link-actions { display: none;}</style>`;
        webRenderedRef.sendMessageToUI("downloadingPDFStart");
        await createFolder(REPORT_FOLDER_NAME);
        await createPDF(content, filePDFUri.fsPath, REPORT_TITLE);
        webRenderedRef.sendMessageToUI("downloadingPDFEnd");
        logMsg(MSGS.REPORT_PDF_CREATED, true);
      } catch (e) {
        webRenderedRef.renderError(webRenderedRef.panel, {
          actionHeader: REPORT_TITLE,
          hasSolution: false,
          message: MSGS.PDF_ERROR.replace("##MESSAGE##", e.message)
        });
      }
    };
    var deleteReportFile = async () => {
      const folderUri = workspace.workspaceFolders[0].uri;
      const folderPath = folderUri.with({
        path: posix.join(folderUri.path, `${REPORT_FOLDER_NAME}`)
      });
      try {
        await workspace.fs.stat(folderPath);
        workspace.fs.delete(folderPath, { recursive: true });
      } catch {
      }
    };
    var createFolder = async (folderName) => {
      const workSpaceUri = workspace.workspaceFolders[0].uri;
      const folderUri = Uri.parse(`${workSpaceUri.path}/${folderName}`);
      await workspace.fs.createDirectory(folderUri);
    };
    var createPDF = async (content, path, title) => {
      const browser = await puppeteer.launch({ headless: "new" });
      const page = await browser.newPage();
      await page.setContent(content);
      await page.pdf({
        path,
        displayHeaderFooter: true
      });
    };
    module2.exports = {
      createPanel,
      getTemplate,
      renderContentOnPanel,
      renderLoader,
      renderError,
      createPDF,
      createFolder,
      WebRenderer
    };
  }
});

// src/dependency-report.js
var require_dependency_report = __commonJS({
  "src/dependency-report.js"(exports2, module2) {
    var { render } = require_mustache();
    var { window: window2, ProgressLocation } = require("vscode");
    var {
      MSGS,
      COMMON_CSS,
      REPORT_TEMPLATE,
      REPORT_TITLE,
      DEPENDENCY_META
    } = require_constants();
    var { findFile, getFileContent, convertObjectToArray } = require_util();
    var { WebRenderer, getTemplate } = require_web_renderer();
    var webRenderer = new WebRenderer(REPORT_TEMPLATE, REPORT_TITLE);
    var runDependencyCommand = async () => {
      const packageFile = await findFile("package.json");
      if (!packageFile) {
        renderDependencyError(MSGS.PACKAGE_JSON_NOT_FOUND);
        return;
      }
      const fileContent = await getFileContent(packageFile);
      if (!fileContent) {
        return {
          success: false,
          data: "Error: Reading content of package.json"
        };
      }
      const packageJSON = JSON.parse(fileContent);
      const {
        name,
        version,
        description,
        devDependencies: dev,
        dependencies: prod,
        peerDependencies: peer
      } = packageJSON;
      const data = {
        projectName: name,
        version,
        description,
        devDependencies: convertObjectToArray(dev, "name", "version"),
        dependencies: convertObjectToArray(prod, "name", "version"),
        peerDependencies: convertObjectToArray(peer, "name", "version")
      };
      return { success: true, data };
    };
    var createHTMLReport = async (data) => {
      const {
        projectName,
        version,
        description,
        devDependencies: dev,
        dependencies: prod,
        peerDependencies: peer
      } = data;
      const view = {
        commonCSS: COMMON_CSS,
        projectName,
        version,
        description
      };
      let content = render(await getTemplate(webRenderer.template), view);
      content += renderDependency(prod, DEPENDENCY_META.dependency);
      content += renderDependency(dev, DEPENDENCY_META.devDependency);
      content += renderDependency(peer, DEPENDENCY_META.peerDependencies);
      webRenderer.renderContent(content);
    };
    var renderDependency = (dependencyList, meta) => {
      if (!dependencyList || dependencyList.length === 0) {
        return "";
      }
      let htmlStr = `
    <div>
      <h2 class="header-section">${meta.dependencyType} (${dependencyList.length})</h2> 
      <div class="hint ">${meta.hint}</div>
        <table class='table table-sm table-bordered table-dep'>
          <thead>
            <tr>
                <th>#</th>
                <th>Name</th>
                <th>Version</th>
            </tr>
          </thead>
          <tbody>`;
      dependencyList.map((dep, index) => {
        htmlStr = `${htmlStr}
          <tr>
            <td>${index + 1}</td>
            <td><a href='https://www.npmjs.com/package/${dep.name}'>${dep.name}</a></td>
            <td>${dep.version}</td>
          </tr>`;
      });
      htmlStr = `${htmlStr}
          </tbody>
      </table>
</div>`;
      return htmlStr;
    };
    var renderDependencyError = (error) => {
      webRenderer.renderError({
        actionHeader: REPORT_TITLE,
        hasSolution: false,
        message: error || ""
      });
    };
    var dependencyCommand2 = async (context) => {
      await webRenderer.init(context);
      webRenderer.renderLoader();
      window2.withProgress(
        {
          location: ProgressLocation.Notification,
          title: `Reading ${REPORT_TITLE}...`,
          cancellable: false
        },
        async () => {
          const result = await runDependencyCommand();
          if (result) {
            if (!result.success) {
              renderDependencyError(JSON.stringify(result.data));
              return;
            }
            createHTMLReport(result.data);
          }
        }
      );
    };
    module2.exports = {
      dependencyCommand: dependencyCommand2
    };
  }
});

// src/extension.js
var vscode = require("vscode");
var { COMMANDS } = require_constants();
var { dependencyCommand } = require_dependency_report();
var { registerCommand } = require_util();
function activate(context) {
  console.log(
    'Congratulations, your extension "npm-dependencies-ui-geeks" is now active!'
  );
  const dependencyCmd = registerCommand(
    COMMANDS.DEPENDENCY,
    () => dependencyCommand(context)
  );
  context.subscriptions.push(dependencyCmd);
}
function deactivate() {
}
module.exports = {
  activate,
  deactivate
};
/*! Bundled license information:

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

progress/lib/node-progress.js:
  (*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)
*/
